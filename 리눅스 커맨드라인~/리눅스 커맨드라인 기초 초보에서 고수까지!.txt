Src = https://www.udemy.com/course/linux-command-line-colt/learn/lecture/30360870?components=add_to_cart%2Cavailable_coupons%2Cbuy_button%2Cbuy_for_team%2Ccacheable_buy_button%2Ccacheable_deal_badge%2Ccacheable_discount_expiration%2Ccacheable_price_text%2Ccacheable_purchase_text%2Ccurated_for_ufb_notice_context%2Cdeal_badge%2Cdiscount_expiration%2Cgift_this_course%2Cincentives%2Cinstructor_links%2Clifetime_access_context%2Cmoney_back_guarantee%2Cprice_text%2Cpurchase_tabs_context%2Cpurchase%2Crecommendation%2Credeem_coupon%2Csidebar_container%2Cpurchase_body_container#overview

섹션 1 빠른코스 오리엔테이션

	1-1 환영함

커멘드라인이 배우기 어렵따는 편견이 잇는데 사실이아님.
포기하지 말고 익혀 보세요. 파워 유저가돼 보세요. 참여를 많이 할 수 있어요.
많은 개념과 명령어를 배울 수잇어요. 심도잇는 이해를 할 수잇어요. 나무를 볼수도 숲을 볼 수도 잇는 강의~
Broad and narrow~

	1-2 커맨드라인 배우는 이유

구닥다리 같지만 깊은 곳을 다를 수 잇어요. 더 많이 할 수 있어요. 구이나 쿠이나 다 비슷한 것 같지만 쿠이에서만 할 수 잇는것도 잇어요.
서버 시작이나, 프로세스 관리, 숨긴파일다루기, 데이터 베이스 사용, 권한 변경 등 못생겼어도 엄청 많은 걸 할 수 잇삼. 익숙해지면 더 빠름. 하지만 모든 운영체제에 같은 명령어가 적용되는건 아님. 그래도 약간 작업해주면 윈도 기기에서도 동작 가능. 개발자 데이터 사이언티스트 등 사용할 툴의 많은 것이 명령줄에서 자동할 것이다. 클라우드 컴퓨터 같은것도 대부분 사용하고 설정하기 위해 커맨드라인 사용함.

	1-3 슬라이드와 실습 찾기

	1-4 조언한마디
암기하지마세요, 그냥 연습하세요. 자연스럽게 외우세요. 만일 몇달이 지났는데도 기억하지 못한다면 안쓰이는거에요, 필요할때 그 명령어들을 쉽게 찾을 수 잇는 것에 집중하세요.
메모장이됐건 포스트잇이 됏건 잘 찾을 수 잇게 하삼. 정보가너무 많아서 다 못외움.

==========================

섹션 2 소개

	2-1 운영체제
하나의 기기만을 위한 운영체제도 잇음. 닌텐도 위같이
윈도우 nt에서 시작된 운영체제 그룹들이 있음. 엑스박스라던지
쨋든 크게 두가지로 분류할 수 잇음. 유닉스 계열과 마이크로 소프트계열
같은 계열은 커맨드도 공유할 수 잇삼.
https://eylenburg.github.io/os_familytree.htm 운영체제 계보

	2-2 유닉스와 유닉스 계열
유닉스란 몰까 1960중반 벨연구소에서 개발. 그래서 아직도 맥이든 우분투든 같이 공유하는 명령어가 잇음.
다중유저운영체제라든지(다수유저가 한컴퓨터 접속) 계층적 파일 시스템. 폴더나 디렉토리 만들어가기. 등.

사람들이 흔히 말하곤 하는 유닉스의 철학이라는 것은 소프트웨어를 모듈화 시키는 거임. 

현대 유닉스는 상표이며 the open consothium에서 관리하고 있음.

단일 유닉스 규격이라고 하는 표준문서가 잇어서 유닉스 이름을 쓰기위해 필요한 조건이 잇음.

만약 이 기준대로 만들면 유닉스인증 받을 자격이 있는지 테스트함.

맥 osx도 한 10년 전쯤에 이 비싼과정을 거쳐 유닉스로 인정받음. 표준을 만족하지만 인증 안받은건 유닉스 계열이라 불림. 유닉스 이름 사용 못하나 계열에 속하는 것.

명령과 그 개념은 모든 종류 유닉스에서 통함.

리눅스는 유닉스는 아니지만 유사유닉스임

	2-3 원조 유닉스 매뉴얼 살펴보기
https://www.bell-labs.com/usr/dmr/www/1stEdman.html
여기 고대 유닉스 메뉴얼있는데 천공카드 같은거 다루는 명령어랑 신택스도 잇음. 근데 현재는 사용안되는 과거 유물들 많음.
글고 50년전엔 한줄짜리 매뉴얼이엿던 명령어가 지금은 개 긴 명령어도 잇음 대표적으로 find

	2-4 리눅스, GNU, 커널

		역사
1980 자유 소프트웨어 운동시작. 독자 규격을 사용하거나 과한 사용료 요구에 맞선 운동. 사용자 억압에 맞서 표현의 자유를 위한 운동. 
소프트 웨어로 할 수 있는 것을 제한하려 하자 나타난 운동. 
		그누
자유 소프트웨어가 아니었던 유닉스 기능들을 모두 가지고 호환되는 자유 소프트 웨어를 새로 만든 것이다.
		리눅스 커널
리누스 토르발즈가 연구하던 커널인데 딱 자유소프트웨어에, 취지랑 잘 맞아 떨어졌음. 
		커널
운영체제는 아니나 그 핵심요소임. 소프트웨어와 하드웨어간 대화 촉진

		리눅스
커널 자체를 가리키도 하지만 동시에, 리눅스 운영체제를 구성하는 소프트웨어들을 가리키는 단어. 리눅스 이름엔 논란이 잇는데 리눅스 커널과 그누프로젝트의 작업이 합쳐진 결과 물이기 떄문임. 리눅스 자체는 커널이고 완성된 운영체제 아님. 보통 리눅스 사람들이 말하는건 리눅스 배포판인데, 리눅스 커널과 다양한 그누도구 공식문서 패키지 관리자가 잇음.

유닉스 운영체제가 오픈소스라고해도 그 안 산출물들은 전부 closed된 경우가 많은 상태에서 90년대 리눅스가 나온 거임

	2-5 터미널, 쉘, bash 살펴보기

		쉘
운영체제의 인터 페이스가 되는 시스템. 쉘이 커널을 달팽이 껍질처럼 감싸고 잇어서 쉘이라는 이름이 부음.

		터미널

옛날엔 대학이나 기관에서 방하나를 차지하는 큰 컴퓨터에 단 하나의 시스템을 가지고 있었고, 캠퍼스 도서관에 터미널이 있는 형태였음.
그리고 각 터미널은 하나의 컴퓨터에 접근하는 것이였으며, 하나의 물리적 체계 였음. 지금은 소프트웨어 적 터미널임. 운영체제는 기본적으로 터미널 내장하나 따로 다운할 수도 잇음. 쉘을 실행 시키는 어플임. 터미널에 명령어를 치면 쉘이 운영체제로 보냄. 
중간자 역할을 하는 것으로 터미널에서 쉘, 쉘은 그명령어를 운영체제로. 좀더 복잡한데 그냥 그렇다는거임 간단하게 보면. 

		배쉬
배쉬 쉘의 조상 쉘의 책임자의 이름을 따 bourne-again쉘이라고 만듬. 가장 인기 잇는 쉘이며 거의 모둔 유닉스 계열 운영체제에서 동작함.

	2-6 설치로 넘어가보자. 
우분투는 그래픽 사용자 인터페이스도 있는 완전한 운영체제임. 터미널만 있는게 아니라 완전한 운영체제임. 근데 대부분은 맥터미널에도 작동함. 윈도우 파워쉘에서는 같은 명령어를 쓰지 않기 떄문에 설치가 좀 더 힘들 수도 있음. 그래서 우분투를 실행할 수 있또록 가상 머신을 하나 마련해야한다. 맥사용중이라면 두 옵션에 대한 설명이 강의 끝에 잇음. 윈도라면 가상머신 설정하는 법을 확인하면 됨. 

=======
 명령어 기초

	3-1 섹션에서 기억해야할 것.
깊게 다루긴할건데 다 외워야되는건 아님. 트렐로 보드가 있는데 nice to have useful important 등으로 분류해주겟음.
이 섹션에서 중요한건 ncal, date 명령어보다 커맨드 구문 옵션 인자등이 더 중요하다. 즉 커맨드 기초 구조가 핵심이다 .

	3-2 터미널 열기

	터미널 여삼
	
	3-3 프롬프트
프롬프트는 쉘이뭔가를 입력받을 준비가 됏다는 뜻 ㅎ
clear치면 꺠끗해짐. 프롬프트를 멋지게 커스텀할 수도 잇음.
" 쿼테이션 마크 쓰고 치면 프롬프트 사라짐. 다음 쿼테이션 마크로 닫아질때까지 한 명령어로 치는 거임.

	3-4 첫명령어 사용하기

date 명령어. 현재 시간 출력함. 만약 스크립트 같은 걸 작성해 현재날짜를 조합하려하면 도움될 수도?
명령어들 케이스 센시티브함. 우분투 쓰면 명령어 틀렸다고 하면서 원래 치려던게 뭐였을지 추측도 해줌.
맥터미널은 가끔 대소문자 구분 안함. 근데 또 전부 안 하는 건 아님. 명바명. 그니까 걍 케이스 신경쓰삼

ncal 명령어. 뉴캘린더. 현 월의 달력을 세로형으로 출력 cal은 가로형임 

	3-5 터미널에서 방향키 사용하기
좌우 키는 커서 왼쪽 오른쪽으로 이동 가능함. 위아래키는 아에 다름. 전에 입력했던 커맨드들을 순회하는 역할을함!

	3-6 명령줄 인자
커맨드에 띄어쓰기로 인자. 매개변수 또는 피연산자를 구분해 줄 수 잇삼 clear같이 아무 인자 요구않는 커맨드도 잇음.
echo ~ 커맨드. ~ 반환
ncal M Y 해당 날짜에 해당하는 달력반환. 
sort 파일명 해당 파일의 내용들을 정렬해줌.
rm 파일명 파일 하나 혹은 여러개를 제거 함.
컨트롤 c하면 명령어 빠져나올 수 잇음.
특정한 명령어나 인자가 아닌, 그 패턴. 그러니까 공백이라는 형식을 잘 봐주세여.

	3-7 옵션
옵션으로 명령어 동작방식을 바꿀 수 잇음. 옵션을 줄떄는 항상 -를 붙입니다. 해ㄷ암기하지마세요 중요하지 않아요 패턴에 집중하세요.
ncal 하면 디폴트가 현재 날짜에 하이라이트 해주는건데, -h하면 하이라이트 안해줌. 
옵션 자체도 명령어와 같이 대소문자 구분함. -j하면 줄리우스력으로 날짜 표시함. -M 은 먼데이를 주의 시작으로 함.
맥에서는 동작 안함.
-3 하면 전달 현달 담달 달력 볼 수 잇음.
구체적인 옵션 외우는 거는 신경 안씀. 옵션이 -로 시작한다는 형식과 동작을 바꿀 수 잇다는 것 만 알아두삼
사실 극히 일부 옵션에 대해서만 지원함.


	3-8 여러옵션 묶어 쓰기 
cal -3 -j 이렇게 한꺼번에 여러 옵션 적용할 수도 있음
ncal -3jMh 이렇게 줄여서 여러 옵션 적용할 수도 있음.

	3-9 긴 형태 옵션 사용하기
-- 사용 하면 줄임말 옵션이 아니라 하나의 영어단어로 된 옵션을 쓸 수 있음. 결과는 같음. date -u , date --universal
date -universal 이렇게 치면 un이런식으로 옵션 축약형인줄알고 잘못 받아들임.

sort -r color.txt, sort --reverse color.txt 
-u , --unique 정렬중 중복된건 제거하고 출력.
sort -ru
date -u 세계표준시기준 시간 표시.

	3-10 매개변수를 필요로 하는 옵션
ncal -A 3 
-A옵션은 출력해야하는 해당 월 다음으로 몇개월을 더 추가해 표시해야하는지임.
-B옵션은 그 반대

ncal -A3 -B3 이렇게 공백없이도 칠 수 있음.
ncal -A3 -B3 June 1998
ncal -A3 -B3M 
ncal -A3 -B3 -M 옵션이 매개변수랑 공백없이 적혀있을때는 M을 따로 적어줘야함. 옵션과 인자의 순서는 상관 없음. 그래도 옵션을 인자 앞에 넣어주는게 일반적임. 꼭 그래야할 때도 잇음.

=======
 도움말 확인하기
	4-1
이 섹션에서 꼭 기억해야할 것들

Important 
The man pages
Navigating a man page
맨 명령어와 맨 페이지 이해, 맨 페이지 탐색

Nice to have
The 7 manual page sections

Useful(not as important)

Type, which, help command

	4-2 매뉴얼 소개
맨페이지는 매뉴얼 페이지의 준말임. 유닉스 계열 운영체제 대부분에 있는 내장된 문서들임. 맥 우분투 둘다 동작
명령어나 전반적인 시스템에 관한 정보를 찾을 수 있음.
man 명령어 하면 설명들을 수잇고 q누르면 빠져나옴. 

	4-3 맨 페이지 탐색 및 검색
우아래 방향키로 스크롤 할 수도 있는데. 긴문서에 대해서는 스페이스바나 f 한번 누르는거로 한 페이지 단위 이동 가능함. b를 누르면 페이지 단위로 뒤 로 이동가능함.
h눌러보면 less 커맨드 목록나옴.
/pattern으로 현재 명령어에서 찾고 싶은 부분 찾을 수 잇음.

	4-4 맨 페이지 시놉시스 자세히 알아보기
맨 명령어를 써보면 이름과 시놉시스(신택스) , 디스크립션(옵션) 확인 가능.
[] 괄호 안에들어가 있는거는 선택적 요소임. 즉 쓰건 안 쓰건 자유라는 뜻. 
ncal [-3hjJpwy] [-A number] [-B number] [-s country_code] [[month] year]
-3hjJpwy 는 옵션을 축약한 것. [-A number] [-B number] [-s country_code]는 매개변수를 따로 받는 옵션이라 따로 적은 것.


cp [-R [-H | -L | -P]] [-fi | -n] [-apvX] source_file target_file
필수 인자를 가지고 있음.

	4-5 7개의 메뉴얼 섹션 및 그 검색
메뉴얼에는 8개의 섹션이 있다. 유저 명령어는 그중 하나일 뿐이다. 다른 섹션에 대해서는 자주 접하진않을 거지만 알아두면 좋다. 
이름은 같지만 서로 다른 섹션에 다르게 기록 돼 있는 정보도 있음. 
man -k 키워드 하면 키워드가 포함된 메뉴얼들에 대한 짧은 기술과 함꼐 섹션 번호를 반환한다.
man 세션번호 메뉴얼명 하면 그 미뉴얼에 대한 메뉴얼을 받아볼 수 있다.


	4-6type과 which 명령어
명령어의 유형에는 4가지가 있다.
실행 가능파일(컴파일드 바이너리 파일(bin))
빌트인 쉘 커맨드(이 명령어들은 쉘의 일부임)
A Shell function
An alias(별칭, 커스텀 명령어)
type명령어 사용하면 명령어의 유형 파악 가능.

	Which
명령어의 타입을 반환하진 않으나 위치를 반환함. 빌트인 쉘에 대해선 help로 설명 볼 수 있음. 
========
색션 5 파일 시스템 탐색
	5-1 이 섹션에서 꼭 기억해야 할 것들

Important

pwd command 
ls command
cd command
root&home directories
relative and absolute paths

nice to have
overview of other folders

	5-2 루트 디렉토리
파일 시스템, 컴퓨터의 폴더 구조 탐색. 전체 파일의 시작. 리눅스 배포판이나 wsl나 맥이나 최상위에 루트 폴더가 있다.
윈도우에는 씨, 디 드라이브가 잇는 것처럼.근데 root라는 이름을 가진 \(루트폴더)의 하위 폴더도 있다. 단순 파일 탐색기에서 루트 폴더 들어가는건 불가능함.
터미널에서 xdc-open 치면 루트폴더 구이로 오픈 가능함. 수만은 폴더가 있는데 어떤건 접근조차 불가 x라고 적힌 디렉토리는 접근 권한이 필요함. 굳이 그 안을 보려면 인증이 필요.
맥에서는 open명령어로 파일을 열수 있는데 open \ 하면 루트폴더 접근가능.

	5-3 홈 디렉토리
홈 디렉토리 안에는 사용자 관련 정보가 있다. 그리고 모든 사용자는 각자이름으로 된 서브디렉토리가 있다.
		각유저의 폴더에는 뭐가 있을까
파일이나 사용자 데이터등 특정유저에 대한 모든 것이 있다.
xdg-open ~ (현재 접속중인 사용자의 홈디렉토리를 갈킴)

	5-4 pwd
print working directory. 현재 내가 작동하는 폴더 디렉토리를 표시함. 기본 터미널을 실행하면 디폴트 위치에서 시작하겠지만 특정 폴더로 들어가 터미널 열면 해당 폴더에서 작업디렉토리 출발가능. ~$ 이거 자체도 홈디렉토리 말하ㅡㄴ거임.

	5-5 list
디렉토리 안 콘텐츠를 보고 싶을때 사용  list 폴더명(해당 폴더의 콘텐츠 반환), list \(루트 디렉토리의 하위컨텐츠들 반환) ls로 반환받았다고 해서  pwd가 바뀌는 건 아님

	5-6 list 유용 옵션.
ls와 함께 사용 할 수있는 몇가지 중요한 옵션이 있음. 
-l 출력리스트에 파일이나 폴더에 대한 정보를 보여준다. 훨씬 더 자세한 정보 보여줌. 
누가 이 폴더에 읽기 쓰기 실행 권한이 있는가? 오너, 그룹 , 최종 수정일자, 폴더의 크기(가상머신은 최소의 크기만 사용함 그래서 같은 크기로 보임) 나중에 권한관련 작업할때 유용
-a 숨겨진파일 숨겨진 디렉토리 포함해서 다 보여줌. .로 시작하는 것도 다 보여줌. gui에서는 세팅에서 숨김파일 표시를 해야 보이는 폴더들. 설정파일들이라 일반유저들을 상관할 필요 없는 파일들임.
-h -l로 폴더 바이트가 출력될때 가독성 좋게 단위를 붙여서 출력해줌.
-S 하면 사이즈가 큰 파일부터 정렬 걍 직접 검색해보샘 필요한 기능잇는지.

	5-6 cd 작업 디렉토리 변경하기
드디어 작업 디렉토리 변경 가능. ls . 하면 현재 디렉토리 표시 ls .. 하면 부모 디렉토리 리스트 표시. (. 현재폴더 .. 부모폴더)
-a 옵션쓰면 서브 컨텐츠로 . .. 도 뜸.

	5-7 상대 경로와 절대 경로
cd 서브디렉토리 는 직접적으로 연결된 하위 경로에서부터 시작하는 상대주소임. 직접적인 하위 관계일때만 쓸수있음. 두단계 아래 내려가고 싶으면 cd sub/sub2 이런식으로 주소 작성해야함.
cd /~/~/~는 루트 폴더에서부터 경로를 적어내려가기 시작하는 절대 주소임. 현재 작업주소공간이 어떻든 절대적 공간으로 이동할 수 있음.

cd / 루트 디렉으로 이동. 절대주소랑 같은 개념. cd ~ 사용자 폴더로 이동. 절대 주소작성시 사용자 폴더에서부터 cd ~/adf/asf이런 식으로 작성할 수도 있음.

	5-8 기타 폴더 들. 
루트폴더의 서브디렉토리들. bin 바이너리의 준말. 엄청나게 많은 실행 파일. media는 이동식 미디어에 연결되는 위치. usd드라이브나 sd 카드.
var폴더는 수많은 파일.. 생성된 로그 파일에 로그정보 기록. 슬래시디렉토리말고 그냥 폴더이름이 root인 것도 잇음. cd접근 불가한데 이 폴더가 root라는 사용자 계정의 홈폴더 이기 떄문임. 모든 리눅스에는 root라는 사용자 파일이 있는데, 슈퍼 유저임. usr 디렉토리. 실행 파일과 각종 라이브러리, 다양한 프로그램으로 가득. 소프트 웨어를 설치하거나 새로운 명령어를 설치하면 이 설치파일 어딘가로 오게 됨.

	5-9 실습
매뉴얼 명령어 안에 들어있을때 /키워드 치면 해당 키워드를 포함하는 것 검색해냄. 컨트롤 f마냥.

========
섹션6 파일 및 폴더 생성

	6-1 이섹션의 핵심
important

touch command
mkdir command

nice to have
file command

useful

파일명 지정에서 유의할점.

	6-2 touch 명령어로 파일 생성.
새로운 파일 또는 여러개 파일을 생성할때 사용하는 명령어임. touch 파일명 으로 작업 폴더에 파일 생성할 수 있음. 굳이 확장자 안적어줘도 됨. 확장자랑 상관없이. 그 이름에 맞는 파일을 만들어줌(확장자명 포함) 그리고 꼭 pwd에서만 가능한건 아님. touch ../novaf 이런식으로 상위 폴더로 이동해 novaf라는 파일을 만들 수 있음. touch ~/dkj 이런 식으로 사용자 폴더에 만들 수 도 있음.

	6-3 touch 명령어가 touch라는 이름을 갖게 된 이유?
왜 make도 create도 아닌 touch라는 명령어명이 파일을 생성하게 된걸까. man touch 해보면 change file timestamps 라고 돼 있음. 
설명을 보면 파일접근 및 수정시간을 업데이트 한다고 돼 있음. 파일이 뭐든 간에 파일 접근 및 수정시간을 현재 시간으로 업데이트 함. 근데 존재하지 않는 파일 인자는 비어있는 상태로 생성한다고 써져 있음. 이걸로 생성한거. 이미 있는 파일 건들면 수정시간만 업데이트 함. 사실상 주기능보다 부기능이 더 쓰이는 거 ㅋ
touch a b c d e f g h 한꺼번에 여러개 파일 생성 가능해서 빠름

	6-4 파일 종류와 확장자
file 파일명 이라는 명령어가 있는데 현재 파일의 확장자 명과 그에 관련된 설명들을을 한다. 이름에 확장자명을 전혀 다른 것으로 바꾸더라도, file 파일명 을 해보면 운영체제는 파일을 여전히 원래 확장자로 인식한다. 즉 이름내 확장자명은 운영체제가 이 파일을 어떻게 인식하느냐와는 관련이 없다. 하지만 운영체제 위 서비스에서는 문제가 생기는데. 일반적으로 이름의 확장자 명대로 파일을 열기 때문에 운영체제를 교란 할 수 있다. 그렇기 때문에 확장자명을 전혀 동떨어지게 적으면안된다. ( 터미널에서 파일명 치다가 탭 누르면 하위 컨텐츠 중 해당 하는 이름 가진 컨텐츠로 자동완성함)

	6-5 파일 명: 좋은 예, 나쁜 예, 못난 예
touch를 사용해 파일을 생성할때 피해야 하는 사항. directory 명령어를 사용해 폴더를 생성하는 법에 대해 배울때도 마찬가지이다.
포함하는 걸 피해야할 몇가지 문자들이 있다. 쉘에서 특별한 의미를 가지는 특수 문자들.. 숫자 문자 하이픈 대시 이런 종류는 괜찮으나 공백은 무조건 피해야함. 
터미널에서 공백은 인자끼리의 구분임. 공백있는 문자열을 하나로 인식시키고 싶으면 따옴표 쓰는 방안이 있겠음 touch "my website"
하지만 만들고 나서도 짜증남. 중간 공백때문에 같은 문제에 봉착 하기 때문임. 똑같이 따옴표 쓰면서 명령어 쓰던가 \이런 역슬래시. 이스케이프 문자를 사용하는 법도 있겠음.
이스케이프 뒤 문자는 이게 특별한 의미를 가지고 있지 않다는 걸 보증받는 역할을 함. 이게 심각한 영향을 끼치는건 아닌데 공백 넣는게 그냥 사람을 번거롭게 함.
대쉬나 언더스코어, 카멜케이스라고 불리는 식으로 공백대신 쓰삼. myWebsite my-website my_website 다른 특수문자도 이스케이프나 따옴표 거치면 사용은 할 수 있는데 귀찮아서 걍 넣지 마삼.
파일명은 대소문자에 따라서 완전히 구분됨.

	6-6 mkdir명령어로 디렉토리 생성
터치가 파일을 생성했다면 얘는 디렉토리 생성. 똑같이 절대주소나 상대주소 사용해서 만들 수 있음.  현 pwd와 하층적으로 직접 연결된 디렉토리만 만들 수 있는데 -p옵션을 넣으면 하위에 하위 폴더라도 그 경로 상에 있는 폴더 다 만듬.

	6-7 파일 및 디렉토리 생성 실습
========
세션 7 Nano 텍스트 편집기
터미널을 나가지 않고 직접 파일을 열고 수정할 수 있는 프로그램. 엄청 중요하진 않음. nano를 전혀 쓰지 않는 개발자도 있기 때문임.

	7-1 이 섹션의 핵심 주제 : nano
important


useful
opening Nano
Nano Shortcuts

nice to have
configuring Nano & spellcheck

	7-2 nano소개
독립적 에디터 없이도 명령줄 기반 에디터만 충분히 잘 사용하면 빠르고 효율적으로 작업 할 수 있다. 하지만 러닝 커브가 있음. 명령줄 기반 에디터가 또 유명한게 많지도 않음.
나노는 배우기 쉽고 유저 친화적임. vim과 emacs가 더 흔함. 기능이 더 많지만 초반에 많이 힘듬. nano도 많지만 않지만 충분함. 쉘 내장임. Nano is ANOther editor의 준말임.
피코라는 90년대 편집기의 후속작임. 피코 나노 마이크로라는 네이밍센스 

	7-3 nano기초
상하 좌우키로 커서 왔다갔따 가능. nano 파일명으로 파일 열고 수정가능. 저장은 write out. ^o키로 가능. 그리고 파일명 정할 수 있는데 적고 엔터 누르삼. 그냥 저장 취소하고싶으면 ^c. exiting은 ^x키로 가능. ^s하면 이모든걸 생각하고 바로 저장 가능.

	7-4 nano로 파일 생성하기
굳이 터치로 파일 만들고 빈파일 나노로 열어 수정하지 않더라도. 나노로 없는 파일 열어서 만들고 저장하는 식으로 새 파일 만들 수 있음.

	7-5 nano 단축키 정복.
나노편집기 열었을때 밑에 적혀있는건 사용할 수 있는 명령어 가운데 일부일 뿐임. 컨트롤 g 하면 모든 단축키 종류가 뜸. 이 단축키들이 그런데 모두 컨트롤키와 함께 쓰이는 건 아님.
M이라고 써진 단축키도 있는데 이건 문자가 아니고 메타키임. 옛날 키보드 배열에는 메타키라는 게 있었음. 윈도우에는 요즘 없는데 맥에는 있음. 이스케이프 키가 메타키임. 윈도우 에선 메타 대신 옵션이나 알트키 씀. 근데 나노 키가. 시스템의 일반적 단축키랑은 다르다는 걸 알아야함. 헷갈릴 수 있음.

	7-6 nano로 찾기, 바꾸기.
컨트롤 w는 파일내에서 검색하는 한가지 방법임. 메타키랑 달러키 한꺼번에 누르면 편집기에서 자동으로 문장 줄 안바뀌는거 바꾸게 할 수 있음 맥터미널에선 esc네. 컨트롤 w하면 검색 기능 활성화 되는데. 백워드라든지 포워드 라든지, 케이스 센서티브하게 검색할 것인지 등 여러가지를 고려해 사용할 수 있음.
리플레이싱 기능 도 있는데 컨트롤 역슬래시 하면 됨. 검색하기와 똑같이 케이스 센서티브 하게 대상을 지정할건지 등을 선택할 수 있고 대상 지정후 바꿀 내용까지 제출하고 나면 하나씩 확인하면서 바꿀 것인지 체크한다. a누르면 체크 안 하고 전부다 바꿀 수 있음. gui 없는 cli 로 작업해야 되는 상황이 올수도 잇으니 열심히 공부

	7-7나노 환경설정 및 철자 검사
컨트롤 t하면 철자 검사 해서 오타 없는지 확인 함. 철자검사 기능이 비활성화 돼 있을 수도 있음. 이때에는 나노 설정 파일을 수정 해야함.
나노 설정파일은 /etc/nanorc etc 디렉토리에 nanorc파일에 있음. 나노로 이 파일 열어도 unwritable 이라는 글이 반겨줄 거임. 언라이터블 함. 권한 문제임. sudo 쓰면 댐.
## Use this spelling checker instead of the internal one.  This option
## does not have a default value.
# set speller "aspell -x -c"

## Allow nano to be suspended.
set suspend
번호 기호라고하는 #이 안붙어 있음. 즉 활성화 돼 있다고 할 수 있음. 왜 안되냐 설정 다 바꿨는데

========
섹션 8 삭제 복사 이동

	8-1 섹션 핵심
important
rm command
rm -d & rm -r
mv command 
cp command

useful


nice to have


	8-2 rm으로 파일 삭제하기
rm으로 삭제하면 휴지통도 안가고 바로 삭제됨. rm 파일 명.

	8-3 폴더 삭제하기
-d --dir 옵션을 사용하면 '빈' 폴더 삭제 가능. 빈거 아니면 삭제 안댐.
rm -d or rmdir이라는 명령어 사용 가능. 빈거만 삭제할 수 잇음.
rm -r or rm --recursive 는 재귀적으로 해당 폴더의 하위폴더까지 싹 삭제해 버림. 큰사고가 될 수도. 권한이 작동하지 않을 수도. 운영쳊제가 파괴돌 수도
rm -i or rm --interactive 삭제시마다 확인메시지가 표시됨. 안전장치가 더해진거.
-I 옵션은 일정 기준치 이상일때만 발동한다. 많은 실수들에 대한 보호를 제공하는 반면 i보다는 덜 시끄럽다.

	8-4 mv로 파일 이동하기. 
mv source destination gui 에서 폴더간 계층차이 나면 옮기기 넘힘듬. 한번에 여러 파일 옮기려면
mv one two three four destination 마지막 경려만 path로 인식되는 듯?

	8-5 디렉토리 옮기기
파일옮기기와 형식은 같다. 단 다수의 폴더를 옮길때 꼭 폴더들이 같은 곳에 위치해야하는 것은 아니다. 절대주소든 상대주소든 올바른 곳을 참조하고 있으면 된다.
따라 파일과 폴더의 이름을 바꾸지 않고 위치만 다른 곳으로 이동시키고자 할 경우 목적지 폴더가 반드시 실제로 존재해야 한다.

	8-6 mv로 이름 변경하기

파일, 폴더 1개등 소스 한개에는 가능하나 여러개 동시에는 불가함. 
mv 소스 새로운 이름. 데스티네이션을 아직 존재하지 않는 폴더나 파일이름으로 설정하면 이름 바뀜.

	8-7 cp로 복사하기
파일 및 디렉토리의 복사본 생성

cp one or more source. 데스티네이션
-r 옵션은 rm의 -r 옵션과 비슷하다. -r을 사용해 하위폴더를 포함하는 모든 것들을 한꺼 번에 옮길 수 있다.

========
섹션 9: 단축키와 히스토리
	9-1 이 섹션의 핵심 주제
important
useful
history command
nice to have
clear shortcut
jump line shortcut
jump character shortcut
jump word shortcut
kill line shortcut
yank shortcut
history expansion

	9-2 줄을 지우고 점프하기
새로운 명령 배우기는 멈추고 유용한 단축키에 대해 배우겠다. 터미널에서 사용가능한 단축키. 보통 단축키들은 해당 동작의 앞글자를 딴다던지 하는식으로 연관성을 가지는데
터미널 단축키는 키보드에서 손을 떼지 않을 수 있도록 설계되었다. 

컨트롤 l 명령어 clear과 비슷한 동작을 한다.

위쪽 방향키를 누르면 이전 사용한 명령어가 나온다.

컨트롤 a 라인 점프를 할 수 있다. 컨트롤 a하면 프롬프트상 명령어를 치고 있는 제일 앞으로 컨트롤 e하면 제일 뒤로.
컨트롤 e 나중에는 파이프라인을 사용해 명령어를 한꺼번에 많이 입력하게 되는데 단축키 사용할 수 있으면 매우 좋음.

	9-3문자와 단어 점프하기
컨트롤 b, f 로 방향키 쓰는 것과 같이 커서를 앞뒤로 움직일 수 있음. 사실 방향키 써도 상관없는 것들인데 터미널 단축키 특징에서 언급했듯이 키보드 중앙에 손을 떼지 않기 위해 설계된 듯.
알트 b f 로 단어단위(띄어쓰기 구별)로 커서를 앞 뒤로 움직일 수 있음.

	9-4문자와 단어를 교체하기
컨트롤 t 해당 커서의 뒤문자와 위치 바꿔줌
알트 t 하면 단어 단위로 위치 바꿀 수 있음 . 단어 순서를 바꿔줌!

	9-5줄, 단어 단위 지우기 등등
컨트롤 k 를 사용하면 해당 커서의 뒷부분까지 다 날려버릴 수 있음.
컨트롤 u 하면 반대로 해당 커서의 앞부분 다 날려버림. 컨트롤 ak 조합으로 한줄을 날려버릴 수도 잇음

알트 d 하면 그 줄 단위가 아니라 단어 단위로 뒷부분 지움. 
반대로 컨트롤 w하면 커서 뒷부분 지움.

컨트롤 d하면 백스페이스나 델리트 키로 지우는 것과 달리 커서의 뒷부분을 지울 수있음. 델레트는 앞부분이잖아.

	9-6 킬링으로 부터 붙여넣기
단어나 줄 단위를 지우게 되면 메모리. 킬 ring이라는 곳에 잠시 저장이됨 . ctrl y 로 다시 불러올 수 있음. 클립보드랑 비슷한데, 복사하고 붙여넣는게 아니라 지우고 붙여넣는 거임.
즉 지우는 행위 자체를 킬링이라는 메모리에 임시 저장시키는 용도로 쓸 수 있음.

	9-7 history 명령어와 히스토리 확장
이미 사용한 명령어들에대한 목록을 볼 수 있음. 걍 방향키로도 전에 썻던 명령어 다시 불러 올 수 있지만 오늘 아침이라던지 좀더 넓은 범위로 확장하면 좋은 방법이 아닐 것임
history 를 치면 그동안 사용했던 명령어들에대한 기록을 볼 수 있따.
history | less 를 사용하면 man명령어처럼 스페이스바를 통해 페이지를 이동해가며 볼 수 있다. 보기 싫으면 q를 통해 나갈 수도 있음.
그리고 !히스토리 번호를 사용하면 긴명령어를 다시 칠 필요없이 바로 실행 가능하다.
스크롤하기 귀찮지만 입력하기가 더 귀찮을때 자주 쓴다. 근데 다른 옵션도 있음
히스토리 검색이라는 거임.
컨트롤 r 하면됨. 이거 쓰면 기존에 내가 사용했던 명령어 히스토리에서 타이핑한 것과 매칭시켜서 추천해줌.
근데 예를들어 c랑 관련된걸 계속 찾아보고 싶다. 하면 컨트롤 r을 여러번 눌러 보삼 히스토리가 길어서 눈으로 찾기 어려울정도면이게 더 나음.

히스토리 목록들은 ~/.bash_history 에 저장이 된다.

echo $HISTFILESIZE 최대 히스토리 저장 개수를 반환한다.
echo $HISTSIZE 현재 히스토리 저장 개수를 반환한다. 

여기서 다루진 않지만 .bash_config .bashrc파일 에서 히스토리 최대 개수등을 수정할 수 있다.

========
섹선10 파일로 작업하기
	10-1 이 섹션의 핵심 주제

important
cat
less
head
tail
sort command

useful
wc command
fancy sort stuff

nice to have

tac command
rev command

	10-2 cat 명령어
결합하다의 concatenates 축약형. 편집기를 사용하지 않고도 파일을. 출력해 읽을 수 있다. cat 읽고자하는 파일 이름. 읽기 전용. 모디파이하는건 없삼. 나노 쓰면 귀찮

만약 인자에 여러개의 파일을 넣으면, 콘카테네이트 이름값함. 각 파일 이어 붙여버림.

옵션같은건 써본적 없음.

이명령어와 다른 명령어를 이용해 새로운 결과로 저장할 수 있으나 여기선 다루지 않음. 거의 파일을 합칠 때 사용했고, 리 다이렉션에 대해 배울때 사용했다.

	10-3 less 사용하기

less 명령어. 
less 파일명 less 는 cat 처럼 쓸 수 있다. 단 man에서 사용했던 것처럼 똑같은 단축키를 가지고 열 수 있다. 
스페이스나 f를 이용해 다음 페이지로 넘어갈 수 있고 b를 통해 되돌아 갈 수도 있다. ㅇ엔터나 방향키로 한줄씩 내릴 수도 있고 검색을 위해 슬래쉬 칠 수도 있음. 나가기 위해 q치면 됨.
같은 거를 계속 검색하면 다음으로 넘어가면서 검색함. 

	10-4 tac과 rev

tac은 cat 의 반댓말임. 파일의 각각의 줄들을 마지막 줄부터 출력함. 연직 역순출력 파일을 수정하진 않으나 그냥 단순히 거꾸로 출력함.
cat 처럼 여러개 요소 쓰면 잇달아 출력함. 줄에 접근하기 편하게 출력하는 용도.

rev도 비슷한 기능을 함. 하지만 tac이 글 전체에서 줄을 뒤집었다면 cat은 줄 안에서 글을 뒤집음. 단 거꾸로 출력만 할뿐 파일 자체에 수정을 가하지는 않음.

	10-5 head와 tail
헤드 명령어는 파일의 앞부분을 출력함. 디폴트는 앞 첫 10줄.
테일 명령어는 반대임. 디폴트는 뒤에서 첫 10 줄.       헤드와 테일 모두 -n 옵션으로 출력할 라인을 정할 수 있음. -head -n 21 -tail -n 21 -head -n5
-c 옵션도 있는데 출력할 바이트 수를 의미함.
tail에 -f옵션도 있는데 이건 실시간 출력임. 즉 명령어 입력후 명령어 닫고 다시 프롬프트 여는게 아니라 계속 리스닝 상태에서 모니터링 감시함. 로그등 실시간 변화하는 자료 볼때 유용.
컨트롤 c하면 빠져나올 수 있음

	10-6 wc명령어
파일 안의 단어수나 라인수, 바이트 수를 세준다. 기본적으로 이 세개를 출력한다' 단어,라인,바이트 수
파이프라인, 리디렉션으로 다른 명령어랑 함께 사용하면 컴퓨터에서 얼마나 많은 패턴이 일치하는지 특정 문자열을 포함하는 파일 수가 몇개인지등 유용하게 쓸 수 있음.

파일 안의 줄 수. 단어의 수. 바이트의 수. 이름 출력. 이게 디폴트고 하나의 값만 얻고 싶으면 옵션을 사용하면된다. 
-l, -w,  -m 문자의 수 -c바이트의 수.

	10-7 sort 명령어
cat head tail 같이 내부 내용은 바꾸지 않고 출력만한다 . 다른 명령의들의 결과로 새로운 파일을 만드는데 사용할 수 있다.

파일의 모든 줄을 알파벳 순으로 정렬하는게 디폴트. 

알파벳간 비교시 소문자가 대문자보다 앞에 나옴. a c A C d D r R x X z Z y Y -> a A c C d D r R x X y Y z Z

숫자간 비교시 첫 숫자 기준으로 각 자리 수 하나 씩 비교해 정렬함. 9.0 500.00 0.00 -> 0.00 500.00 9.0
옵션 -n을 사용하면 숫자간 비교 가능. -r은 리버스 출력. -u은 유니크로. 중복요소 제거 출력.
예를 들어 파이프라이닝이나 리디렉션 이용해 ls를 정렬해 출력한다던가 하는 식으로 활용 가능.

	10-8 데이터 열을 이용해 정렬하기
sort로 할 수 있는 멋진 것들 중 하나는 특정 데이타나 열등으로 정렬할 수 있다는 것이다. 
데이터 분석을 시작한다면 sort를 사용하진 않을 것이다. 쿼리를 보내거나 전송하거나 조작하기에 더 좋은 데이터 베이스에 저장 돼 있는 데이터를 사용하거나 할 것이다.

apple 4.1
banana 2.1
cat 5.1
fire 11.1
hot 9.11
egg 10.11
이런식으로 전혀 다른 자료형의 문자가 있으면 옵션을 적용한다 해도 일괄적 기준으로 분류하기 힘듬. 이떄 사용하는게 sort data.txt -nk 2 이런식으로 -k2 이런식으로 해당 기준 칼럼을 지정후
분류하는 형식이 있음. 칼럼은 공백문자 기준으로 구분됨.

========

섹션 11: 리디렉션
	
	11-1 섹션에서 중요한것
important

redirecting standard output
redirecting standard input 
redirecting standard error

useful

nice to have
fancy shortcut syntax

	11-2 표준스트림 개요

표준 스트림. 표준 출력 입력 에러. 세가지 요소로 나뉘어진다. 표준 출력의 예로는 터미널의 결과 출력이 있다. 하지만 터미널 말고도 프린터출력이나 문서저장과 같은 방식을 할수도 잇음.
명령이 잘 수행되면 내용을 저장하거나 파일로 출력하거나 다른 명령어를 수행시키면서 에러가 있을때는 파일로 따로 저장하게 할 수 있다. 다양한 방법으로 구성할 수 잇음.
둘다 터미널에 출력되는 결과임.
표준 입력은 명령에 입력되는 데이터로 일반적으로 키보드임. 지금까지는 명령어와 입력인자만 있었지 표준 입력ㅇ로 데이터를 입력해본 적이 없음. 
원래 있던 파일로부터 명령을 실행하는 것은 방금 본 것과는 다르다. 출력이 입력이 될 수도 있음. 리다이렉션. 지금까지는 표준 입력을 이용한 명령어를 보거나 사용한 적이 없음.
명령어와 인자로 실행하는 방식과 표준입력을 주는 방식은 다름.

	11-3 표준 출력의 리다이렉션
표준 스트림의 세요소중 첫번쨰 출력의 리다이렉션을 해보자. 표준 출력과 에러에 대해서 터미널 창 출력 대신 파일에 저장하는 것으로  표준 입력의 출력을 다른 명령의 결과로 바꾸는 것임. >기호 사용
명령어 > 파일명. 명령어의 결과를 파일로 리디렉션 함. 중복 리디렉션하면 새로운 값으로 덮어 씌워짐. /usr/bin에 많은 명령어 들이 있음. 파일명에 적절한 경로 입력하면 다른 폴더에 파일 저장도 가능. 터미널엔 아무것도 표시하지 않고, 대신 파일에 저장하는 거임.

ls /usr/bin > list.txt
sort -k5n > sorted_list.txt
리디렉션으로 파일을 만들고 그 파일로 명령어를 처리해봣다. 

	11-4 표준 출력 추가.
리디렉션 어펜딩(기존 정보 보존하고 덮어 씀) >>
echo 명령어의 표준출력을 터미널 출력말고 리디렉션 할 수도 있음
오버라이트와 어펜딩.

	11-5 표준 입력의 리디렉션
필 없을 것 같은데 파이프라이닝 할때 도움 많이 됨.
command filename 은 단순히 인자로 받은 명령어를 처리하는 거지 표준입력을 받는게 아님.
command < filename 하면 같은 출력 값을 가지나 표준 입력이라볼 수 있음.
그냥 단순히 command 만 치면 프롬프트가 없어지고 계속 커서가 점멸하는 리스닝상태에 들어가는데, 이게 일종의 표준 입력 상태임.
	
	11-6 표준입력과 출력을 동시에 리디렉션하기
표준 입력과 출력을 동시에 리디렉션해서 명령어를 사용해보겠음.

cat < original.txt > output.txt 입력 리디렉션, 출력리디렉션.
파일 하나를 읽어 리디렉션 한 뒤에 이미 있는 파일에 덮어 쓰거나, 새로운 파일을 만드는 과정임. 이때 original은 명령어의 인자가 아니고 명령어에서 인자가 없을떄 필요한 표준 입력을 제공 해줌.
이건 그냥 표준입출력 리디렉션이 동시에 가능하다는 걸 보여주는 예일 뿐이고, cat original.txt > output.txt해도 같은 값 산출 가능.

	11-7 표준 에러 리디렉션
에러를 파일로 저장해 기록을 남기는 경우 많이 사용한다. 
cat nonexistent file 2> error.txt
왜 2 일까. 모든 표준 스트림은 세개밖에 없긴 하지만 각각 파일 디스크립터라는 번호가 있다.
표준 입력은 0, 출력은 1 에러는 2. 근데 입출력은 많이 쓰이기 때문에 파일 디스크립터 번호를 적지않는게 디폴트임. 에러는 디폴트가 아니라 써줘야댐.

	11-8 한번에 리디렉션 하기와 멋진 단축키들.
cat bees.txt ants.txt > insects.txt 2> error.txt
한 명령어에서 표준 출력과 표준 에러를 동시에 리디렉션 가능. 여러스트림을 동시에 리디렉션.
이렇게 두개동시에 리디렉션 할때는  표준출력을 먼저 적어야댐. 출력의 디스트립터가 1이고 더작으니까 먼저한다고 생각하삼.

표준 출력과 에러를 같은 파일에 저장하는 멋진 구문도 있음. 
2>&1 사용. 2번을 1번으로 리디렉션 하라.라는 뜻임 &1은 같은 파일 이름을 두번쓰는 대신 표준 출력을 뜻하는 1로 줄여쓰는 것과 같다.
종종 필요함. ls docs > output.txt 2>output.txt . ls doc > output.txt 2>&1 output.txt

최신 bash에서만 작동하는 더 멋진 구문을 살펴보겠다. 
ls docs&>output.txt 이런 식으로 더 간단히 아웃풋 에러 모두 저장 가능. 최신에서만 사용가능.


========
섹션 12 파이프
	12-1 이 섹션의 핵심 주제
important
piping

useful
tee command

nice to have
tr command

	12-2 파이프 개요.
명령어가 표준입력을 받는 것이 얼마나 중요한지 보게 될 것이다. 파이프는 |문자를 사용하며 파이프라인 만드는 것을 의미한다. 
두 명령어를 연결하귀위해 |을 이용하면 한 명령어의 표준 출력을 두번쨰명령어의 표준 입력으로 이어줄 수 있다.
command1 | command 2
표준 입력을 배울때 왜 표준 입력이 필요한가 이해가 안됐을 것이다. 
date | rev 하면 rev라는 명령어는 표준입력이나 인자를 기다리는 명령어임. 인자가 없으면 리스닝 상태로 들어감. 그런데 저렇게 파이프라이닝 치면 결과를 출력해줌.

	12-3 파이프 써보기
less 명령어는 cat 과는 다르게 출력물들을 /로 검색할 수도 있고 스페이스바나 단축키를 이용해 페이지 단위로 훅훅 넘길 수잇음.
ls 같은 명령어 아웃풋이 너무 복잡할떄. 파이프라인 활용 가능. 그리고 터미널로 돌아가도 깨끗함 
ls /usr/bin -l | less
ls /usr/bin -1 | wc -l
이렇게 하면 l에서 각 명령어들이 한줄로 처리 될 뿐만 아니라 맨 윗줄의 total라인수는 빼고 표시해 순수한 라인수가 몇개인지 샐수 있다.

	12-4 리디렉션과 파이핑 비교
리디렉션과 파이핑 모두 아웃풋을 리디렉션하는데 사용되지만, 다른 방식으로 작동한다. 둘다 표준 스트림을 이용하는 것은 같다.
리디렉션은 파일에 명령어를 연결하고 파이핑은 다른 커맨드에 커맨드를 연결한다. 즉 리디렉션은 파일이 필요하지만, 파이핑은 필 없음.
ls /usr/bin -1 | wc -l > count.txt

	12-5 막간을 틈타 tr 명령어 배우기
이 명령어는 표준 입력이 필요하다. translate or delete characters. squeeze, translate or delete characters from standard input, writing to standard output. 어떤 문장의 대문자를 소문자로 바꿔준다던가 특수문자를 다른 특수문자로 바꿔주는 역할을 함.

문자를 편집하거나 변환하는 여러 방법중 하나임.
사실 tr은 텍스트를 바꾸기 좋은 명령어가 아니고 sed가 더 좋음
awk나 mawk를 사용하는 방안도 있음.
cat msg | tr s S s를 S로
cat msg | tr s a
cat msg | tr a-z A-Z 모든 소문자 대문자로.
cat msg | tr -d s 모든 s제거하는 옵션
cat data.txt | tr -d [:alpha:] (나중에 find, grep 명령어를 더 다룸.
[:alpha:] 는 대소문자를 가리지 않는 모든 문자를 뜻함. 
[:lower:][:upper:]같은 것도 있음.
cat data.txt | tr -d [:alpha] | tr -d : | tr -d [:blank:]
이렇게 공백과 문자와 세미콜론 모두 지울 수 있음.
cat data.txt | tr -d [:alpha] | tr -d : | tr -d [:blank:] > phones.txt
나중에 이걸로 리디렉션.
이걸로 스팸전화 갈기는 나쁜 프로그램도 만들 수 잇음. 

	12-6 여러 파이프 동시 사용하기.
tac | rev rev는 표준 입력 받는 명령어로 이런 조합 가능

cat file | head -7 | tail -5 이런 조합도 가능.

ls -lh | sort -rhk 5 | head -3
========
========
========
========
========
========
========
========
========
========
	appendix 설치해보기 애플
두옵션중 하나만 썰치하면댐.  맥에서는 사실 설치안해도 이 과정에서 실행할 커맨드의 98퍼센트가 동작함. 이미 개발자고 맥 써야할 이유가 잇으면 걍 깔지 말고 쓰삼. 하지만 이 비디오에서 하는 것과 가장 유사하게 경험하고 싶고 시각적으로 똑같고 싶으면 가상머신으로 우분투 설치하삼. 맥이랑 폴더구조도 약간만 다르고 똑같음. 하지만 최근 맥의 디폴트 쉘은 zsh인데 bash로 바꾸는 걸 추천함. 

======

echo $SHELL 치면 우리 쉘의 이름 알려줌.  chsh -s /bin/bash 치면 암호치고 다운가능.

맥 개발자나 데이터 과학자라면 모든 워크플로우가 설정 돼있을텐데 가상머신 설치하면서까지 버리진 않을 거임. 근데 처음부터 하고 싶다면 이건 좋은 옵션이 될거임. 
	appendix 설치해보기 윈도우
윈도우는 파워셸이 기본 내장임. 어두운 배경에 터미널 하나 있으니까, 진지한 개발자라면 컴퓨터 안에 컴퓨터가 또있는게 대형프로젝트에 부담일 수 잇음. wsl로 리눅스 커널 접근 가능. 별도 그래픽 사용자가 없음. 그냥 윈도환경에 통합 되어 있음. 초보자 친화적이진 않지만 하고 싶으면 도전해보셈. 폴더를 옮기면 하위컨텐츠도 따라 움직인다.
가상머신 깔고 우분투 까삼 lts. 먼저 가상머신 까삼. 가상머신으로 가상 장치 할당할 수 잇음. 그 위에 우분투 설정하삼.

