1.http로의 여행
Src = https://kamranahmed.info/blog/2016/08/13/http-in-depth

 내가 내블로그에 글을 쓴지 꽤 시간이 지났고 그 이유는 충분한 시간이 없어서였다. 나는 오늘 자투리 시간을 찾았고 http에 대한 글을 쓰기로 마음먹었다.
http는 그 전체 웹에 대한 영향력과, 공부하는 것으로부터 더 나은 어플을 개발할 수 있게해주기 때문에 반드시 모든 웹개발자가 알아야 하는 프로토콜이다.
이 글 안에서 나는 http가 무엇인지 말하고, 어떻게 생겨났고 현재는 어디있는지. 그리고 어떻게 이곳까지 도달했는지에 다룰 것이다.



2. http란 무엇인가?

우선 http란 무엇인가? http는 tcp/ip에 기반한 응용프로그램 계층 통신 프로토콜으로 클라이언트와 서버가 어떻게 통신하는지 표준화한다. 콘텐츠가 어떻게 요청했는지 그리고 어떻게 인터넷을 통해 전송됐는지 기술한다. 응용프로그램 계층 프로토콜으로서 이건 그냥 호스트들이(클라이언트와 서버) 어떻게 통신할지 표준화하고 요청을 받고 응답하는데 tcp/ip계층에 의존하는 추상화 계층에 불과하다. 기본 tcp 포트는 80이나 다른 포트들고 또한 사용될 수 있다. 하지만 https 는 443을 사용한다.

3 - 1. http/0,9 - the one liner(1991)

http이 첫번쨰 문서화된 버전은 http/0.9였다. 그당시 역대급으로 간단한 프로토콜이였으며 GET이라고 불리는 메소드만 가지고 1991년 제시되었다. 
만약 클라이언트가 서버상의 일부 서버에 접근해야한다면 아래와 같은 간단한 요청을 만들었다.

GET /index.html

그리고 서버로부터의 응답은 다음과 같이 생겼었다.

(response body)
(connection closed)

즉 서버는 요청을 받고, html로 응답한다. 그리고 콘텐츠가 전송되자마자, 연결은 끝났었다.  그것은

헤더가 없었고, GET만이 오직 사용가능한 메소드였다. 응답은 HTML이여야 했다.

프로토콜은 정말 앞으로 오게된 것들의 디딤발이 되는 것 이상이라고 할 수 없었다.

3 - 2. http/1.0 - 1996

1996년 http의 차새대 버전인 http/1.0은 원 버전을 넘어 광범위하게 진화했다.

오직 html 반응을 위해 설계된 http/0.9와 다르게 http/1.0은 이미지나 비디오파일, 단순텍스트나 다른 타입의 응답 형태를 다룰 수 있었다.
그것은 post나 head와 같은 더 많은 메소드가 추가되었고, 응답반응 포맷은 바뀌었다. http헤더는 응답과 요청 두가지에 모두 포함되었다. 상태코드는 반응을 식별하기위해 추가되었고 문자 세트지원 역시 도입되었다. 다중 파트 유형, 인증, 캐싱, 콘텐츠 엔코딩, 그리고 더 많은 것들이 포함되었다. 

여기 http요청과 반응이 어떻게 생겼었는지 예가 있다.

GET / HTTP/1.0
Host: kamranahmed.info
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*

당신이 보는 것처럼 요청과 함꼐 클라이언트는 요구하는 응답유형등의 개인정보를 보냈었다. http/0.9에서 클라이언트는 헤더가 없었기때문에 그러한 유형의 정보를 절대 보낼 수 없었다.

요청에 대한 응답의 예는 다음과 같이 생겼다.

HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

(response body)
(connection closed)

 응답의 맨 처음 시작에는 http/1.0이 있다. (버전명과 함께한 http), 
그리고 응답 문구(혹은 그냥 상태코드에 대한 설명)이 있다.

 이 신 버전에서 요청과 응답해더는 아스키 엔코딩으로 유지 되었지만. 응답 본문은 이미지. 비디오, html, 단순 텍스트, 다른유형의 콘텐츠들이 될 수 있게 되었다. 그래서 이제 서버는 클라이언트에 어떤 유형의 컨텐츠든 보낼 수가 있었다. 그 도입으로부터 얼마지나지 않아 http의 hyper text라는 용어는 잘못된 명칭이 되었다. HMTP나 Hypermedia transfer protocol이 좀 더 그 의미에 부합하겠으나 우리는 평생 하나의 이름과 함께하지 않냐.

 http/1.0의 주요 결점중하나는 당신은 각 연결에대해 다량의 요청을 가질 수 없다는 것이다. 즉 클라이언트가 서버에 무언가를 필요로 할때마다 새로운 tcp연결을 열고 그 하나의 요청이 달성되면 연결을 닫는다는 것을 의미한다. 그리고 다음 요청을 위해서는 다시 새로운 연결을 열어야 한다. 이게 뭐가 나쁜거냐고? 당신이 10개의 이미자와 5개의 스타일 싯, 5개의 자바스크립트파일을 가진, 웹페이지에 대한 요청이 있을때 총 20개의 아이템들을 가져와야 하는 웹사이트를 방문했다고 가정해보자. 서버는 그 요청이 달성되자마자 연결을 끊기 때문에 각각의 아이템이 전송될 20개의 개별 연속적 연결을가질 것이다.이 많은 양의 연결은 새로운 느린시작과 함께한 3방향 핸드쉐이크 때문에 중대한 성능패널티를 초래하는 tcp연결을 요구하는 심각한 성능 타격으로 이어질 것이다.

4. 3방향 핸드쉐이크

간단한 형식으로 된 삼방향 핸드셰이크는 모든 tcp연결이 삼방향 핸드쉐이크(클라이언트와 서버가 응용프로그램 데이터 교환을 시작하기전에 일련의 패킷을 공유하는 것)로 시작하는 것이다. 

 SYN - 클라이언트는 가상의 번호 (x라고하자))를 뽑고 서버로 보낸다.
 SYN ACK - 서버는 ack패킷을 송신함으로서 요청을 인정하고 