1.http로의 여행
Src = https://kamranahmed.info/blog/2016/08/13/http-in-depth

 내가 내블로그에 글을 쓴지 꽤 시간이 지났고 그 이유는 충분한 시간이 없어서였다. 나는 오늘 자투리 시간을 찾았고 http에 대한 글을 쓰기로 마음먹었다.
http는 그 전체 웹에 대한 영향력과, 공부하는 것으로부터 더 나은 어플을 개발할 수 있게해주기 때문에 반드시 모든 웹개발자가 알아야 하는 프로토콜이다.
이 글 안에서 나는 http가 무엇인지 말하고, 어떻게 생겨났고 현재는 어디있는지. 그리고 어떻게 이곳까지 도달했는지에 다룰 것이다.



2. http란 무엇인가?

우선 http란 무엇인가? http는 tcp/ip에 기반한 응용프로그램 계층 통신 프로토콜으로 클라이언트와 서버가 어떻게 통신하는지 표준화한다. 콘텐츠가 어떻게 요청했는지 그리고 어떻게 인터넷을 통해 전송됐는지 기술한다. 응용프로그램 계층 프로토콜으로서 이건 그냥 호스트들이(클라이언트와 서버) 어떻게 통신할지 표준화하고 요청을 받고 응답하는데 tcp/ip계층에 의존하는 추상화 계층에 불과하다. 기본 tcp 포트는 80이나 다른 포트들고 또한 사용될 수 있다. 하지만 https 는 443을 사용한다.

3 - 1. http/0,9 - the one liner(1991)

http이 첫번쨰 문서화된 버전은 http/0.9였다. 그당시 역대급으로 간단한 프로토콜이였으며 GET이라고 불리는 메소드만 가지고 1991년 제시되었다. 
만약 클라이언트가 서버상의 일부 서버에 접근해야한다면 아래와 같은 간단한 요청을 만들었다.

GET /index.html

그리고 서버로부터의 응답은 다음과 같이 생겼었다.

(response body)
(connection closed)

즉 서버는 요청을 받고, html로 응답한다. 그리고 콘텐츠가 전송되자마자, 연결은 끝났었다.  그것은

헤더가 없었고, GET만이 오직 사용가능한 메소드였다. 응답은 HTML이여야 했다.

프로토콜은 정말 앞으로 오게된 것들의 디딤발이 되는 것 이상이라고 할 수 없었다.

3 - 2. http/1.0 - 1996

1996년 http의 차새대 버전인 http/1.0은 원 버전을 넘어 광범위하게 진화했다.

오직 html 반응을 위해 설계된 http/0.9와 다르게 http/1.0은 이미지나 비디오파일, 단순텍스트나 다른 타입의 응답 형태를 다룰 수 있었다.
그것은 post나 head와 같은 더 많은 메소드가 추가되었고, 응답반응 포맷은 바뀌었다. http헤더는 응답과 요청 두가지에 모두 포함되었다. 상태코드는 반응을 식별하기위해 추가되었고 문자 세트지원 역시 도입되었다. 다중 파트 유형, 인증, 캐싱, 콘텐츠 엔코딩, 그리고 더 많은 것들이 포함되었다. 

여기 http요청과 반응이 어떻게 생겼었는지 예가 있다.

GET / HTTP/1.0
Host: kamranahmed.info
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*

당신이 보는 것처럼 요청과 함꼐 클라이언트는 요구하는 응답유형등의 개인정보를 보냈었다. http/0.9에서 클라이언트는 헤더가 없었기때문에 그러한 유형의 정보를 절대 보낼 수 없었다.

요청에 대한 응답의 예는 다음과 같이 생겼다.

HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

(response body)
(connection closed)

 응답의 맨 처음 시작에는 http/1.0이 있다. (버전명과 함께한 http), 
그리고 응답 문구(혹은 그냥 상태코드에 대한 설명)이 있다.

 이 신 버전에서 요청과 응답해더는 아스키 엔코딩으로 유지 되었지만. 응답 본문은 이미지. 비디오, html, 단순 텍스트, 다른유형의 콘텐츠들이 될 수 있게 되었다. 그래서 이제 서버는 클라이언트에 어떤 유형의 컨텐츠든 보낼 수가 있었다. 그 도입으로부터 얼마지나지 않아 http의 hyper text라는 용어는 잘못된 명칭이 되었다. HMTP나 Hypermedia transfer protocol이 좀 더 그 의미에 부합하겠으나 우리는 평생 하나의 이름과 함께하지 않냐.

 http/1.0의 주요 결점중하나는 당신은 각 연결에대해 다량의 요청을 가질 수 없다는 것이다. 즉 클라이언트가 서버에 무언가를 필요로 할때마다 새로운 tcp연결을 열고 그 하나의 요청이 달성되면 연결을 닫는다는 것을 의미한다. 그리고 다음 요청을 위해서는 다시 새로운 연결을 열어야 한다. 이게 뭐가 나쁜거냐고? 당신이 10개의 이미자와 5개의 스타일 싯, 5개의 자바스크립트파일을 가진, 웹페이지에 대한 요청이 있을때 총 20개의 아이템들을 가져와야 하는 웹사이트를 방문했다고 가정해보자. 서버는 그 요청이 달성되자마자 연결을 끊기 때문에 각각의 아이템이 전송될 20개의 개별 연속적 연결을가질 것이다.이 많은 양의 연결은 새로운 느린시작과 함께한 3방향 핸드쉐이크 때문에 중대한 성능패널티를 초래하는 tcp연결을 요구하는 심각한 성능 타격으로 이어질 것이다.

4. 3방향 핸드쉐이크

간단한 형식으로 된 삼방향 핸드셰이크는 모든 tcp연결이 삼방향 핸드쉐이크(클라이언트와 서버가 응용프로그램 데이터 교환을 시작하기전에 일련의 패킷을 공유하는 것)로 시작하는 것이다. 

 SYN - 클라이언트는 가상의 번호 (x라고하자))를 뽑고 서버로 보낸다.
 SYN ACK - 서버는 ack패킷(난수로 구성되어 있음)을 클라이언트에게 다시 돌려보냄으로서 요청을 승인한다.  난수 y가 서버에 의해 선택되고 x에는 +1을 한
 다.
 ACK - 클라이언트는 서버에게 전달 받은 숫자 를 증가시키고 y+1시켜 ACK 패킷을 돌려보낸다.

3방향 핸드셰이크가 완성되면 클라이언트와 서버간의 데이터 공유가 시작 될 것이다. 클라이언트는 마지막 ack패킷을 발송하자마자 응용프로그램 데이터 발송을 시작할 것이지만. 서버는 요청을 마무리하기 위해 ACK패킷이 수신될때까지 기다려야 한다.

하지만 http/1.0에서 새로 구현된 부분 중 일부는 이 이슈를 connection: keep-alive라고 불리는 새로운 헤더를 도입함으로서 극복하려 했다. 이것은 서버에게 "다시 필요하니까 이연결을 닫지마"라고 전달하려는 의도였다. 하지만 여전히 그것은 널리지지되지 않았고 문제는 지속되었다.

무연결외에도, http는 무상태 프로토콜등 이기도 하다. 서버는 클라이언트에 대한 정보를 유지하지 않고, 때문에 각각의 요청들은 오래된 요청과 아무런 연관 없이 서버가 그 자신에게 들어온 요청을 마무리하기위해 필요한 정보를 가지고 있어야한다. 이것은 상황을 악화시키는 꼴이다. 즉 클라이언트가 열어야하는 수많은 양의 연결외에도 클라이언트는 연결선을 통해 중복되는 데이터들을 보내야하고 이것은 대역폭 사용증가를 야기한다.

5. Http/1.1 - 1999

http/1.0이 나온지 겨우 3년이 지나 다음버전인 http/1.1이 1999년 나왔다. 이것은 전세대보다 많은 진보를 만들었다. http/1.0을 통한 주요한 향상 사항은 다음을 포함한다.

 -새로운 http 메소드.  PUT, PATCH, OPTIONS, DELETE등의 새로은 메소드들이 도입되었다.

 -호스트네임 식별자  1.0에서 필요하지 않았지만 1.1에서 필수가 되었다.

 -영구 연결 위에서 논의된 것 과 같이. 1.0에서는 하나의 연결당 하나의 요청만이 가능했고, 요청이 완수되자마자 연결은 종료 됐었다. 이로인해 심각한 성능 타격과 응답속도 문제가 발생했다. http/1.1은 영구적 연결을 도입했다. 즉 연결은 기본적으로 닫히지 않게 됐고 계속 연결됨으로서 다중의 연속적 요청을 가능케 했다.
이연결을 닫기 위해서는 Connection: close라는 해더가 요청으로 활성화 돼야 한다. 클라이언트는 주로 이 헤더를 안전하게 연결종료하기 위해 마지막 요청에 보낸다.

 -파이프라이닝 파이프라이닝 지원을 도입했다. 클라이언트는 서버에 다중요청을 서버에서 응답받을때까지 기다릴 필요없이 보낼 수 있다 요청이 수신된 하나의 시퀀스에서 말이다. 하지만 클라이언트가 여기가 첫번째 응답 다운로드가 완료되고 다음 콘텐츠에 대한 응답이 시작되는 지점이라는 것을 어떻게 알죠?라고 물어볼 수 있다. 이것을 해결하기 위해 클라이언트가 응답이 끝내는 곳을 식별하고 다음 반응을 기다리는데 사용할 수 있는 content-length 헤더가 있어야 한다. 


파이프라이닝이나 영구 연결로부터 이득을 얻기 위해 유의해야한다. Content-length ㅔㅎ더는 응답이 가능 해야 한다, 왜냐하면 이것은 클라이언트가 언제 전송을 완료할지 알게하고 그 다음 요청을 보내거나 (요청을 보내는 평범한 연속적 방법) 다음 응답을 기다리기 시작할 수 있다.(파이프라이닝이 활성화 작동된다면)

하지만 여전히 이 접근에는 문제가 있다. 만약 데이터가 동적이고 서버가 content length를 미리 찾을 수 없다면 어떻게 할 것인가? 이경우에는 당신은 정말 영구 연결의 혜택을 볼 수 없을 것이다. 이문제를 해결하기위해 http/1.1은 청크화된 인코딩을 도입했다. 이러한 경우 서버는 청크화 인코딩을 위해 content-length를 생략할 것이다. 하지만 만약 그들중 아무도 사용할 수 없으면 연결은 요청의 끝에 닫혀야 한다.

 -청크화 전송 
 동적 콘텐츠의 경우에 서버가 content-length를 전송이 시작할때 정말 찾아 낼 수 없다면 콘텐츠를 조각으로 보내기 시작할 것이다(chunk by chunk)그리고 ocntent-length를 송신하기 전에 각 청크에 추가할 것이다. 그리고 이 청크들이 모두 보내지고 따라서 모든 전송이 완료될때, 클라이언트가 전송이 끝났는지 알아보기 위해 content-length가 0으로 설정된 비어있는 청크를 보낼 것이다. 청크화 전송을 클라이언트에게 알리기 위해 서버는 transfer-encoding:chunked 헤더를 추가한다.

 -오직 기본적인증만 있었던 http/1.0과 다르게 http/1.1 다이제스트 및 프록시 인증을 포함하고 있다.

 -캐싱

 -바이트 범위

 - 문자 집합

 - 언어 조절

 - 클라이언트 쿠키

 - 강화된 압축 지원

 - 새로운 상태코드

나는 모든 1.1기능들에 대해 자세히 설명하지는 않을 것이다 이포스트에서. 왜냐하면 그것은 그자체로 하나의 토픽이 될뿐더러 이미 그것에대해 많은 것을 찾아 볼 수있을 것이다. 그러한 문서중에 내가 당신에게 읽기 추천하는 것은 https://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf( 1.0과 1.1사이의 중요한 변화)이다. 

1.1은 1999년 도입되었고 수년간 표준이 되었다. 비록 이게 그 전 버전보다 많이 발전하긴 했지만 웹은 매일변하고 있고, 이것또한 노후화를 보이기 시작했다. 오늘날 웹페이지를 로드하는 것은 그 어떤순간보다 자원집약적인 일이다. 요즘날 간단한 웹페이지 하나라도 30개가 넘는 연결을 열어야 한다. 아니 1.1은 영구 연결을 가지고 있는데 왜 그렇게 많은 연결이 필요한가?라고 말할지도 모른다. 그 이유는 1.1에서 어떤 순간이든 오직 하나의 두드러진 연결만을 가질 수 있기 때문이다. 1.1은 이문제를 파이프라이닝 도입으로부터 해결하려 했지만 완전히 그 문제를 다루지는 않았다. 