1.http로의 여행
Src = https://kamranahmed.info/blog/2016/08/13/http-in-depth

 내가 내블로그에 글을 쓴지 꽤 시간이 지났고 그 이유는 충분한 시간이 없어서였다. 나는 오늘 자투리 시간을 찾았고 http에 대한 글을 쓰기로 마음먹었다.
http는 그 전체 웹에 대한 영향력과, 공부하는 것으로부터 더 나은 어플을 개발할 수 있게해주기 때문에 반드시 모든 웹개발자가 알아야 하는 프로토콜이다.
이 글 안에서 나는 http가 무엇인지 말하고, 어떻게 생겨났고 현재는 어디있는지. 그리고 어떻게 이곳까지 도달했는지에 다룰 것이다.



2. http란 무엇인가?

우선 http란 무엇인가? http는 tcp/ip에 기반한 응용프로그램 계층 통신 프로토콜으로 클라이언트와 서버가 어떻게 통신하는지 표준화한다. 콘텐츠가 어떻게 요청했는지 그리고 어떻게 인터넷을 통해 전송됐는지 기술한다. 응용프로그램 계층 프로토콜으로서 이건 그냥 호스트들이(클라이언트와 서버) 어떻게 통신할지 표준화하고 요청을 받고 응답하는데 tcp/ip계층에 의존하는 추상화 계층에 불과하다. 기본 tcp 포트는 80이나 다른 포트들고 또한 사용될 수 있다. 하지만 https 는 443을 사용한다.

3 - 1. http/0,9 - the one liner(1991)

http이 첫번쨰 문서화된 버전은 http/0.9였다. 그당시 역대급으로 간단한 프로토콜이였으며 GET이라고 불리는 메소드만 가지고 1991년 제시되었다. 
만약 클라이언트가 서버상의 일부 서버에 접근해야한다면 아래와 같은 간단한 요청을 만들었다.

GET /index.html

그리고 서버로부터의 응답은 다음과 같이 생겼었다.

(response body)
(connection closed)

즉 서버는 요청을 받고, html로 응답한다. 그리고 콘텐츠가 전송되자마자, 연결은 끝났었다.  그것은

헤더가 없었고, GET만이 오직 사용가능한 메소드였다. 응답은 HTML이여야 했다.

프로토콜은 정말 앞으로 오게된 것들의 디딤발이 되는 것 이상이라고 할 수 없었다.

3 - 2. http/1.0 - 1996

1996년 http의 차새대 버전인 http/1.0은 원 버전을 넘어 광범위하게 진화했다.

오직 html 반응을 위해 설계된 http/0.9와 다르게 http/1.0은 이미지나 비디오파일, 단순텍스트나 다른 타입의 응답 형태를 다룰 수 있었다.
그것은 post나 head와 같은 더 많은 메소드가 추가되었고, 응답반응 포맷은 바뀌었다. http헤더는 응답과 요청 두가지에 모두 포함되었다. 상태코드는 반응을 식별하기위해 추가되었고 문자 세트지원 역시 도입되었다. 다중 파트 유형, 인증, 캐싱, 콘텐츠 엔코딩, 그리고 더 많은 것들이 포함되었다. 

여기 http요청과 반응이 어떻게 생겼었는지 예가 있다.

GET / HTTP/1.0
Host: kamranahmed.info
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)
Accept: */*

당신이 보는 것처럼 요청과 함꼐 클라이언트는 요구하는 응답유형등의 개인정보를 보냈었다. http/0.9에서 클라이언트는 헤더가 없었기때문에 그러한 유형의 정보를 절대 보낼 수 없었다.

요청에 대한 응답의 예는 다음과 같이 생겼다.

HTTP/1.0 200 OK 
Content-Type: text/plain
Content-Length: 137582
Expires: Thu, 05 Dec 1997 16:00:00 GMT
Last-Modified: Wed, 5 August 1996 15:55:28 GMT
Server: Apache 0.84

(response body)
(connection closed)

 응답의 맨 처음 시작에는 http/1.0이 있다. (버전명과 함께한 http), 
그리고 응답 문구(혹은 그냥 상태코드에 대한 설명)이 있다.

 이 신 버전에서 요청과 응답해더는 아스키 엔코딩으로 유지 되었지만. 응답 본문은 이미지. 비디오, html, 단순 텍스트, 다른유형의 콘텐츠들이 될 수 있게 되었다. 그래서 이제 서버는 클라이언트에 어떤 유형의 컨텐츠든 보낼 수가 있었다. 그 도입으로부터 얼마지나지 않아 http의 hyper text라는 용어는 잘못된 명칭이 되었다. HMTP나 Hypermedia transfer protocol이 좀 더 그 의미에 부합하겠으나 우리는 평생 하나의 이름과 함께하지 않냐.

 http/1.0의 주요 결점중하나는 당신은 각 연결에대해 다량의 요청을 가질 수 없다는 것이다. 즉 클라이언트가 서버에 무언가를 필요로 할때마다 새로운 tcp연결을 열고 그 하나의 요청이 달성되면 연결을 닫는다는 것을 의미한다. 그리고 다음 요청을 위해서는 다시 새로운 연결을 열어야 한다. 이게 뭐가 나쁜거냐고? 당신이 10개의 이미자와 5개의 스타일 싯, 5개의 자바스크립트파일을 가진, 웹페이지에 대한 요청이 있을때 총 20개의 아이템들을 가져와야 하는 웹사이트를 방문했다고 가정해보자. 서버는 그 요청이 달성되자마자 연결을 끊기 때문에 각각의 아이템이 전송될 20개의 개별 연속적 연결을가질 것이다.이 많은 양의 연결은 새로운 느린시작과 함께한 3방향 핸드쉐이크 때문에 중대한 성능패널티를 초래하는 tcp연결을 요구하는 심각한 성능 타격으로 이어질 것이다.

4. 3방향 핸드쉐이크

간단한 형식으로 된 삼방향 핸드셰이크는 모든 tcp연결이 삼방향 핸드쉐이크(클라이언트와 서버가 응용프로그램 데이터 교환을 시작하기전에 일련의 패킷을 공유하는 것)로 시작하는 것이다. 

 SYN - 클라이언트는 가상의 번호 (x라고하자))를 뽑고 서버로 보낸다.
 SYN ACK - 서버는 ack패킷(난수로 구성되어 있음)을 클라이언트에게 다시 돌려보냄으로서 요청을 승인한다.  난수 y가 서버에 의해 선택되고 x에는 +1을 한
 다.
 ACK - 클라이언트는 서버에게 전달 받은 숫자 를 증가시키고 y+1시켜 ACK 패킷을 돌려보낸다.

3방향 핸드셰이크가 완성되면 클라이언트와 서버간의 데이터 공유가 시작 될 것이다. 클라이언트는 마지막 ack패킷을 발송하자마자 응용프로그램 데이터 발송을 시작할 것이지만. 서버는 요청을 마무리하기 위해 ACK패킷이 수신될때까지 기다려야 한다.

하지만 http/1.0에서 새로 구현된 부분 중 일부는 이 이슈를 connection: keep-alive라고 불리는 새로운 헤더를 도입함으로서 극복하려 했다. 이것은 서버에게 "다시 필요하니까 이연결을 닫지마"라고 전달하려는 의도였다. 하지만 여전히 그것은 널리지지되지 않았고 문제는 지속되었다.

무연결외에도, http는 무상태 프로토콜등 이기도 하다. 서버는 클라이언트에 대한 정보를 유지하지 않고, 때문에 각각의 요청들은 오래된 요청과 아무런 연관 없이 서버가 그 자신에게 들어온 요청을 마무리하기위해 필요한 정보를 가지고 있어야한다. 이것은 상황을 악화시키는 꼴이다. 즉 클라이언트가 열어야하는 수많은 양의 연결외에도 클라이언트는 연결선을 통해 중복되는 데이터들을 보내야하고 이것은 대역폭 사용증가를 야기한다.

5. Http/1.1 - 1999

http/1.0이 나온지 겨우 3년이 지나 다음버전인 http/1.1이 1999년 나왔다. 이것은 전세대보다 많은 진보를 만들었다. http/1.0을 통한 주요한 향상 사항은 다음을 포함한다.

 -새로운 http 메소드.  PUT, PATCH, OPTIONS, DELETE등의 새로은 메소드들이 도입되었다.

 -호스트네임 식별자  1.0에서 필요하지 않았지만 1.1에서 필수가 되었다.

 -영구 연결 위에서 논의된 것 과 같이. 1.0에서는 하나의 연결당 하나의 요청만이 가능했고, 요청이 완수되자마자 연결은 종료 됐었다. 이로인해 심각한 성능 타격과 응답속도 문제가 발생했다. http/1.1은 영구적 연결을 도입했다. 즉 연결은 기본적으로 닫히지 않게 됐고 계속 연결됨으로서 다중의 연속적 요청을 가능케 했다.
이연결을 닫기 위해서는 Connection: close라는 해더가 요청으로 활성화 돼야 한다. 클라이언트는 주로 이 헤더를 안전하게 연결종료하기 위해 마지막 요청에 보낸다.

 -파이프라이닝 파이프라이닝 지원을 도입했다. 클라이언트는 서버에 다중요청을 서버에서 응답받을때까지 기다릴 필요없이 보낼 수 있다 요청이 수신된 하나의 시퀀스에서 말이다. 하지만 클라이언트가 여기가 첫번째 응답 다운로드가 완료되고 다음 콘텐츠에 대한 응답이 시작되는 지점이라는 것을 어떻게 알죠?라고 물어볼 수 있다. 이것을 해결하기 위해 클라이언트가 응답이 끝내는 곳을 식별하고 다음 반응을 기다리는데 사용할 수 있는 content-length 헤더가 있어야 한다. 


파이프라이닝이나 영구 연결로부터 이득을 얻기 위해 유의해야한다. Content-length ㅔㅎ더는 응답이 가능 해야 한다, 왜냐하면 이것은 클라이언트가 언제 전송을 완료할지 알게하고 그 다음 요청을 보내거나 (요청을 보내는 평범한 연속적 방법) 다음 응답을 기다리기 시작할 수 있다.(파이프라이닝이 활성화 작동된다면)

하지만 여전히 이 접근에는 문제가 있다. 만약 데이터가 동적이고 서버가 content length를 미리 찾을 수 없다면 어떻게 할 것인가? 이경우에는 당신은 정말 영구 연결의 혜택을 볼 수 없을 것이다. 이문제를 해결하기위해 http/1.1은 청크화된 인코딩을 도입했다. 이러한 경우 서버는 청크화 인코딩을 위해 content-length를 생략할 것이다. 하지만 만약 그들중 아무도 사용할 수 없으면 연결은 요청의 끝에 닫혀야 한다.

 -청크화 전송 
 동적 콘텐츠의 경우에 서버가 content-length를 전송이 시작할때 정말 찾아 낼 수 없다면 콘텐츠를 조각으로 보내기 시작할 것이다(chunk by chunk)그리고 ocntent-length를 송신하기 전에 각 청크에 추가할 것이다. 그리고 이 청크들이 모두 보내지고 따라서 모든 전송이 완료될때, 클라이언트가 전송이 끝났는지 알아보기 위해 content-length가 0으로 설정된 비어있는 청크를 보낼 것이다. 청크화 전송을 클라이언트에게 알리기 위해 서버는 transfer-encoding:chunked 헤더를 추가한다.

 -오직 기본적인증만 있었던 http/1.0과 다르게 http/1.1 다이제스트 및 프록시 인증을 포함하고 있다.

 -캐싱

 -바이트 범위

 - 문자 집합

 - 언어 조절

 - 클라이언트 쿠키

 - 강화된 압축 지원

 - 새로운 상태코드

나는 모든 1.1기능들에 대해 자세히 설명하지는 않을 것이다 이포스트에서. 왜냐하면 그것은 그자체로 하나의 토픽이 될뿐더러 이미 그것에대해 많은 것을 찾아 볼 수있을 것이다. 그러한 문서중에 내가 당신에게 읽기 추천하는 것은 https://www.ra.ethz.ch/cdstore/www8/data/2136/pdf/pd1.pdf( 1.0과 1.1사이의 중요한 변화)이다. 

1.1은 1999년 도입되었고 수년간 표준이 되었다. 비록 이게 그 전 버전보다 많이 발전하긴 했지만 웹은 매일변하고 있고, 이것또한 노후화를 보이기 시작했다. 오늘날 웹페이지를 로드하는 것은 그 어떤순간보다 자원집약적인 일이다. 요즘날 간단한 웹페이지 하나라도 30개가 넘는 연결을 열어야 한다. 아니 1.1은 영구 연결을 가지고 있는데 왜 그렇게 많은 연결이 필요한가?라고 말할지도 모른다. 그 이유는 1.1에서 어떤 순간이든 오직 하나의 두드러진 연결만을 가질 수 있기 때문이다. 1.1은 이문제를 파이프라이닝 도입으로부터 해결하려 했지만 완전히 그 문제를 다루지는 않았다. 헤드오브라인 블라킹 문제(천천히, 그리고 버거운 요청들이 뒤에 요청이 오는 것을 막고 파이프라인 안에서 요청이 갇히는 현상이다. 다음 요청이 완료될때까지 기다려야하기 떄문에. 이러한 1.1의 단점을 극복하기 위해 개발자들은 차선책을 구현하기 시작했는데 스프레드사용, css에서 이미지 인코딩, 하나의 거대한 css/자바스크립트 파일,도메인 파편화등이 그것이다.

6.SPYD - 2009
구글은 웹을 빠르게하기위해, 그리고 비록 웹페이지 반응속도를 늦추지만 웹 보안성이 증가하도록 대체프로토콜 개발을 시작했다. 2009년 그들은 SPDY를 발표했다.

 SPDY는 구글의 트레이드 마크이나, 두문자어는 아니다.

만약 우리가 대역폭을 계속 증가시킨다면 네트워크 퍼포먼스가 초기에는 좋아질지 언정 많은 향상을 체감하지 못하는 지점이 온다. 하지만 만약 반응속도에 똑같이 한다면 즉 만약 우리가 반응시간을 계속 낮춘다면 영구적인 성능향상을 얻을 수 있을 것이다. 이게 SPDY 뒤에 있는 퍼포먼스 향상을 불러온 핵심적인 아이디어이다. 네트워크 성능을 향상시키기위해 응답시간을 줄이는 것이다. 그 차이점을 모르는 사람을 위해 적자면, 응답시간은 지연이다. 즉 소스로부터 목적지까지 데이터가 이동하는데 얼마나 걸리냐 이다.(밀리초로 측정됨) 그리고 대역폭은 각초마다 전송되는 데이터의 총량이다.(bits per second).

SPDY의 특징은 다중화, 압축, 우선순위화, 보안등을 포함하고 있다. 나는 SPDY에대해 자세히 파고들지는 않을 것이다. 우리가 http/2의 불편한 진실로 다음섹션에서 들어간다면 알게될 것이다. 내가 말했듯이 http/2는 SPDY로부터 영감을 받았다는 것을.

SPDY는 HTTP를 정말 대체하려고 하지는 않았다. 그저 응용계층에서 존재하는 http를 통한 전송계층이였으며, 선을통해 보내기전에 요청을 수정했다. 이것은 사실상의 표준이 되었으며 대부분의 브라우저에서 이것을 도입하기 시작했다.

2015년 구글은 두개의 경쟁적 표준이 있는 것을 바라지 않았고, http/2를 생성시키는 한편 spdy에 반대하며 이것을 http 에 통합하였다.

7.http/2 - 2015

지금쯤이면 우리가 왜 http프로토콜의 다른 개선판이 필요했는지 확신했을 것이다. /2는 컨텐츠의 낮은 응답시간 전송을 위해 설계되었다. 구버전인 1.1로부터 차이점과 중요기능등은 다음과 같다.

 - 문자대신 이진수이다. 

 - 다중화 하나의 연결을 통한 다중 비동기화 http 요청

 - hpack을 사용한 헤더압축

 - 서버푸쉬 - 하나의 요청에대한 다중의 반응

 - 요청 우선순위화

 - 보안

7-1 이진수 프로토콜

http/2는 1.x버전에서 증가된 응답시간을 이진화프로토콜화 시킴으로서 해결하려는 경향이 있었다. 이진화 프로토콜으로서 파싱이 더 쉽지만 1.x와 다르게 인간의 눈으로 더이상 읽을 수 없다. 

프레임과 스트림

http메시지는 하나나 그 이상의 프레임으로 구성돼 있다. 메타데이터를 위한 헤더 프레임이 있고, 페이로드를 위한 데이터 프레임이 있다. 그리고 (헤더,데이타, rst_stream, setting, priority등) 다른 몇몇의 프레임들이 존재한다. http/2명세에서 확인할 수 있다.

모든 2 요청과 반응은 고유 스트림 id가주어지고 프레임들로 나뉜다. 프레임은 단지 데이터의 이진 조각일 뿐이다. 프레임들의 모임은 스트림이라고 불린다. 각 프레임은 스트림 아이디를 가지고 있다 그것은 프레임이 어떤 스트림에 속하고 각 프레임은 공통된 해더를 가지고 있다. 그리고 고유한 스트림 id외에도 클라이언트에 의해 실행된 모든 요청은 짝수 번호를 사양하고 서버로부터의 응답도 짝수 스트림 아이디를 가지고 있다는 것은 말할만한 가치가 있을 것 같다.

 헤더와 데이터 프레임 외에도 내가 여기서 말할 가치가 있다고 생각하는 것은 rst_stream 프레임이다. 이것은 일부 스트림을 제거하기 위해 사용되는 특수 프레임 타입이다. 즉 클라이언트는 서버에게 더이상 이 스트림이 필요하지 않다는 것을 알리기 위해 이 스트림을 송신한다. 1.1에서 서버가 클라이언트에 응답을 멈추는 유일한 방법은 (응답시간 증가로 이어진)연결을 닫는것이다. 왜냐하면 새 연결은 어떤 연속적 요청을 위해서라도 항상 열려야 하기 떄문이다. 반면에 2에서 클라이언트는 rst_stream을 사용하여 특정한 스트림을 받는 것을 멈출 수 있다. 반면에 연결은 계속 열려 있을 것이고 다른 스트림들은 계속 실행상태에 있을 것이다.

7-2 다중화

2는 이제 이진수 프로토콜이기 때문에 그리고 상기했듯이 응답과 요청에 프레임,스트림을 사용하기 떄문에 tcp연결이 열렸을때 모든 스트림들은 추가적 연결을 열지 않고도 같은 연결을 통해 비동기적으로 송신된다. 즉 응답은 일정한 순서가 없고 클라이언트는 특정 패킷이 속하는 스트림을 식별하기 위해 부여된 스트림 아이디를 사용한다. 이건 1.x버전에 존재했던 head of line blocking issue를 해결하고 클라이언트는 시간이 걸리는 다른 요청을 기다릴 필요가 없으며, 다른 요청들은 계속 처리 될 것이다.

7-3 hpack header 비교

독립된 각각의 rfc의 부분 이였다. 특히 헤더를 보내는데 최적화되는 것을 목표로 삼았던. 즉 우리가 꾸준히 같은 클라이언트로부터 서버를 꾸준히 접근할때 굉장히 많은 쓸모없는 중복데이터가 발생한다. 우리는 헤더에서 그것을 계속계속 보내는 것이다. 그리고 때떄로 쿠키가 헤더 사이즈를 증가시켜 대역폭 사용증가와 응답시간 증가로 이어진다. 이문제를 해결하기 위해 2 에서는 헤더 압축을 도입했다. 

 요청, 반응과는 다르게 헤더는 gzip이나 compress등의 포맷으로 압축되지 않지만 헤더압축을 위한 다른 메커니즘이 있다. 리터럴 값은 허프만 코드를 사용해 엔코딩 되고, 헤더테이블은 클라이언트와 서버에 의해 유지된다. 그리고 서버와 클라이언트 양쪽은 후속요청에 있는 반복되는 헤더들을 생략한다(유저 에이전트 등) 그리고 양쪽에 의해 관리하는 헤더테이블을 사용해 참조한다.

우리가 헤더에 대해 이야기하고는 있지만 :method, :scheme, :host and :path를 제외하고 헤더는 1.1과 같다고 같다고 여기에 덧붙이겠다.

7-4. 서버 푸쉬


서버푸쉬는 2의 다른 엄청난 기능이다. 클라이언트가 특정 리소스를 요청할 것이라는 것을 알고 있는 서버는 그걸 클라이언트가 심지어 요청하는 일 없이도 송신할 수 있다. 예를들어 브라우저가 웹페이지를 로드한다고 해보자. 브라우저는 서버로부터 불러와야하는 원격 콘텐츠를 찾기 위해 전체 페이지를 분석한다. 그리고 서버에 콘텐츠를 가져오기 위한 연속적인 요청을 보낸다.

 서버푸쉬는 클라이언트가 요구하려고하는 데이터를 푸싱함으로써 서버가 덜 왕복할 수 있게 해준다. 이것이 일어나는 방법은. 서버는 push_promise라고 하는 특수 프레임을 보내고 클라이언트에게 알린다. "야 나는 이 리소스를 너에게 전해주려는 참이야. 나한테 요청하지마" 푸쉬 프로미스 프레임은 푸쉬를 발생시킨 프레임과 연결되며 약속된 서버가 푸시할 리소스를 가지고 있는 스트림의 아이디를 가지고 있다.

7-5 우선순위화 요청

클라이언트는 우선순위화 정보를 스트림이 열릴 헤더에 포함함으로서 스트림에 우선순위를 부여할 수 있다. 어떤떄이든 클라이언트는 스트림의 우선순위를 바꾸기위해 우선순위 프레임을 송신 할 수 있다.

 우선순위화 정보 없이, 서버는 요청을 비동기적으로 처리한다. 즉 아무런 순서 없이. 만약 스트림에 부여된 우선순위가 있다면. 이 우선순위 정보에 기반해 서버는 요청을 처리하기 위해 얼마나 많은 리소스가 주어져야하는지 결정한다.

7-6 보안성

2에서 TLS등을 통한 보안이 필수가 되어야 하는 가에 대한 많은 논의가 있었다. 결국 그것을 의무로 만들지는 않게 결정됐다. 하지만 대부분의 벤더들은 TLS를 통해서 사용될떄에만 2를 지원할 것이라고 발언한 상태이다. 그래서 비록 /2가 명세서에서부터 암호화를 요구하지는 않지만 기본적으로 일종의 의무 처럼 되었다. 그것만 빼면 http/2는 /2는 tls를 통해 도입되었을때 몇몇의 필수사항들을 도입했다. 즉 TLS 1.2버전 이상이 반드시 샤용돼야하며, 특정한 최소한의 키사이즈가 있다거나, 사용후 삭제되는 키가 필요하다.

 http/2는 현재 여기 있으며 채택률에서 spdy를 능가했다. /2는 성능향상의 측면에서 많은 것을 제공하며, 아마 이젠 우리가 사용을 시작할때이다.

 만약 더 이상의 세부사항이 필요하다면 명세들에 대한 링크와 /2에서 얻어지는 성능향상 증명의 링크가 있다. 질문과 코멘트들을 위해 아래있는 코멘트 섹션을 사용하라. 그리고 읽는 중에 뻔한 거짓들을 발견한다면 지적해주세요.

이걸로 끝이다. 다음시간까지! 채널고정해주세요/