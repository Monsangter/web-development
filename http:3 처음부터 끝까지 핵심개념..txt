Src = https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/
http/3 from A to Z: core concepts 

1. 빠른 요약. 

 거의 5년이란 시간동안의 개발 끝에 새로운 http/3 프로토콜이 최종단계에 근접했다. 최종단계의 반복들은 실험적 기능으로서 이미 사용 가능했다, 하지만 /3의 가용성과 사용이 2021년에 걸쳐 증가할 것이라는 걸 예측 할 수 있다. 그래서 /3은 정확히 무엇인가? 왜 /2가 나온지 얼마 안되어 필요되었는가? 어떻게 사용되고 사용해야하는가? 그리고 이건 어떻게 웹 성능을 증가시키는가? 알아보자.

2. 본문

 당신은 아마 이 토픽에대해 이야기하는 블로그 포스트나 컨퍼런스토크를 들었고 그 답을 알고 있다고 생각할지 모른다. 당신은 아마 이런 이야기를 들었을 것이다. /3은 /2에 비해 패킷손실이 있을때 훨씬 빠르다, "/3 연결은 더 낮은 응답시간을 가지고 있으며 준비되는데 더 적은 시간이 든다" 그리고 아마 "/3은 데이터를 더 빠르게 보내며, 리소스들을 더 병렬적으로 보낸다"라는 말들을 들었을 것이다.

 이런 설명과 기사는 일반적으로 중요한 기술적 세부사항을 생략했으며, 미묘한 뉘앙스가 부족하다. 그리고 대개 부분적으로만 맞다. 그들은 자주 /3을 성능적 혁명으로 만들고는 한다. 그러나 이것은 정말 요란하지 않은 수수한(그러나 여전히 유용하다) 진화이다. 이러한 것들은 대게 새로운 프로토콜들이 실전에서 그들의 높은 기대에 부응하지 못할 것이기 때문에 위험하다고할 수 있다. 나는 이게 많은 사람들을 결국 실망으로 이끌고, 입문자들에게 맹목적으로 잘못된 오류정보들의 더미로 이끌까봐 두렵다.

 이러한 것들은 /2에서 일어났고 우리가 봐온 것들이다. 그것은 서버푸쉬, 병렬 스트림, 우선순위와 같은 흥미로운 새기능을 갖춘 정말 위대한 성능적 혁명으로 사람들에게 소개 됐다. 우리는 자원 번들링을 멈출 수 있었고 우리 자원이 다수의 서버에 샤딩되는 것을 중단하며 페이지 로딩 과정을 엄청나게 간소화 할 수 있을 것이였다. 아마 스위치를 한번 누르면 마법같이 50퍼센트나 빨라질 것이다.

 5년이 지난후 우리는 서버 푸쉬가 실전에서 전혀 동작하지 않고, 스트림및 우선순위는 정말 자주 썩게 구현된다. 그래서 결과적으로 (감소된) 리소스 번들링, 심지어 샤딩 또한 몇몇 상황에서 상당히 좋은 방법이다.

마찬가지로 프리로드 힌트같은 프로토콜 행동을 수정하는 메커니즘들은 자주 숨겨진 깊이와 버그들을 포함하고 그것들이 올바르게 사용되기 어렵게한다.

이와같이 나는 이러한 형태의 잘못된 정보와 비현실적기대들이 /3에대해 퍼지는 것을 막는 것은 중요하다고 생각한다.

이 문서 시리즈 에서 나는 더 많은 뉘앙스를 가지고 특히 그 성능 기능들, 새로운 프로토콜에 대해 말할 것이다. /3이 참 전망 좋은 새 개념들을 포함하고는 있지만 슬프게도 대부분의 웹페이지와 유저들에게 상대적으로 그 영향이 제한된다는 것을 보여줄 것이다. /3를 설정하고 사용하는 것은 매우 어려운 일이므로, 새로운 프로토콜을 구성할때 주의 하도록하자.

 -파트 1: /3의 역사와 핵심 개념
 이 글은 /3과 일반적 프로토콜에 처음인 사람을 타겟으로 했다. 그리고 이것은 주로 기초를 다룰 것이다.

 -파트 2:/3의 성능 기능들
 이것은 좀더 깊이있고 기술적이다. 이미 그 기초를 알고 있다면 여기서부터 시작해도 된다.

 -3파트 3: 실용적인 /3 배포 옵션
 이 시리즈의 세번쨰 글에서는 http/3를 자기 손으로 배포하고 테스트하는데 관련된 문제들을 다룬다.

주의사항: 이 시리즈들은 반드시 깊은 프로토콜 지식을 필요로하지 않거나 더 배우고 싶지 않은 사람들을 타겟으로 잡고 있다. 그러나 충분히 많은 기술적 세부사항들을 다루고 있으며 고급 독자 또한 흥미를 가질만한 외부 소스에 대해 많은 링크들을 가지고 있다.

3. 우리는 왜 /3를 필요로 하는가? 

 내가 가장 많이 직면하는 질문은 "/2가 2015 표준화됐고 나온지 얼마되지도 않았는데 왜 우리는 /3을 필요로 하는가? 만약 당신이 오히려 그 기저에 있는 TCP의 업그레이드가 필요했지 우선 새로운 http버전이 정말 필요없었다는 것을 인정하지 않으면 이상하다.

Tcp는 http와 같은 다른 프로토콜에 신뢰성과 순서있는 전달 같은 중요한 서비스를 제공하는 주요 프로토콜이다. tcp는 우리가 많은 유저들과 동시에 인터넷을 사용할 수 있게 해주는 하나의 이유이다. 왜냐하면 이것은 각 사용자의 대역폭 사용을 공정한 몫만큼으로 제한하기 떄문이다.

 - 알고 있었나요?

 http(s)를 사용할때, 당신은 당신은 실로 http 이외에도 몇몇의 프로토콜들을 동시에 사용하고 있는 것이다. 이 스택안의 프로토콜들은 각자의 고유한 기능과 책임이 있다.(아래 그림 참조) 예를들어 http가 URL가 데이터 해석을 다루는 반면, TLS(전송계층보안)은 암호화로 보안을 보장한다. tcp는 손실된 패킷을 재전송함으로서 믿을 수 있는 데이터 전송을 활성화한다. 그리고 인터넷 프로토콜은 한곳의 종말점에서 다른기기로 패킷을 라우팅한다.

 이 프로토콜의 층계는 프로토콜의 기능을 쉽게 재사용할 수 있도록 하기 위해 수행된다. 더 높은 층의 포로토콜들(http등)은 암호화와 같은 복잡한 기능들을 재구현할 필요가 없다. 왜냐하면 하위계층프로토콜(tls같은)들은 이미 그들을위해 하고 있기 때문이다. 다른 예처럼. 대부분의 인터넷상 어플리케이션들은  그들의 데이터들이 완전히 전송되는 것을 확실하게 하기위해. tcp를 내부적으로 이용한다. 이러한 이유로 tcp는 인터넷상에서 가장 널리 사용되고 배포되는 프로토콜이다.

 tcp는 웹에게 수십년간 주춧돌이 되어 왔다. 하지만 2000년 후반 그 노후화를 보여주기 시작했다. 그리고 이것을 대체하려고 만들어진 quic라고 하는 새로운 전송 프로토콜은 tcp와 그위에 직접적으로 /2를 두고 실행하는 것이 매우 어려울 수 있는 핵심적 몇부분에서 다르다.  이와 같이 /3 그자체는 /2의 새로운 quic 프로토콜과 과 경쟁가능할 수 있게해주는 작은 개조판이다.

 quic는 필요하다. tcp는 대략 인터넷 초기 이래로 정말 최대의 효율을 염두에지고 만들어지지 않았기 때문이다. 예를들어 dcp는 새 연결을 만들기 위해 핸드 셰이크를 필요로한다. 이것은 클라이언트와 서버 둘 모두가 존재하는지, 그리고 그들이 데이터 교환을 원하고 할 수 있는지 확실히 하기위해 수행된다. 그러나 연결상에서 다른일이 수행되려면 먼저 완전한 네트워크 왕복이 완료 돼야한다. 만약 클라이언트와 서버가 지리적으로 멀리 떨어져 있다면 각 왕복 시간(round-trip time, RTT)이 100밀리초 이상 걸려 큰 지연을 유발 할 수 있다.

 두번쨰 예로서 tcp는 전송하는 모든 데이터들을 하나의 파일이나, 바이트 흐름으로서 본다 우리가 동시에 여러 파일을 전송하기 위해 tcp를 사용할지라도말이다.( 예를들어 많은 리소스로이루어진 웹페이지를 다운 받는 일), 실전에서 이것은 하나의 파일을 포함하는 패킷들이 손실된다면, 그 패킷이 회복될때까지 다른 파일들 역시 지연된다는 것을 의미한다.

 이것을 Hol(head of line) blocking이라고 한다. 실전에서 이런 비효율들이 꽤 다루기 쉬운 것은 반면에(그렇지 않았다면 우리는 tcp를 30년 넘게 사용해오지 않았을 것이다.)http등과 같은 상위 프로토콜에도 큰 방식으로 영향을 준다.

 우리는 tcp를 업그레이드하고 발전시키려는 시도를 계속 해왔다. 이러한 문제들을 발전시키고, 새로운 성능향상 기능들을 도입하기 위하여. 예를들어 tcp fast open은 헨드쉐이크 오버헤드를 상위계층 프로토콜에 시작부터 데이터를 보내는 것으로 제거한다. 다른 방식은 multipath tcp라는 것인데, wifi와 4g셀룰러를 동시에 사용해 처리량과 견고성을 늘리는 것이다.

 이런 tcp확장기능들을 구현하는 것은 엄청나게 어려운 일은 아니다. 하지만 그것을 인터넷범위에서 배포하는 것은 극단적으로 어려운 일이다. tcp는 매우 대중화돼서, 모든 연결된 디바이스들은 그들의 보드에 그들 고유의 프로토콜 구현을 가지고 있다. 만약 이 구현이 너무 오래됐고, 업데이타가 안됐고, 버그투성이라면. 아마 확장기능들은 실전적으로 사용가능하지 않을 것이다. 다르게 말하자면 모든 구현은 그걸 실제로 사용하기위해 이미 확장기능들에대해 알고 있어야 한다.

 만약 우리가 종말유저 기기(당신의 컴퓨터나 웹서버등)를 이야기 하는 것이라면 큰 문제는 아니다, 왜냐하면 이것들은 상대적으로 쉽게 수동업데이트 되기 떄문이다. 하지만 많은 다른 디바이스들이 클라이언트와 서버간에 있고 보드에 그들만의 tcp코드를 가지고 있다.(방화벽, 로드 밸런서, 라우터, 캐싱서버, 프록시 등)

 이런 중간단계의 기기들은 업데이트하기 더 어렵고 때때로 그들이 받아들이는 것에 대해서 더 엄격하고 보수적이다. 예를들어 기기가 방화벽이라면 그것은 알수없는 확장자를 포함하는 트랙픽들을 모두 차단하게 만들어 졌을 것이다. 실전에서 사용되고 있는 많은 중간 기기들은 tcp가 더이상 새로운 확장자를 포함하지 않을 것이라는 확실한 가정을 하고 있는 것으로 드러났다.

 결과적으로 대규모 범위에서 확장자를 사용하기 위해 충분히 구현되기전까지 수년에서 십여년에 달하는 기간이 걸릴 수 있다. 아마 tcp를 발전시키는 것은 현실적으로 불가능하다고 말할지도 모른다.

 결과적으로 직접 업그레이드보다 tcp를 대체할 프로토콜이 필요한 것은 분명하게 되었다. 하지만 tcp기능의 복잡성과 다양한 구현들에 대한 복잡성만으로도 처음부터 시작해 새롭지만 더 나은 것을 만드는 일은 매우 기념비적 일이 될 것이다. 이와 같은 이유로 2010년대 초 이일은 미뤄지기로 된 것이였다.

 결국 또한 tcp말고도 http/1.1에도 이슈사항이 있었다. 우리는 먼저 작업을 나누고 1.1을 고치는 첫 시도를 해야 했다. 이제는 /2가 된 그 시도말이다. 그게 완료 됐을때 tcp대체에 대한 일 또한 시작 될 수 있었다. QUIC말이다. 원래 우리는 /2를 quic위에서 직접 실행할 수 있기를 바랬다. 하지만 사실상 이 것은 구현을 너무 비효율적으로 만들었다(주로 기능 복사때문에)

 대신에 /2는 quic와 호환되도록 몇가지 주요영역에서 조정되었다. 이 수정된 버전은 /3이라는 이름이 붙었다(/2-over-quic라는 이름 대신) 주로 마케팅적 이유와 분명성 때문이였다) 이와같이 /1.1과 /2간의 차이는  /2와 /3간의 차이보다 훨씬 더 커다랐다.

 더 알아보기.
중요하게 봐야할점은 우리가 원한 것은 실제 http/3이 아니라 tcp/2였다는 것이고 /3을 그 과정중에 얻었다는 것이다. 그래서 우리가 흥분하는 /3의 주요기능들은 실제 quic에서 온 것이다.(바른 연결 설정, 적은 hol 블라킹, 연결 이송등)

4. Quic란 무엇인가?

 아마 이게 왜 중요한지 당신은 궁금할 수 있을 것이다. 이런 기능이 /3이나 uqic에 포함되는 것에 예민한 사람들은 누구일까? 나는 이질문들이 매우 중요하다고 생각한다. 왜냐하면 uqic는 tcp아 유사하게 http와 웹페이지 로딩외에도 많은 경우들에 사용될 수 있는 일반 전송프로토콜이기 때문이다. 예를들어 nds, ssh, smb, rtp등등 모두가 quic에서 실행될 수 있다. 이와 가은 이유로 quic에대해 좀 더 깊이 봐보자, 왜냐하면 내가 읽었던 /3에 대한 오개념들이 대부분 이곳에서 왔기 때문이다.

 당신이 아마 들어봤을 이야기는 quic는 아직 다른 프로토콜위에서 실행된다는 것인데. User datagram protocol(UDP)가 그것이다. 이건 사실이다, 하지만 많은 사람들이 주장하는 성능적이유때문이 아니다. 이상적으로 quic는 완전히 독립적인 새 전송프로토콜로, 프로토콜스택상 ip프로토콜의 바로 위에서 실행된다.

 그러나 그렇게한다면, 인터넷상의 모든 기기들은 먼저 quic를 인지하고 허락하도록 업데이트 돼야한다.라는 똑같은 문제에 직면하게 만들었을 것이다. 운좋게도, 우리는 널리 쓰이는 다른 전송계층 프로토콜인 udp 위에서도 quic를 만들 수 있다.

 - 알고 있었나요?

Udp는 가능한 가장 기본적인 전송프로토콜이다. 이건 정말 아무 기능도 제공하지 않으며 포트넘버라고 불리는 것 또한 제공하지 않는다.(예를들어 http : 80, https :443, DNS :53 등). 이것은 핸드쉐이크를 사용해 연결을 구성하지 않으며 신뢰가능하지 않다, 만약 udp패킷이 손실되더라도 자동적으로 재전송 되지 않을 것이다.
따라서 udp의 "최고노력" 접근 방식은 결국얼마나 빠른 성능을 가질 수 있냐를 다룬다. 핸드쉐이크를 기다릴 필요도 없고 hol블로킹도 없다. 실전에서 udp는 대개 빠른속도로 업데이트되는 실시간 트래픽에 사용되며 그러므로 패킷손실을 조금 겪을 수 있다. 왜냐하면 미싱데이터는 빠르게 구식이 되기떄문이다.(라이브 화상회의나 게이밍을 생각해보자) 이건 낮은 초기 딜레이가 필요한 경우에도 유용하다. 예를들어 도메인 네임 찾기가 완료되기 위해서는 한번의 왕복이면 된다. 

 많은 출처들이 /3은 성능때문에 udp위에서 만들어졌다고 주장한다. 그것들은 /3이 연결을 만들지 않으며, 패킷 재전송을 기다리지 않고 udp같이 빠르다고 말한다. 그러나 이런 주장들은 틀렸다. 위에서 말했던 것처럼. udp는 /3은 주로 배포하기 쉽게 만들 것이라는 기대로 quic에 의해 사용된다. 왜냐하면 이미 인터넷상 대부분의 기기들에 알려졌고 구현되었기 때문이다.

 그러므로 udp위에서 quic는 tcp를 강력하고 대중적인(뭐 조금은 느리지만) 프로토콜로 만든 거의 모든 기능들을 재구현한다. quic는 절대적으로 신뢰 가능하며 손실된 패킷이 잘 도착했는지 확인 하기위해 수신된 패킷과 재전송에 대해에 대해 승인을 사용한다, 또한 quic는 여전히 연결을 구성하고 매우 복잡한 핸드셰이크를 가지고 있다.

결국 quic는 흐름제어나 정체 제어라고 불리는 메커니즘들을 사용하여 송신자가 네트워크나 수신자에게 오버로딩하는 것을 예방한다. 하지만 이건 순정UDP를 가지고 할 수 있는 것보다. tcp를 더 느리게 만든다. 가장 중요한점은 이런 기능구현에 있어서 quic는 TCP보다 더 똑똑하고 효율적인 방법으로 작동한다는 것이다. 이것은 수십년간의 tcp배포경험과 모범 실전사례들을 몇몇 핵심 기능과 결합했다. 우리는 이 기능들을 이 본문에서 나중에 더 깊이 다뤄볼 것이다.

 - 더 알아보기

 여기서 가장 중요한 점은 공짜점심같은게 없다는 것이다. 단지 tcp를 udp로 대체했다는 이유로 /3은 /2보다 마술처럼 빠르지 않다. 대신에 우리는 quic라고 불리는 훨씬더 발전된 버전의 tcp를 재 설계해 구현했다. 그리고 우리는 quic가 더 쉽게 배포되는 것을 원하기 때문에 udp 상에서 실행한다.

5. 커다란 변경점들.

그래서 quic는 분명히 tcp에서 발전된 것이 맞나? 그렇다면 왜 이렇게 다른건가. quic에는 몇가지 구체적인 기능과 기회들이 있다.(o-rtt data, 연결 미그레이션, 손실과 낮은 네트워크 속도에서 회복 더 잘함.) 우리는 다음 연속시리즈부분에서에서 세부적으로 토의해볼 것이다. 그러나 이 새로운 것들은 4가지 주요 변경점으로 요약된다.

1. quic는 TLS와 깊게 통합된다.
2. QUIC는 다중의 독립적 바이트 스트림들을 지원한다.
3. quic는 id연결을 사용한다.
4. quic는 프레임을 사용한다.

이 부분들을 더 자세히 들여다보자.

말했던 것처럼, TLS(전송계층플토콜)은 인터넷상에서 전송되는 데이터들을 암호화하고 보안하는 역할을 한다. 만약 https를 사용한다면, 당신의 순전한 http데이터는 TCP에의해 전송되기전에 TLS에 의해 먼저 암호화 될 것이다.

 -알고 있었나요?
TLS의 기술적 세부사항은 운좋게도 여기서 매우 필요한 부분은 아니다. 당신은 그냥 암호화가 꽤 고급 수학과 많은 량의 소수들을 이용해 된다는 것을 알아야 한다.
이 수학적 파라미터들은 클라이언트와 서버간에 별개의 TLS구체화 핸드셰이크중에 클라이언트와 서버간 다뤄진다. TCP핸드셰이크와 마찬가지로, 이 과정은 약간의 시간이 걸릴 수 있다. TLS의 구버전에선(1.2이하) 이건 일반적으로 두개의 네트워크 왕복이 필요하다. 운좋게도 1.3 이상의 TLS버전 에서는 한번의 왕복으로 줄었다. 이것은 주로 tls(1.3이상 최신버전)이 다른 수학 알고리즘을 몇개만 사용할 수 있도록 엄격히 제한하고 있기 떄문이다. 이것은 클라이언트가 명시적인 목록대신 서버가 지원할 목록들에 대해 즉시 추측할 수 있고, 왕복을 절약할 수 있다.

초기 인터넷에서 보안트래픽은 처리측면에서 꽤 값비쌌다. 추가적으로 모든 사용사례에 대해 필요하다고 간주되지 않았다. 그러므로 역사적으로 tls는 tcp의 상층에서 선택적으로 사용가능한 완전히 독립적 프로토콜이 돼 왔다.

시간이 지나며 우리의 인터넷 보안에 대한 태도는 당연히 "보안은 기본적인것"으로 바뀌었다. 그러므로 이론에서 http/2는 TLS없이 TCP를 통해 직접 실행 될 수 있었고(이것은 