 운영체제/ 컴퓨터 과학 특강 #18

src=https://www.youtube.com/watch?v=26QPDBe-NB8

이 강의는 호버에서 지원됩니다. 저는 carrie anne입니다 컴퓨터 과학 특가에 오신것을 환영합니다
1940년대와 1950년대 초 컴퓨터는 한번에 한개의 프로그램을 실행했다. 프로그래머는 자신의 책상에서 펀치카드에 하나를 쓰듯이 프로그램을 작성했다. 그다음 방크기의 컴퓨터가 있는 방으로 가져와 전용 컴퓨터 운영자에게 전했다. 그사람은 프로그램을 컴퓨터에 공급한다. 컴퓨터는 그것을 실행하고, 출력을 내뱉고 정지한다. 이 아주 수동적인 프로세스는 컴퓨터가 느려졌을때, 다시 돌아가 프로그램을 실행하는데에는 종종 몇시간 며칠 몇주나 걸렸다. 그러나 컴퓨터는 더 빨라지고 빨라졌다. 기하급수적으로. 조만간 인간이 뛰어다니면서 판독기들에 프로그램을 삽입하는 것은 실제 프로그램 자체를 실행하는 것 보다 오래 걸리게 된다. 즉 컴퓨터가 스스로 작동할 수 있는 방법이 필요하게 되었다. 그리하여 운영체제가 탄생하였다. 

 운영체제 또는 os는 그냥 프로그램과 같다. 그러나 하드웨어에 대한 특별한 권한으로 다른 프로그램을 실행하고 관리할 수 있다. 일반적으로 전원을 켰을떄 처음 시작하는 프로그램이며. 모든 후속 프로그램은 os에 의해 시작된다. Os는 컴퓨터가 더욱 광범위하고 강력해진 1950년대에 시작 되었다. 극초기 os는 일상의 수작업으로 프로그램을 로딩하는 수동적 작업을 강화했다. 한번에 하나의 프로그램을 받는 대신 컴퓨터가 일괄적으로 batch할 수 있었다. 컴퓨터가 하나를 완료하면 자동적으로 즉시 다음을 시작한다. 누군가가 사무실에서 다음 프로그램을 찾느라 고생하는동안 가동 중단 시간은 없었다. 이걸 일괄처리 (batch processing) 이라 한다. 컴퓨터가 빨라지는동안 가격은 더욱 내려갔다. 그에따라 전세계 곳곳에, 특히 대학과 관공서에서 나타났다.

 곧 사람들은 소프트 웨어를 공유하기 시작했다. 그러나 문제가 있었다. 하버드 마크1이나 에니악과 같은 유일 성 컴퓨터의 시대에는 프로그래머들은 하나의 기계에대한 코드를 써야만 했다. 프로세서, 펀치카드 판독기 및 프린터는 이미 알려져 있었고 변함이 없었다. 그러나 컴퓨터가 널리 보급되며, 그들의 구성이 항상 동일 하지는 않았다.
마치 컴퓨터들의 cpu는 같지만 프린터가 같지 않은 것처럼. 이것은 프로그래머에게 커다란 고통이였다. 그들은 프로그램 작성에 대해 걱정 할 뿐만 아니라 모든 모델의 프린터를 포함한 컴퓨터에 연결된 주변 장치들과의 접속법 또한 걱정했다. 

 초기 주변장치와의 접속은 낮은 수준 이여서, 프로그래머는 각 장치에 대한 하드웨어 세부 정보를 알아야 했다. 게다가 프로그래머들이 코드를 테스트하기위해 모든 모델의 주변장치에 접근해보는 일은 거의 없었다. 그래서 그들은 설명서만 읽으면 되도록 최선을 다해 코드를 작성해야 했고, 공유할때 효과가 있기만을 바래야했다. 이 당시는 플러그앤 플레이라고 보긴 어려웠다

 이는 분명 끔찍한 일이었으므로 프로그래머들이 쉽게 사용하도록, 운영체제는 소프트웨어 프로그램과 하드웨어 주변 장치의 중개자로서의 단계를 밟았습니다. 보다 구체적으로 그들은 장치 구동기(device driver)라고 불리는 api를 통해 소프트웨어 추상화를 제공했다. 이를 통해 프로그래머는 표준화된 메커니즘을 사용하여 입출력 하드웨어 또는 줄여서 I/O와 대화할 수 있다. 예를들어 프로그래머는 "print highscore"와 같은 함수를 호출 할 수 있다. 그러면 os는 그것을 종이 위에 올려놓기 위해 무거운 이송 작업을 수행할 것이다. 

 1950년대 말 컴퓨터는 너무 빨라져, 그들은 종종 유휴상태였다. 프린터와 펀치 카드 리더기 같은 느린 기계들을 기다리는 경우가 많았다. 프로그램이 i/o에서 차단 되는 동안 값 비싼 프로세서는 단지 쉬고 있었다. 

 50년대 후반 영국 맨체스터 대학에서는 아틀라스라는 슈퍼 컴퓨터로 작업을 시작했다. 세계 최초의 슈퍼 컴퓨터이다. 이 엄청난 기계를 사용하기 위해 최대한활용할 수 있는 방법이 필요했다. 그 해결책은 1962년에 끝난 atlas supervisor라고 불리는 프로그램이었다. 이 운영 체제는 프로그램을 자동적으로 로드했을 뿐만 아니라 초기의 일괄 처리 시스템 처럼 동시에 여러개의 프로그램을 단일 cpu내에서 실행할 수도 있었다. 그것은 영리한 스케줄링을 통해 작업했다. atlas에서 게임을 실행한다고 하자. print(highscore)라는 함수를 호출하여, atlas에게 highscore라는 변수를 종이에 인쇄하도록 지시한다. 친구들에게 우리가 가상 tiddlywinks(어린이용 표적게임)의 궁극적 챔피언이 누구인지 볼 수 있도록하자. 그 함수 호출은 수천 클락 사이클에 해당하는 시간이 걸릴 것이다. 왜냐하면 기계식 프린터가 전자 cpu에 비해 느리기 떄문이다. 그래서 i/o가 끝날때까지 기다리는 대신 atlas는 프로그램을 절전 모드로 전환하고 다음 대기중인 실행할 준비된 다른 프로그램을 선택하여 실행한다. 결국 프린터가 atlas에 "highscore"값의 인쇄를 마쳤다고 보고한다. Atlas 는 프로그램을 실행 준비가 된 것으로 표시하고, 어느 시점에서 cpu에 다시 실행되도록 예약하고 print문 다음 다음 코드 행으록 계속 진행한다. 

 이 방법으로 atlas는 cpu에서 계산을 실행하는 하나의 프로그램을 가질 수 있다. 다른 프로그램이 데이터를 인쇄하고 있었고, 또 다른 프로그램이 펀치 테이프의 데이터를 판독하고 있는 동안에말이다. atlas의 기술자들은 이 아이디어를 두배로 늘렸다. 4대의 테이프 판독기, 4개의 종이테이프 펀치, 8개의 자기 테이프 드라이브로 컴퓨터를 완성했다. 이로 인해 많은 프로그램이 하나의 cpu에서 한꺼번에 진행되어 시간을 공유할 수 있었다. 이 기능이 바로 운영체제에서 가능한 것이였으며 멀티태스킹이라 불린다. 그럼에도 하나의 컴퓨터에 여러 프로그램을 동시에 실행하는 데에는 큰 걸림돌이 있다. 각각 하나는 메모리가 필요할 것이고, 다른 프로그램으로 전환할때 그 프로그램의 데이터를 잃을 순 없는 노릇이니까 말이다. 해결책은 각 프로그램에 자체 메모리 블록을 할당하는 것이다. 예를들어 컴퓨터가 만개의 메모리 위치를 가지고 있다고 생각해보자. 프로그램 a가 0에서 999까지 프로그램 b가 1000에서 1999까지 할당된 메모리 주소를 얻을 수 있다. 프로그램이 더 많은 메모리를 요구하면, 운영체제는 요청을 승인 할 수 있는지 여부를 결정하고 승인한다면 다음에 할당할 메모리 블록을 결정한다. 이런 유연성은 뛰어나지만 단점을 야기한다. 프로그램 a가 할당된 비 순차 메모리 블록으로 끝날 수 있음을 의미한다. 즉 프로그램 a가 0에서 999까지, 2000에서 2999까지라는 소리다. 이것은 단순한 예제일 뿐이고, 실제 프로그램에는 수십개의 블록이 할당 될 수 있다. 메모리에 전체 흩어져있다는 말이다. 상상할 수 있듯이 프로그래머가 이것을 추적하기에는 매우 혼란 스러울 것이다. 하루의 끝에서 합쳐져야 할 판매 데이터의 긴 목록이 있다고 하자. 이 목록은 다양한 메모리 블록에 걸쳐 저장된다. 이 복잡성을 숨기기 위해 운영 체제는 메모리 위치를 가상화 한다. 가상 메모리를 사용하면 프로그램은 메모리가 항상 주소0에서 시작되어 단순하고 일관되게 유지한다고 가정할 수 있다. 그러나 실제 컴퓨터 메모리의 물리적 위치는 운영체제에 의해 추상화되고 숨겨져 있다. 새로운 수준의 추상화 이다. 프로그램 b를 예로 들어보자. 주소 1000에서 1999의 메모리 블록이 할당 되어 있다.  프로그램 b는 가상 메모리 주소에서 0에서 999사이의 주소를 가진 것으로 나타난다. os와 cpu는 가상-실제 메모리를 다시 자동으로 매핑하여 처리한다. 따라서 b가 메모리위치 42를 요청하면 실제주소 1042를 읽는다. 이 메모리 주소의 가상화는 예시 프로그램 a에서 더욱 유용하다. 예시에서 프로그램 a는 서로 분리된 두개의 메모리 블록이 할당되어 있다. 이것 역시 프로그램 a에게는 보이지 않는다. 하지만 그것은 2000개의 연속적 블록 주소가 할당 되 어 있다. 프로그램 a가 메모리주소 999를 읽으면 동시에 물리적 메모리주소 999로 매핑된다.  그러나 1000을 읽으면 실제 물리주소 2000으로 매핑된다. 이 매커니즘을 통해 프로그램은 메모리 크기를 유연하게 할 수 있다. 이를 동적 메모리 할당이라고 한다. 그것은 그들이 연속적인 것처럼 보이게한다. 이건 모든 것을 단순화하고, 동시에 다중의 프로그램을 실행하는 os에 엄청난 유현성을 제공한다
각 프로그램에 자체 메모리를 할당하는 또 다른 장점은 서로로부터 더 잘 격리 된다는 것이다. 버그가 있는 프로그램이 생기게되면 다른 프로그램의 메모리가 아닌 자신의 메모리를 버리는 데에서 그친다. 이 기능을 메모리 보호라고한다. 이는 또한 바이러스와 같은 악의적 소프트웨어로부터 보호하는데 정말 유용하다. 예를들어 우리는 일반적으로 다른 프로그램이 읽거나 수정할 수 있는 기능을 원하지 않는다. 그러니까 이메일에 그러한 종류의 엑세스 권한이 있으면 악성 소프트웨어가 사용자를 대신하여, 전자메일을 보내고 개인정보를 도용할 수 있다. 좋지 않은 것이다. atlas는 가상메모리와 보호메모리 모두를 가졌다. 그리고 이런 기능을 지원하는 최초의 컴퓨터 및 os였다. 1970년대가 되면 컴퓨터는 충분히 빠르고 저렴했다. 대학교와 같은 기관은 컴퓨터를 구입해 학생들이 사용할 수 있었다. 그것은 여러 프로그램을 한번에 돌리기에 충분히 빠르지 않았고, 동시에 여러 사용자가 상호작용적 접근을 할 수 없었다. 이것은 대형 컴퓨터에 연결되는 키보드 및 화면이지만 . 그자체에 처리능력은 포함되지 않아 터미널을 통해 수행되었다. 냉장고 크기의 컴퓨터는 50개의 터미널이 연결되어 50명의 사용자가 사용가능했다. 이제 운영체제는 여러 프로그램 뿐 아니라 여러 사용자를 다룰 수 있게 되었다. 아무도 컴퓨터 자원을 먹어치울 수 없도록, 운영체제는 시간 공유 기능을 제공하도록 개발되었다. 개별 사용자는 시간 공유를 통해 컴퓨터 프로세서, 메모리등의 일부분만 활용할 수 있었다. 컴퓨터가 너무 빠르기 떄문에 단지 리소스 1/50만 차지해도 개인이 많은 작업을 완료하기엔 충분했다. 초기의 가장 영향력 있는 시간 공유 운영체제는 1969년에 나온 multics, 또는 (multiplexed information and computing service)다중화된 정보와 컴퓨팅 서비스 이다. multics는 처음부터 안전하도록 설계된 최초의 운영체제 였다. 개발자는 장난스러운 사용자가 그들이 해선 안되는 데이터에 접근하는 것을 원치 않았다. 마치 학생이 자신 교수계정에서 기말 시험에 접근하려고 하는 것과 같이 말이다. 이와 같은 기능은 multics가 그당시 많은 양인 1메가 바이트 메모리를 사용했고, 실제로 복잡했음을 의미한다. 이 수치는 단지 OS실행만으로 컴퓨터 메모리의 절반을 차지할 수도 있는 것이다. multics의 연구원 중 한명인 데니스 리치는 이렇게 말했다. 상업적 성공을 거둔 multics가 명백히 잘못한 것들 중 하나는 그것은 어떤 면에서 지나치게 오버엔지니어 된 것이다. 그 안에 너무 많은 것이 있었다. 데니스와 다른 멀틱스 연구원인 켄톰슨은 파업후 유닉스라는 새로운 운영체제를 구축했다. 그들은 os를 두부분으로 분리하고자 했다. 첫번쨰는 커널이라고 부르는 i/o를 다루는 기능인 메모리관리, 멀티태스킹과 같은 os의 핵심기능이였다. 두번쨰 부분은 추가적으로 제공되지만 커널이 아닌 프로그램과 라이브러리 같은 유용한 도구들이였다. 작고 군살 없는 커널을 만드는 것은 의도적으로 일부 기능만 남겨두는 작업이였다. 다른 multics 개발자인 톰 반 블렉은 "데니스에게 멀틱스에서 작성한 코드의 절반이 오류 복구 코드라는 것을 언급했습니다" 라고 회상했다. "우리는 유닉스에서 모든 것을 빼버렸다" 라고 말했다. 오류가 발생하면 패닉이라고 하는 루틴을 갖게된다, 이게 호출되면, 기계는 충돌하고, 당신은 홀로 소리를 지르며 갈것이다. "야, 재부팅해". 커널 패닉이라는 말을 들어본 적이 있을텐데, 이 단어는 여기서 비롯되었다. 말그대로 커널이 충돌할때 복구할 수단이 없기 떄문에 패닉이라는 기능을 호출한다. 원래는 panic이라는 단어를 인쇄하고 무한 루프로 들어가는 작업을 했다. 이 단순함은 저렴하고 다양한 하드웨어에서 유닉스가 돌아갈 수 있다는 것을 의미했고, 데니스와 켄이 일하는 벨 연구소에서 널리 사용되었다. 유닉스를 사용하여 자신의 프로그램을 만들고 실행하는 개발자가 많아지며, 기여되는 도구 수도 증가했다. 1971년 출시 직후 다른 프로그래밍 언어용과 워드프로세서용 컴파일러를 만들었고 1970년대와 80년대 가장 인기있는 os중 하나가 되었다. 동시에 1980년대 초반까지 기본 컴퓨터의 비용은 개인이 구입할 수 있을 정도로 하락했고, 개인 또는 가정용 컴퓨터라고 불렸다. 이것은 기업및 정부 , 대학에서 볼 수 있는 중앙 컴퓨터보다 훨씬 더 간단했다. 그들의 운영체제는 똑같이 단순하게 있어야 했다. 예를들어 마이크로 소프트의 디스크 운영체제 또는 ms-dos는 160킬로 바이트에 불과했지만 이름에서 알 수 있듯이, 하나의 디스크에 맞출 수 있었다. 1981년 처음 출시된 ms-dos는 초기 가정용 컴퓨터로 가장 널리 사용되었다. 비록 멀티 태스킹과 보호된 메모리는 부족했지만. 이것은 프로그램이 시스템을 정기적으로 충돌 할 수 있고, 할 것임을 의미한다. 짜증나긴 하지만, 사용자는 자신의 컴퓨터를 다시 껐다 켤 수 있는 절충안이 있었다. 마이크로 소프트가 85년 처음 출시한 윈도우의 초기버전은 90년대 전반에 걸쳐 os를 지배했지만, 이조차 강한 메모리 보호기능이 없었다. 프로그램이 잘못 수행되면 죽음의 블루 스크린이 뜬다. 전체 운영체제를 중단 시킬 정도로 심각하게 다운 되었다는 신호와 함께말이다. 다행히도 windows의 최신버전은 더 나은 보호기능을 제공하며, 대개의 경우 충돌을 일으키지 않는다. 오늘날 컴퓨터는 Mac os x, windows 10, linux, iOS 및 안드로이드와 같은 최신 운영체제를 실행한다. 비록 우리가 가지고 있는 컴퓨터가 종종 한사람만 사용하는 경우가 많더라도. os는 모두 멀티 태스킹 및 가상, 보호메모리를 갖추고 있다. 따라서 한번에 많은 프로그램을 실행할 수 있다. 웹브라우저에서 유튜브를 보면서, 포토샵으로 사진을 편집하고, spotify에서음악 재생을 하며, dropbox를 동시에 동기화할 수 있다. 이는 운영체제에 대한 수십년간의 연구 및, 이런 프로그램을 저장할 적당한 메모리가 없었다면 불가능한 일이였을 것이다. 담주에 계속하겟다. 이 엪소드를 후원해준 호버에 감사듬. hover는 도메인의 구매와 관리에 도움이 되는 서비스이다. 호버에는 .com, .netㅇㄹ 포함한 400개 이상의 도메인 확장명이 있다. 일반적 주소보다 더 많은 전문적 고유 도메인을 얻을 수도 있다. 여기 crash course에서 mongols.fans라는 도메인을 얻을 수 있다. 한번 도메인을 만들면 기존 이메일로 전달할 커스텀 이메일 주소를 설정할 수 있다. Outlook gmail등을 포함해 당신이 이미 사용하고 있는 것으로. 호버를 사용하면 맞춤 도메인과 이메일 주소를 10% 할인 받을 수 있다. Hover.com/crashcourse로 이동해 커스텀 도메인을 생성하고 우리 프로그램 후원해주삼