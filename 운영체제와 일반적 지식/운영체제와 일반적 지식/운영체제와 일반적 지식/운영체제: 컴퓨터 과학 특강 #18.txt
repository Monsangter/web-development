운영체제/ 컴퓨터 과학 특강 #18

src=https://www.youtube.com/watch?v=26QPDBe-NB8

이 강의는 호버에서 지원됩니다. 저는 carrie anne입니다 컴퓨터 과학 특가에 오신것을 환영합니다
1940년대와 1950년대 초 컴퓨터는 한번에 한개의 프로그램을 실행했다. 프로그래머는 자신의 책상에서 펀치카드에 하나를 쓰듯이 프로그램을 작성했다. 그다음 방크기의 컴퓨터가 있는 방으로 가져와 전용 컴퓨터 운영자에게 전했다. 그사람은 프로그램을 컴퓨터에 공급한다. 컴퓨터는 그것을 실행하고, 출력을 내뱉고 정지한다. 이 아주 수동적인 프로세스는 컴퓨터가 느려졌을때, 다시 돌아가 프로그램을 실행하는데에는 종종 몇시간 며칠 몇주나 걸렸다. 그러나 컴퓨터는 더 빨라지고 빨라졌다. 기하급수적으로. 조만간 인간이 뛰어다니면서 판독기들에 프로그램을 삽입하는 것은 실제 프로그램 자체를 실행하는 것 보다 오래 걸리게 된다. 즉 컴퓨터가 스스로 작동할 수 있는 방법이 필요하게 되었다. 그리하여 운영체제가 탄생하였다. 

 운영체제 또는 os는 그냥 프로그램과 같다. 그러나 하드웨어에 대한 특별한 권한으로 다른 프로그램을 실행하고 관리할 수 있다. 일반적으로 전원을 켰을떄 처음 시작하는 프로그램이며. 모든 후속 프로그램은 os에 의해 시작된다. Os는 컴퓨터가 더욱 광범위하고 강력해진 1950년대에 시작 되었다. 극초기 os는 일상의 수작업으로 프로그램을 로딩하는 수동적 작업을 강화했다. 한번에 하나의 프로그램을 받는 대신 컴퓨터가 일괄적으로 batch할 수 있었다. 컴퓨터가 하나를 완료하면 자동적으로 즉시 다음을 시작한다. 누군가가 사무실에서 다음 프로그램을 찾느라 고생하는동안 가동 중단 시간은 없었다. 이걸 일괄처리 (batch processing) 이라 한다. 컴퓨터가 빨라지는동안 가격은 더욱 내려갔다. 그에따라 전세계 곳곳에, 특히 대학과 관공서에서 나타났다.

 곧 사람들은 소프트 웨어를 공유하기 시작했다. 그러나 문제가 있었다. 하버드 마크1이나 에니악과 같은 유일 성 컴퓨터의 시대에는 프로그래머들은 하나의 기계에대한 코드를 써야만 했다. 프로세서, 펀치카드 판독기 및 프린터는 이미 알려져 있었고 변함이 없었다. 그러나 컴퓨터가 널리 보급되며, 그들의 구성이 항상 동일 하지는 않았다.
마치 컴퓨터들의 cpu는 같지만 프린터가 같지 않은 것처럼. 이것은 프로그래머에게 커다란 고통이였다. 그들은 프로그램 작성에 대해 걱정 할 뿐만 아니라 모든 모델의 프린터를 포함한 컴퓨터에 연결된 주변 장치들과의 접속법 또한 걱정했다. 

 초기 주변장치와의 접속은 낮은 수준 이여서, 프로그래머는 각 장치에 대한 하드웨어 세부 정보를 알아야 했다. 게다가 프로그래머들이 코드를 테스트하기위해 모든 모델의 주변장치에 접근해보는 일은 거의 없었다. 그래서 그들은 설명서만 읽으면 되도록 최선을 다해 코드를 작성해야 했고, 공유할때 효과가 있기만을 바래야했다. 이 당시는 플러그앤 플레이라고 보긴 어려웠다

 이는 분명 끔찍한 일이었으므로 프로그래머들이 쉽게 사용하도록, 운영체제는 소프트웨어 프로그램과 하드웨어 주변 장치의 중개자로서의 단계를 밟았습니다. 보다 구체적으로 그들은 장치 구동기(device driver)라고 불리는 api를 통해 소프트웨어 추상화를 제공했다. 이를 통해 프로그래머는 표준화된 메커니즘을 사용하여 입출력 하드웨어 또는 줄여서 I/O와 대화할 수 있다. 예를들어 프로그래머는 "print highscore"와 같은 함수를 호출 할 수 있다. 그러면 os는 그것을 종이 위에 올려놓기 위해 무거운 이송 작업을 수행할 것이다. 

 1950년대 말 컴퓨터는 너무 빨라져, 그들은 종종 유휴상태였다. 프린터와 펀치 카드 리더기 같은 느린 기계들을 기다리는 경우가 많았다. 프로그램이 i/o에서 차단 되는 동안 값 비싼 프로세서는 단지 쉬고 있었다. 50년대 후반 영국 맨체스터 대학에서는 아틀라스라는 슈퍼 컴퓨터로 작업을 시작했다. 세계 최초의 슈퍼 컴퓨터이다. 이 엄청난 기계를 사용하기 위해 최대한활용할 수 있는 방법이 필요했다. 그 해결책은 1962년에 끝난 atlas supervisor라고 불리는 프로그램이었다. 이 운영 체제는 프로그램을 자동적으로 로드했을 뿐만 아니라 초기의 일괄 처리 시스템 처럼 동시에 여러개의 프로그램을 단일 cpu내에서 실행할 수도 있었다. 그것은 영리한 스케줄링을 통해 작업했다. atlas에서 게임을 실행한다고 하자. print(highscore)라는 함수를 호출하여, atlas에게 highscore라는 변수를 종이에 인쇄하도록 지시한다. 친구들에게 우리가 가상 tiddlywinks(어린이용 표적게임)의 궁극적 챔피언이 누구인지 볼 수 있도록하자. 그 함수 호출은 수천 클락 사이클에 해당하는 시간이 걸릴 것이다. 왜냐하면 기계식 프린터가 전자 cpu에 비해 느리기 떄문이다. 그래서 i/o가 끝날때까지 기다리는 대신 atlas는 프로그램을 절전 모드로 전환하고 다음 대기중인 실행할 준비된 다른 프로그램을 선택하여 실행한다. 결국 프린터가 atlas에 "highscore"값의 인쇄를 마쳤다고 보고한다. Atlas 는 프로그램을 실행 준비가 된 것으로 표시하고, 어느 시점에서 cpu에 다시 실행되도록 예약하고 print문 다음 다음 코드 행으록 계속 진행한다. 이 방법으로 atlas는 cpu에서 계산을 실행하는 하나의 프로그램을 가질 수 있다. 다른 프로그램이 데이터를 인쇄하고 있었고, 또 다른 프로그램이 펀치 테이프의 데이터를 판독하고 있는 동안에말이다. atlasㅡ이 기술자들은 이 아이디어를 두배로 늘렸다. 4대의 테이프 판독기, 4개의 종이테이프 펀치, 8개의 자기 테이프 드라이브로 컴퓨터를 완성했다. 이로 인해 많은 프로그램이 하나의 cpu에서 한꺼번에 진행되어 시간을 공유할 수 있었다. 이 기능이 바로 운영체제에서 가능한 것이였으며 멀티태스킹이라 불린다. 그럼에도 하나의 컴퓨터에 여러 프로그램을 동시에 실행하는 데에는 큰 걸림돌이 있다. 각각 하나는 메모리가 필요할 것이고, 다른 프로그램으로 전환할때 그 프로그램의 데이터를 잃을 순 없는 노릇이니까 말이다. 해결책은 각 프로그램에 자체 메모리 블록을 할당하는 것이다. 예를들어 컴퓨터가 만개의 메모리 위치를 가지고 있다고 생각해보자. 프로그램 a가 0에서 999까지 프로그램 b가 1000에서 1999까지 할당된 메모리 주소를 얻을 수 있다.