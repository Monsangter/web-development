Src = https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview

 1. http에 대한 개요.

 http은 html문서와 같은 자원을 가져오는 프로토콜이다. 이건 웹 위에서의 모든 데이터 교환의 기초라고 할 수 있으며, 요청이 수신자(대게 웹브라우저)에 의해 시작되는 클라이언트 서버 프로토콜이다. 완전한 문서는 서로 다른 가져온 (예를들어 텍스트나, 레이아웃 설명, 이미지, 비디오, 스크립트등과 같은)하위 문서로부터 재구성된다.

 클라이언트와 서버는 (데이터 스트림이 아닌)개인적 메시지를 교환하며 통신한다. 클라이언트(주로 웹브라우저)에 의해 보내진 메시지를 요청이라고 하며  답으로서 서버에 의해 보내진 메시지를 응답이라고 한다.

 90년대 초에 개발된 http는 시간이 지남에 따라 발전해왔으며 확장가능한 프로토콜이다. tcp또는 tls암호화 tcp연결을 통해 전송되는 응용계층 프로토콜이지만 신뢰할만하다면 어떤 전송프로토콜이든 이론적으로는 사용가능하다. 그 확장성때문에 하이퍼텍스트 문서를 가져오는 것 뿐만아니라 이미지나 비디오를 가져올때, 혹은 콘텐츠(html 폼 결과)를 서버에 포스트할때도 쓰인다. http는 요청된 웹페이지 업데이트를 위하여 문서의 부분을 가져올때도 쓰인다.

 2. HTTP 기반 시스템의 구성 요소

  http는 클라이언트 서버프로토콜로, 요청은 하나의 개체, 유저 에이전트(또는 이를 대신하여 프록시)에 의해 전송된다. 대부분의 경우에 유저-에이전트는 웹브라우저이다. 하지만 어떤 것이든 유저-에이전트가 될 수 있는데 예를들어 검색엔진 인덱스를 채우고 유지하기 위해 웹을 크롤링하는 로봇도 그중 하나가 될 수 있겠다. 각 요청은 서버를통해 개별적으로 전송되며 서버는 그것을 처리하고 응답을 제공한다. 클라이언트와 서버사이에는 수많은 계채가 있는데, 하나의 집단으로서 프록시라고 불리는, 게이트웨이와 캐시로서의 역할을 수행하며 다른 작업을 수행한다.

 실제로 브라우저와 서버간에는 요청을 다루는 많은 컴퓨터들이 있다. 라우터나 모뎀등 말이다. 웹의 계층적 설계덕에 네트워크와 전송계층에서 이 과정들은 숨겨져 있다. http는 스택의 제일 위. 응용프로그램 계층에 있다. 비록 네트워크 문제들을 진단하는데 중요하긴 하나 기저에 깔린 층들은 http 설명과 거의 관련이 없다.

 3. 클라이언트: 유저-에이전트

유저 에이전트란 유저를 대신하여 행동하는 도구이다. 이 역할은 일차적으로 웹브라우저에 의해 수행된다. 하지만 엔지니어의 프로그램에 의해 실행될 수도 있고 웹개발자가 그들의 어플을 디버그하기위해 사용될 수도 있다.
 
 브라우저는 항상 요청을 시작하는 개체이다. 절대 서버가 요청을 시작하지는 않는다.(하지만 조금의 메커니즘에선 수년에 걸쳐 서버 주도 메시지가 시도되고 있기는하다.)

 웹페이지를 표시하기위해 웹브라우저는 페이지를 표시하는 html문서를 가져오기 위해 원요청을 보낸다. 그러면 이 파일을 분석하고 그에 상응가능한 실행 스크립트, 레이아웃 정보(css) 페이지에 포함된 서브자원(대게 이미지나 비디오)를 추가 요청한다. 그럼 웹 브라우저는 이 자원들을 합하고 완벽한 문서를 웹페이지로서 보여준다. 브라우저에의해 실행된 스크립트는 추후단계에서 더많은 리소스들을 가져올 수 있고 따라서 브라우저는 웹패이지를 계속 업데이트 한다.


 웹페이지는 하이퍼텍스트문서이다. 이것의 의미는 표시된 콘텐츠의 일부는 링크라는 소리다. 이 링크는 (대게 마우스 클릭으로) 새로운 웹페이지를 가져오게 되는데, 이 웹페이지는 유저들이 그들의 유저에이전트를 지시하고 웹페이지를 탐색할 수 있게 한다. 브라우저는 이런 지시들을 http요청으로 변환하고 나아가 사용자에게 명확한 응답을 제공하기 위해 http응답을 번역한다.

 4. 웹서버

 통신채널의 반대편에는 서버가 있다. 이 서버는 클라이언트에 의해 요청된 문서를 제공한다. 서버는 사실 하나의 기계처럼 보이지만, 실제로는 부하를 감당하는 (부하분산) 서버의 집합일 수도 있다. 아니면 다른 컴퓨터들(캐시, db서버, 이커머스 서버와 같은)에 질문하는 복잡한 소프트웨어의 일부일 수도 있다. 완전히, 또는 부분적으로 요청된 문서를 생성한다.

 서버는 반드시 하나의 기계일 필요가 없다. 하지만 몇명의 서버소프트웨어는 하나의 기계에서 호스트 될 수 있기도 하다. http 1.1과 호스트 헤더로 , 그들은 아마 같은 ip주소를 공유할 수도 있다.

 5. 프록시

웹브라우저와 서버간에, 수많은 컴퓨터와 기계들은 http 메시지를 전달한다. 웹스택의 계층화된 구조 때문에. 이것들은 전송계층이나 네트워크, 물리계층에서 동작한다. http층걔에서는 투명화되고 잠재적으로 그 퍼포먼스에 중요한 영향을 끼친다. 이 응용프로그램 층계에서 실행되는 것은 일반적으로 프록시라고 불린다. 이건 투명화 될 수 있으며, (그들이 받은 요청을 수정없이 전달한다), 투명화되지 않을 수 있다( 이경우 요청을 서버로 전달하기 전에 어떠한 형태로든 요청을 변경한다. 프록시는 수많은 기능을 수행한다.

 - 캐싱 (캐시는 공공화되거나 개인화 될 수 있다. 브라우저 캐시처럼)

 - 필터링 (반 바이러스 탐색이나, 보호자 통제와 같은)

 - 부하 분산 . Load balancing ( 서로다른 요청들을 서비스하기 위해 다수의 서버를 허용한다.)

 - 인증 authentication (다른 자원들에 대한 접근을 통제하기 위해)

 - 로깅 (사용정보들에 저장공간 할당)

  6. http의 기본적 특성들.

6-1 http는 심플하다.

http는 일반적으로 가독성있고 간단하도록 설계 됐다.  http 메시지를 프레임으로 캡슐화하는 http/2에서 도입된 추가적 복잡성에도 불구하고 말이다. http 메시지는 읽힐 수 있으며 인간에 의해 이해될 수 있다. 개발자에게 쉬운 테스트 환경을 제공하며, 새로 온 사람들에게는 줄어든 복잡성을 제공한다. http는 확장 가능하다. http/1.0에서 도입된 http 헤더는 이 프로토콜이 확장하고 실험하기 쉽게 만든다. 새로운 기능또한 클라이언트와 서버간의 새로운 헤더 코드에대한 간단한 합의만으로도 도입가능하다.

6-2 http는 무상태이긴 하지만 세션리스는 아니다.

 http는 무상태이다. 동일한 연결에서 성공적으로 수행되는 두 요청 간에는 연결점이 없다. 이건 특정한 페이지들과 일관성있게 상호작용을 시도하는사용자들에게 즉시 문제가 될 소지가 있다. 하지만 http코드가 그 자체는 무상태인 반면에, http 쿠키는 상태 유지 세션사용을 허용한다. http 쿠키들은 업무 흐름에 추가되고 같은 문맥, 간은 상태를 공유하기 위해 각 http 요청들에 대한 세선 생성을 허용한다.

6-3 http와 연결들

 연결은 전송 계층에 의해 제어되고 그러므로 근본적으로 http 밖의 범위에 있다. http는 기저의 전송프로토콜이 연결기반이 되는 것을 필요로 하지는 않는다. 그냥 단지 신뢰성 있고, 메시지가 손실되지만 않으면(최소한 이러한 경우 오류가 발생해야함)된다. 인터넷상 두개의 가장 흔한 전송 프로토콜 사이에서 tcp는 신뢰성 있지만 udp는 그렇지 않다. 따라서 http는 tcp표준에 의존하고 있으며 이러한 표준은 연결 기반이다.

 클라이언트 서버가 http 요청 응답 쌍 교환을 할수 있기전에 그들은 먼저 tcp연결을 만들어야 한다. http/1.0의 기본 동작은 각각의 http 요청/응답 쌍에 대해 별도의 tcp 연결을 여는 것이다. 이건 하나의 tcp연결을 공유해 다수의 요청이 짧은 시간내 연속적으로 전송하는 것보다 덜 효율적이다.

 이러한 결점을 완화하기 위해 http/1.1은 파이프라이닝(구현하기 어려운 것으로 판명됨)과 영구적인 연결들을 도입했으며, 이에따라 기저에 있는 tcp연결은 connection header 를 사용해 부분적으로 제어 될 수 있다. http/2 는  단일 연결에 걸친 메시지를 멀티 플렉싱 함으로서 연결을 더 따뜻하고 효율적으로 유지할 수 있게, 한단계 더 나아갔다.

 http에 맞는 더 나은 전송 프로토콜을 설계하기 위한 실험들이 진행중이다. 예를들어 구글은 udp위에서 더 신뢰성있고 효율적인 전송프로토콜을 제공할 수 있게 해주는 quic를 실험하고 있다.

 7. http에 의해 무엇이 제어 될 수 있는가?

 시간이 지남에 따라 이 확장적 특성을 가진 http는 웹을 위해 더 많은 제어와 기능들을 허용해왔다. 캐시와 인증 메소드는 초기 https 역사에서 다뤄진 함수였다. 대조적으로 원 제약을 완화하기 위한 기능은 2010년대에 추가되었다.

 여기 http로 제어가능한 일반적 기능들에 대한 리스트가있다.

 - 캐싱

 어떠헥 문서가 캐시될 것인지 캐싱하는 것은 http에 의해 제어된다. 서버는 프록시와 클라이언트에 무엇을 얼마나 길게 캐시할 것인지 지시할 수 있다. 클라이언트는 중간 캐시 프록시가 저장된 문서들을 무시하도록 지시할 수 있다.

 -릴렉싱
 스누핑이나 다른 개인정보 공격을 예방하기 위해 원본제약을 완화 할 수 있다. 웹브라우저는 웹사이트들의 엄격한 분리를 강제한다.

 -인증
 몇몇 페이지들은 보호돼서 오직 특정한 유저들만이 접근 할 수 있을 것이다. 기초 인증은 http에 의해 제공된다.  Www-인증이나 비슷한 헤더들을 사용하면서, 아니면 http쿠키르 사용하는 구체적인 세션을 세팅함으로써.

 -프록시터널링
 서버나 클라이언트는 자주 인트라넷에 위치해 있고, 다른 컴퓨터들에게 그들의 진짜 ip주소를 숨간다. http요청은 이 네트워크 장벽을 가로지르기 위해 프록시를 사용한다. 모든 프록시들이 http프록시 인것은 아니다. 예를들어 socks 프로토콜은 더 낮은 레벨에서 작동한다. Ftp같은 다른 프로토콜들은 이 프록시들에 다뤄질 수 있다.

 -세션
http쿠키를 사용하여 당신은 서버 상태를 요청과 연결 할 수 있다. 이것은 기본 http가 무상태 프로토콜임에도 불구하고 세션을 생성한다.
이건 이커머스 쇼핑바구니 뿐만 아니라 사용자가 아웃풋을 구성할 수 있는 모든 사이트에서 마찬가지이다.

 8. http 흐름

 클라이언트가 최종서버든 중간서버든 서버와 통신하고 싶을때, 다음의 단계를 수행한다.

 -1 tcp연결을 개방한다, tcp연결은 요청을 보내거나 응답을 받을때 사용된다.

 -2 http 메시지를 보낸다: http 메시지(http/2이전)는 인간가독하다. http/2와 함께 이 간단한 메시지들은 프레임안에 캡슐화되고 그 
    들을 직접적으로 읽을 수 없지만 원칙들은 그대로 유지되게 한다. 예를들어:

GET / HTTP/1.1
Host: developer.mozilla.org
Accept-Language: fr

 -3 서버에 의해 보내진 반응을 읽는다. 아래와 같은.


 HTTP/1.1 200 OK
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
ETag: "51142bc1-7449-479b075b2891b"
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

<!DOCTYPE html... (here come the 29769 bytes of the requested web page)

  -4 추후의 요청에 대해 연결을 종료하거나 재 활용한다.
 만약 http 파이프라이닝이 활성화되면 첫번째 반응을 완전히 받을때까지 기다리지 않고도. 몇몇 요청은 대기없이 보내질 수 있다. http 파이프라이닝은 현대적 버전과 구형소프트웨어조각이 공존하는 현재 네트워크에서 구현되기 어렵다고 증명되었다.  파이프라이닝은 http/2에서 보다 프레임내의 강력한 멀티 플렉싱 요청으로 대체되었다.

 9. http 메시지

 http 메시지들. http1.1나 그 이전 버전에서는 인간이 읽을 수 있다. http/2에서 이 메시지들은 이진구조로 이진구조, 프레임에 내장되어 헤더압축과 다중화같은 최적화를 가능케 한다. 원래의 http 메시지의 일부가 이 버전의 http 에서 보내지더라도. 각 메시지의 의미는 변경되지 않으며, 클라이언트는 원래의 http/1.1요청을 재구성한다. 따라서  http/1.1의 형식으로 된 http/2메시지를 이해하는것이 유용하다.

 http 메시지들에는 고유의 포맷을 가진 요청과 응답이라는 두가지 유형이 있다. 

 9-1 요청 

 http요청의 예

  Get / http/1.1.                       method /(path) version of protocol
 Host: developer.mozilla.org 	      headers
 Accept-Language: fr

- HTTP 메서드. Get, post와 같은 동사나 options head와 같은 명사는 클라이언트가 수행하고 싶어하는 동작을 정의한다.
일반적으로 클라이언트는 (get을 사용해) 리소스를 가져오거나, (postm를 사용해) html form 값을 포스트하고 싶어한다. 
다른 경우 더 많은 작업이 필요할 수 있다.

- 가져올 리소스의 경로 리소스의 URL은 문맥에서 확실한 요소에서 제거된다.. 예를들어 도메인 프로토콜 tcp포트 없이 (http://), (developer.mozilla.org),(80)

- http 프로토콜의 버전

- 서버에 추가적 정보를 전달하는 추가적 헤더

- post와 같은 일부 메소드의 경우, 보낸 리소스를 포함하는 응답의 본문과 유사하다.

 9-2 반응

 반응의 예이다.

 HTTP/1.1 200 OK                             version of the protocol. status code. Status message.
Date: Sat, 09 Oct 2010 14:28:02 GMT
Server: Apache
Last-Modified: Tue, 01 Dec 2009 20:18:22 GMT
Tag: "51142bc1-7449-479b075b2891b"                                 headers
Accept-Ranges: bytes
Content-Length: 29769
Content-Type: text/html

 응답은 다음과 같은 요소들로 이루어져 있다.
그들이 따르는 http프로토콜의 버전
응답이 성공적이였는지 아니였는지 왜 그랬는지 보여주는 상태코드.
상태코드에 대해 짧은 비공식적 설명을 하는 상태메시지.
요청을 위한 http 헤더.
추가적으로 가져온 리서스를 포함하는 본문.

10 http에 기반한 api들

 http에 기반을 두고 있는 가장 흔하게 사용되는 api는 XMLHttpRequest api이다. 이것은 유저에이전트와 서버간에 데이터를 교환하기 위해 사용될 수 있다. 현대 fetch api도 더 강력하고 유연한 기능 세트와 함께 같은 기능을 제공한다.

 또다른 api인 서버전송 이벤트는 단방향 서비스이다. 서버가 클라이언트에게 이벤트를 보내는 것을 허용하는. Http를 운송 메커니즘으로서 사용하는. 이벤트 소스 인터페이스를 사용하는 클라이언트는 연결을 개방하고 이벤트 핸들러를 설정한다. 클라이언트 브라우저는 http흐름에서 오는 메시지를 적절한 이벤트 객체로 자동 번역한다. 그리고 클라이언트 브라우저는 이벤트 핸들러에 만약 알려졌다면 이벤트의 타입을 전달하고 만약 구채적인 타입의 이벤트핸들러가 생성되지 않았다면 온메시지 이벤트를 전달한다.

11 결론

 http는 사용하기 쉬운 확장가능한 프로토콜이다. 헤더를 추가할 수 있는 능력과 결합되어 클라이언트-서버 구조는 http가 웹의 확장된 능력과 함꼐 발전할 수 있게 해준다. 

 http/2는 성능을 향상시키기위해 http 메시지를 프레임에 내장하여 복잡해지긴 했지만 메시지의 기본구조는 http/1.0이래로 똑같다.
세션흐름은 간단하게 남기때문에, 간단한 http 메시지 감시만으로도 조사하고 디버깅할 수 있게 해준다.