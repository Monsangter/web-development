Src = https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/
http/3 from A to Z: core concepts 

1. 빠른 요약. 

 거의 5년이란 시간동안의 개발 끝에 새로운 http/3 프로토콜이 최종단계에 근접했다. 최종단계의 반복들은 실험적 기능으로서 이미 사용 가능했다, 하지만 /3의 가용성과 사용이 2021년에 걸쳐 증가할 것이라는 걸 예측 할 수 있다. 그래서 /3은 정확히 무엇인가? 왜 /2가 나온지 얼마 안되어 필요되었는가? 어떻게 사용되고 사용해야하는가? 그리고 이건 어떻게 웹 성능을 증가시키는가? 알아보자.

2. 본문

 당신은 아마 이 토픽에대해 이야기하는 블로그 포스트나 컨퍼런스토크를 들었고 그 답을 알고 있다고 생각할지 모른다. 당신은 아마 이런 이야기를 들었을 것이다. /3은 /2에 비해 패킷손실이 있을때 훨씬 빠르다, "/3 연결은 더 낮은 응답시간을 가지고 있으며 준비되는데 더 적은 시간이 든다" 그리고 아마 "/3은 데이터를 더 빠르게 보내며, 리소스들을 더 병렬적으로 보낸다"라는 말들을 들었을 것이다.

 이런 설명과 기사는 일반적으로 중요한 기술적 세부사항을 생략했으며, 미묘한 뉘앙스가 부족하다. 그리고 대개 부분적으로만 맞다. 그들은 자주 /3을 성능적 혁명으로 만들고는 한다. 그러나 이것은 정말 요란하지 않은 수수한(그러나 여전히 유용하다) 진화이다. 이러한 것들은 대게 새로운 프로토콜들이 실전에서 그들의 높은 기대에 부응하지 못할 것이기 때문에 위험하다고할 수 있다. 나는 이게 많은 사람들을 결국 실망으로 이끌고, 입문자들에게 맹목적으로 잘못된 오류정보들의 더미로 이끌까봐 두렵다.

 이러한 것들은 /2에서 일어났고 우리가 봐온 것들이다. 그것은 서버푸쉬, 병렬 스트림, 우선순위와 같은 흥미로운 새기능을 갖춘 정말 위대한 성능적 혁명으로 사람들에게 소개 됐다. 우리는 자원 번들링을 멈출 수 있었고 우리 자원이 다수의 서버에 샤딩되는 것을 중단하며 페이지 로딩 과정을 엄청나게 간소화 할 수 있을 것이였다. 아마 스위치를 한번 누르면 마법같이 50퍼센트나 빨라질 것이다.

 5년이 지난후 우리는 서버 푸쉬가 실전에서 전혀 동작하지 않고, 스트림및 우선순위는 정말 자주 썩게 구현된다. 그래서 결과적으로 (감소된) 리소스 번들링, 심지어 샤딩 또한 몇몇 상황에서 상당히 좋은 방법이다.

마찬가지로 프리로드 힌트같은 프로토콜 행동을 수정하는 메커니즘들은 자주 숨겨진 깊이와 버그들을 포함하고 그것들이 올바르게 사용되기 어렵게한다.

이와같이 나는 이러한 형태의 잘못된 정보와 비현실적기대들이 /3에대해 퍼지는 것을 막는 것은 중요하다고 생각한다.

이 문서 시리즈 에서 나는 더 많은 뉘앙스를 가지고 특히 그 성능 기능들, 새로운 프로토콜에 대해 말할 것이다. /3이 참 전망 좋은 새 개념들을 포함하고는 있지만 슬프게도 대부분의 웹페이지와 유저들에게 상대적으로 그 영향이 제한된다는 것을 보여줄 것이다. /3를 설정하고 사용하는 것은 매우 어려운 일이므로, 새로운 프로토콜을 구성할때 주의 하도록하자.

 -파트 1: /3의 역사와 핵심 개념
 이 글은 /3과 일반적 프로토콜에 처음인 사람을 타겟으로 했다. 그리고 이것은 주로 기초를 다룰 것이다.

 -파트 2:/3의 성능 기능들
 이것은 좀더 깊이있고 기술적이다. 이미 그 기초를 알고 있다면 여기서부터 시작해도 된다.

 -3파트 3: 실용적인 /3 배포 옵션
 이 시리즈의 세번쨰 글에서는 http/3를 자기 손으로 배포하고 테스트하는데 관련된 문제들을 다룬다.

주의사항: 이 시리즈들은 반드시 깊은 프로토콜 지식을 필요로하지 않거나 더 배우고 싶지 않은 사람들을 타겟으로 잡고 있다. 그러나 충분히 많은 기술적 세부사항들을 다루고 있으며 고급 독자 또한 흥미를 가질만한 외부 소스에 대해 많은 링크들을 가지고 있다.

3. 우리는 왜 /3를 필요로 하는가? 

 내가 가장 많이 직면하는 질문은 "/2가 2015 표준화됐고 나온지 얼마되지도 않았는데 왜 우리는 /3을 필요로 하는가? 만약 당신이 오히려 그 기저에 있는 TCP의 업그레이드가 필요했지 우선 새로운 http버전이 정말 필요없었다는 것을 인정하지 않으면 이상하다.

Tcp는 http와 같은 다른 프로토콜에 신뢰성과 순서있는 전달 같은 중요한 서비스를 제공하는 주요 프로토콜이다. tcp는 우리가 많은 유저들과 동시에 인터넷을 사용할 수 있게 해주는 하나의 이유이다. 왜냐하면 이것은 각 사용자의 대역폭 사용을 공정한 몫만큼으로 제한하기 떄문이다.

 - 알고 있었나요?

 http(s)를 사용할때, 당신은 당신은 실로 http 이외에도 몇몇의 프로토콜들을 동시에 사용하고 있는 것이다. 이 스택안의 프로토콜들은 각자의 고유한 기능과 책임이 있다.(아래 그림 참조) 예를들어 http가 URL가 데이터 해석을 다루는 반면, TLS(전송계층보안)은 암호화로 보안을 보장한다. tcp는 손실된 패킷을 재전송함으로서 믿을 수 있는 데이터 전송을 활성화한다. 그리고 인터넷 프로토콜은 한곳의 종말점에서 다른기기로 패킷을 라우팅한다.

 이 프로토콜의 층계는 프로토콜의 기능을 쉽게 재사용할 수 있도록 하기 위해 수행된다. 더 높은 층의 포로토콜들(http등)은 암호화와 같은 복잡한 기능들을 재구현할 필요가 없다. 왜냐하면 하위계층프로토콜(tls같은)들은 이미 그들을위해 하고 있기 때문이다. 다른 예처럼. 대부분의 인터넷상 어플리케이션들은  그들의 데이터들이 완전히 전송되는 것을 확실하게 하기위해. tcp를 내부적으로 이용한다. 이러한 이유로 tcp는 인터넷상에서 가장 널리 사용되고 배포되는 프로토콜이다.

 tcp는 웹에게 수십년간 주춧돌이 되어 왔다. 하지만 2000년 후반 그 노후화를 보여주기 시작했다. 그리고 이것을 대체하려고 만들어진 quic라고 하는 새로운 전송 프로토콜은 tcp와 그위에 직접적으로 /2를 두고 실행하는 것이 매우 어려울 수 있는 핵심적 몇부분에서 다르다.  이와 같이 /3 그자체는 /2의 새로운 quic 프로토콜과 과 경쟁가능할 수 있게해주는 작은 개조판이다.

 quic는 필요하다. tcp는 대략 인터넷 초기 이래로 정말 최대의 효율을 염두에지고 만들어지지 않았기 때문이다. 예를들어 dcp는 새 연결을 만들기 위해 핸드 셰이크를 필요로한다. 이것은 클라이언트와 서버 둘 모두가 존재하는지, 그리고 그들이 데이터 교환을 원하고 할 수 있는지 확실히 하기위해 수행된다. 그러나 연결상에서 다른일이 수행되려면 먼저 완전한 네트워크 왕복이 완료 돼야한다. 만약 클라이언트와 서버가 지리적으로 멀리 떨어져 있다면 각 왕복 시간(round-trip time, RTT)이 100밀리초 이상 걸려 큰 지연을 유발 할 수 있다.

 두번쨰 예로서 tcp는 전송하는 모든 데이터들을 하나의 파일이나, 바이트 흐름으로서 본다 우리가 동시에 여러 파일을 전송하기 위해 tcp를 사용할지라도말이다.( 예를들어 많은 리소스로이루어진 웹페이지를 다운 받는 일), 실전에서 이것은 하나의 파일을 포함하는 패킷들이 손실된다면, 그 패킷이 회복될때까지 다른 파일들 역시 지연된다는 것을 의미한다.

 이것을 Hol(head of line) blocking이라고 한다. 실전에서 이런 비효율들이 꽤 다루기 쉬운 것은 반면에(그렇지 않았다면 우리는 tcp를 30년 넘게 사용해오지 않았을 것이다.)http등과 같은 상위 프로토콜에도 큰 방식으로 영향을 준다.

 우리는 tcp를 업그레이드하고 발전시키려는 시도를 계속 해왔다. 이러한 문제들을 발전시키고, 새로운 성능향상 기능들을 도입하기 위하여. 예를들어 tcp fast open은 헨드쉐이크 오버헤드를 상위계층 프로토콜에 시작부터 데이터를 보내는 것으로 제거한다. 다른 방식은 multipath tcp라는 것인데, wifi와 4g셀룰러를 동시에 사용해 처리량과 견고성을 늘리는 것이다.

 이런 tcp확장기능들을 구현하는 것은 엄청나게 어려운 일은 아니다. 하지만 그것을 인터넷범위에서 배포하는 것은 극단적으로 어려운 일이다. tcp는 매우 대중화돼서, 모든 연결된 디바이스들은 그들의 보드에 그들 고유의 프로토콜 구현을 가지고 있다. 만약 이 구현이 너무 오래됐고, 업데이타가 안됐고, 버그투성이라면. 아마 확장기능들은 실전적으로 사용가능하지 않을 것이다. 다르게 말하자면 모든 구현은 그걸 실제로 사용하기위해 이미 확장기능들에대해 알고 있어야 한다.

 만약 우리가 종말유저 기기(당신의 컴퓨터나 웹서버등)를 이야기 하는 것이라면 큰 문제는 아니다, 왜냐하면 이것들은 상대적으로 쉽게 수동업데이트 되기 떄문이다. 하지만 많은 다른 디바이스들이 클라이언트와 서버간에 있고 보드에 그들만의 tcp코드를 가지고 있다.(방화벽, 로드 밸런서, 라우터, 캐싱서버, 프록시 등)

 이런 중간단계의 기기들은 업데이트하기 더 어렵고 때때로 그들이 받아들이는 것에 대해서 더 엄격하고 보수적이다. 예를들어 기기가 방화벽이라면 그것은 알수없는 확장자를 포함하는 트랙픽들을 모두 차단하게 만들어 졌을 것이다. 실전에서 사용되고 있는 많은 중간 기기들은 tcp가 더이상 새로운 확장자를 포함하지 않을 것이라는 확실한 가정을 하고 있는 것으로 드러났다.

 결과적으로 대규모 범위에서 확장자를 사용하기 위해 충분히 구현되기전까지 수년에서 십여년에 달하는 기간이 걸릴 수 있다. 아마 tcp를 발전시키는 것은 현실적으로 불가능하다고 말할지도 모른다.

 결과적으로 직접 업그레이드보다 tcp를 대체할 프로토콜이 필요한 것은 분명하게 되었다. 하지만 tcp기능의 복잡성과 다양한 구현들에 대한 복잡성만으로도 처음부터 시작해 새롭지만 더 나은 것을 만드는 일은 매우 기념비적 일이 될 것이다. 이와 같은 이유로 2010년대 초 이일은 미뤄지기로 된 것이였다.

 결국 또한 tcp말고도 http/1.1에도 이슈사항이 있었다. 우리는 먼저 작업을 나누고 1.1을 고치는 첫 시도를 해야 했다. 이제는 /2가 된 그 시도말이다. 그게 완료 됐을때 tcp대체에 대한 일 또한 시작 될 수 있었다. QUIC말이다. 원래 우리는 /2를 quic위에서 직접 실행할 수 있기를 바랬다. 하지만 사실상 이 것은 구현을 너무 비효율적으로 만들었다(주로 기능 복사때문에)

 대신에 /2는 quic와 호환되도록 몇가지 주요영역에서 조정되었다. 이 수정된 버전은 /3이라는 이름이 붙었다(/2-over-quic라는 이름 대신) 주로 마케팅적 이유와 분명성 때문이였다) 이와같이 /1.1과 /2간의 차이는  /2와 /3간의 차이보다 훨씬 더 커다랐다.

 더 알아보기.
중요하게 봐야할점은 우리가 원한 것은 실제 http/3이 아니라 tcp/2였다는 것이고 /3을 그 과정중에 얻었다는 것이다. 그래서 우리가 흥분하는 /3의 주요기능들은 실제 quic에서 온 것이다.(바른 연결 설정, 적은 hol 블라킹, 연결 이송등)

4. Quic란 무엇인가?

 아마 이게 왜 중요한지 당신은 궁금할 수 있을 것이다. 이런 기능이 /3이나 uqic에 포함되는 것에 예민한 사람들은 누구일까? 나는 이질문들이 매우 중요하다고 생각한다. 왜냐하면 uqic는 tcp아 유사하게 http와 웹페이지 로딩외에도 많은 경우들에 사용될 수 있는 일반 전송프로토콜이기 때문이다. 예를들어 nds, ssh, smb, rtp등등 모두가 quic에서 실행될 수 있다. 이와 가은 이유로 quic에대해 좀 더 깊이 봐보자, 왜냐하면 내가 읽었던 /3에 대한 오개념들이 대부분 이곳에서 왔기 때문이다.

 당신이 아마 들어봤을 이야기는 quic는 아직 다른 프로토콜위에서 실행된다는 것인데. User datagram protocol(UDP)가 그것이다. 이건 사실이다, 하지만 많은 사람들이 주장하는 성능적이유때문이 아니다. 이상적으로 quic는 완전히 독립적인 새 전송프로토콜로, 프로토콜스택상 ip프로토콜의 바로 위에서 실행된다.

 그러나 그렇게한다면, 인터넷상의 모든 기기들은 먼저 quic를 인지하고 허락하도록 업데이트 돼야한다.라는 똑같은 문제에 직면하게 만들었을 것이다. 운좋게도, 우리는 널리 쓰이는 다른 전송계층 프로토콜인 udp 위에서도 quic를 만들 수 있다.

 - 알고 있었나요?

Udp는 가능한 가장 기본적인 전송프로토콜이다. 이건 정말 아무 기능도 제공하지 않으며 포트넘버라고 불리는 것 또한 제공하지 않는다.(예를들어 http : 80, https :443, DNS :53 등). 이것은 핸드쉐이크를 사용해 연결을 구성하지 않으며 신뢰가능하지 않다, 만약 udp패킷이 손실되더라도 자동적으로 재전송 되지 않을 것이다.
따라서 udp의 "최고노력" 접근 방식은 결국얼마나 빠른 성능을 가질 수 있냐를 다룬다. 핸드쉐이크를 기다릴 필요도 없고 hol블로킹도 없다. 실전에서 udp는 대개 빠른속도로 업데이트되는 실시간 트래픽에 사용되며 그러므로 패킷손실을 조금 겪을 수 있다. 왜냐하면 미싱데이터는 빠르게 구식이 되기떄문이다.(라이브 화상회의나 게이밍을 생각해보자) 이건 낮은 초기 딜레이가 필요한 경우에도 유용하다. 예를들어 도메인 네임 찾기가 완료되기 위해서는 한번의 왕복이면 된다. 

 많은 출처들이 /3은 성능때문에 udp위에서 만들어졌다고 주장한다. 그것들은 /3이 연결을 만들지 않으며, 패킷 재전송을 기다리지 않고 udp같이 빠르다고 말한다. 그러나 이런 주장들은 틀렸다. 위에서 말했던 것처럼. udp는 /3은 주로 배포하기 쉽게 만들 것이라는 기대로 quic에 의해 사용된다. 왜냐하면 이미 인터넷상 대부분의 기기들에 알려졌고 구현되었기 때문이다.

 그러므로 udp위에서 quic는 tcp를 강력하고 대중적인(뭐 조금은 느리지만) 프로토콜로 만든 거의 모든 기능들을 재구현한다. quic는 절대적으로 신뢰 가능하며 손실된 패킷이 잘 도착했는지 확인 하기위해 수신된 패킷과 재전송에 대해에 대해 승인을 사용한다, 또한 quic는 여전히 연결을 구성하고 매우 복잡한 핸드셰이크를 가지고 있다.

결국 quic는 흐름제어나 정체 제어라고 불리는 메커니즘들을 사용하여 송신자가 네트워크나 수신자에게 오버로딩하는 것을 예방한다. 하지만 이건 순정UDP를 가지고 할 수 있는 것보다. tcp를 더 느리게 만든다. 가장 중요한점은 이런 기능구현에 있어서 quic는 TCP보다 더 똑똑하고 효율적인 방법으로 작동한다는 것이다. 이것은 수십년간의 tcp배포경험과 모범 실전사례들을 몇몇 핵심 기능과 결합했다. 우리는 이 기능들을 이 본문에서 나중에 더 깊이 다뤄볼 것이다.

 - 더 알아보기

 여기서 가장 중요한 점은 공짜점심같은게 없다는 것이다. 단지 tcp를 udp로 대체했다는 이유로 /3은 /2보다 마술처럼 빠르지 않다. 대신에 우리는 quic라고 불리는 훨씬더 발전된 버전의 tcp를 재 설계해 구현했다. 그리고 우리는 quic가 더 쉽게 배포되는 것을 원하기 때문에 udp 상에서 실행한다.

5. 커다란 변경점들.

그래서 quic는 분명히 tcp에서 발전된 것이 맞나? 그렇다면 왜 이렇게 다른건가. quic에는 몇가지 구체적인 기능과 기회들이 있다.(o-rtt data, 연결 미그레이션, 손실과 낮은 네트워크 속도에서 회복 더 잘함.) 우리는 다음 연속시리즈부분에서에서 세부적으로 토의해볼 것이다. 그러나 이 새로운 것들은 4가지 주요 변경점으로 요약된다.

1. quic는 TLS와 깊게 통합된다.
2. QUIC는 다중의 독립적 바이트 스트림들을 지원한다.
3. quic는 id연결을 사용한다.
4. quic는 프레임을 사용한다.

이 부분들을 더 자세히 들여다보자.

말했던 것처럼, TLS(전송계층플토콜)은 인터넷상에서 전송되는 데이터들을 암호화하고 보안하는 역할을 한다. 만약 https를 사용한다면, 당신의 순전한 http데이터는 TCP에의해 전송되기전에 TLS에 의해 먼저 암호화 될 것이다.

 -알고 있었나요?
TLS의 기술적 세부사항은 운좋게도 여기서 매우 필요한 부분은 아니다. 당신은 그냥 암호화가 꽤 고급 수학과 많은 량의 소수들을 이용해 된다는 것을 알아야 한다.
이 수학적 파라미터들은 클라이언트와 서버간에 별개의 TLS구체화 핸드셰이크중에 클라이언트와 서버간 다뤄진다. TCP핸드셰이크와 마찬가지로, 이 과정은 약간의 시간이 걸릴 수 있다. TLS의 구버전에선(1.2이하) 이건 일반적으로 두개의 네트워크 왕복이 필요하다. 운좋게도 1.3 이상의 TLS버전 에서는 한번의 왕복으로 줄었다. 이것은 주로 tls(1.3이상 최신버전)이 다른 수학 알고리즘을 몇개만 사용할 수 있도록 엄격히 제한하고 있기 떄문이다. 이것은 클라이언트가 명시적인 목록대신 서버가 지원할 목록들에 대해 즉시 추측할 수 있고, 왕복을 절약할 수 있다.

초기 인터넷에서 보안트래픽은 처리측면에서 꽤 값비쌌다. 추가적으로 모든 사용사례에 대해 필요하다고 간주되지 않았다. 그러므로 역사적으로 tls는 tcp의 상층에서 선택적으로 사용가능한 완전히 독립적 프로토콜이 돼 왔다.

시간이 지나며 우리의 인터넷 보안에 대한 태도는 당연히 "보안은 기본적인것"으로 바뀌었다. 그러므로 이론에서 http/2는 TLS없이 TCP를 통해 직접 실행 될 수 있었지만(이것은 cleartext http/2라는 이름으로 rfc명세 되었다) 어떤 유명한 웹브라우저도 실제로 이 방식을 지원하지 않았다. 

어떤 면에서는 브라우저 공급업체들은 보안을 위해 성능을 희생하면서까지 의식적인 절충을 했다.

이런 TLS(특히 웹트래픽에 대하여) 기본화 발전상을 봤을때, quic의 설계자가 이 트랜드를 다음 단계로 이행하고자 한 건 놀랄일이 아니다. 단지 /3을 위한 클리어텍스트 모드를 지원하는 걸 넘어서, quic자체에 보안을 깊숙히 침투시키기로 했다. 반면에 quic의 첫번째 구글 명세버전은 이것을 위해 개인 설정을 썼지만, 표준화된 quic는 현존하는 tls 1.3을 직접적으로 사용한다.

이것을 위해 일종의 프로토콜스택 안에 있는 일반적 개별 프로토콜간 분할 청소를 하게되고, 이전의 이미지에서 봤듯이, 1.3은 tcp위에서 독립적으로 돌아갈 수 있지만 quic는 대신에 TSL1.3을 캡슐화한다. 다르게 말하자면 TLS에서 독립적으로 QUIC를 사용할 수 있는 법은 없다. QUIC는 항상 완벽히 암호화되고(/3에서 확장자로)
게다가 QUIC는 거의 헤더에필드에 있는 모든 패킷 또한 암호화한다. 전송계층 정보(패킷번호등 TCP에서 암호화되지 않는)은 quic의 중개자에 의해 더의상 읽을 수 없다)심지어 패킷 헤더플레그의 일부또한 암호화된다) tcp+tls와 다르게 quic는 패킷해더와 페이로드에 있는 전송계층의 메타 데이터 또한 암호화한다.

이를 위해 quic는 수학적 암호화 매개변수를 설정하기 위해 tls1.3핸드 셰이크를 tcp를 이용할 때보다 더, 덜 사용한다. 이 접근은 quic에게 몇개의 이점을 준다.

장점

01quic는 그 사용자들에게 더 안전하다.
클리어텍스트 quic를 실행하는 방법이 없기 때문에, 도청하려고 하는 공격자와 도청자에게 더 적은 선택지를 준다.(최근의 연구는 /2클리어텍스느 옵션이 얼마나 위험할 수 있는지 보여줬다)

02quic 연결 설정은 더 빠르다.
tls, tcp의 경우 두가지 프로토콜은 각자 별개의 핸드셰이크를 필요로 하지만 quic는 전송과 암호화 핸드셰이크를 하나로 통합하여, 왕복을 절약한다.(위 이미지 참고)우리는 이것을 파트 2에서 더 자세히 다룬다.

03 quic는 더 쉽게 발전할 수 있다.
이것은 완전히 암호화 됐기 떄문에, 네트워크의 중개기는 tcp에서 그랬던 것처럼 그 내용물을 더이상 들여다보거나 해석할 수 없다. 결과적으로 그들은 더이상 차기 quic버전에서 업대이트에 실패해 고장날 일은 없다. 만약 우리가 quic에 새로운 기능을 넣고 싶어진다면 중개기 전체를 업그레이드 하는 대신 우리는 종말기기만 업데이트하면된다.

이 이점 외에도 광범위한 암호하에는 단점또한 존재한다.

단점

01 많은 네트워크들이 quic허용을 주저하고 있다.
원하지 않은 트래픽을 감지해내는 것이 더 어려워지기때문에, 회사는 그 방화벽을 통해 이것을 막아버리고 싶어할지도 모른다. isp와 중간 네트워크는 평균 지연과 패킷 손실비율과 같은 계량적 수치들이 더이상 존재할 수 없게되어 문제들을 진단하고 탐지하는 것이 어려워지기 때문에 막고 싶어 할 것이다. 이것들은 quic가 보편적으로 사용되지 않을 것이라는 것을 의미한다. 파트3에서 더 다룬다.

02 quic는 더 높은 암호화 부담을 가진다.
quic는 각 개별 패킷을 tls로 암호화 한다. 반면에 tls~tcp는 몇몇패킷들을 동시에 암호화 할 수 있다. 이것들은 고용량 처리 시나리오에서 quic를 더느리게 만든다. 파트2에서 다룬다.

03 quic는 웹을 더 중앙화 되게 만든다.

내가 자주 맞닥뜨렸던 불만들은 이런 것이였다. quic는 그들이 다른 사람들과는 전혀 공유하지 않으면서 데이터에 완전히 접근하게 해주기 떄문에 구글에의해 추진되고 있다. 나는 대부분 이 생각에 동의 하지 않는다. 첫번째로 quic는 외부관찰자로 부터 사용자수준의 정보(예를들어 방문하고 있는 링크)등을 tls~tcp(quic는 상태유지)가 하는 것보다 더 숨기거나 덜 숨기지 않는다. 

두번쨰로 구글이 quic프로젝트를 시작하긴 했지만 우리가 오늘날 이야기하는 최종적 프로토콜은 더 광범위한 조직인 ietf(internet engineering task force에 의해 디자인 되었다. Ietf의 quic는 기술적으로 구글의 quic 구글의 quic와 매우다르다. 사실 ietf의 대부분이 대기업인 구글이나 패이스북이라거나 cloudfare이나 fastly와 같은 cdn에서 왔다. quic의 복잡성 때문에, http/3가 그랬던 것 과 같이 어떻게 정확하고 성능성있게 배치하는지 필요한 노하우를 가진 회사들이다.
이것은 아마 그런 종류의 기업들에 좀더 중앙화 되는 효과로 이어질 것이고, 이건 정말 걱정거리인 것이다.

 -개인적 생각
이게 내가 이런 글들을 쓰고 많은 기술적논의를 하는 이유중 하나이다. 많은 사람들이 프로토콜의 세부사항들을 알기 쉽게하고 이런 회사로부터 독립적으로 사용할 수 있게 하는 것이다.

 - 더알아보기
여기서 주목해야할 점은 quic는 기본적으로 깊은 암호화를 가지는 회사라는 것이다. 이것은 그 보안성과 정보보호 특성을 증가시킬 뿐만아니라, 배포가능성과 진화 가능성에도 도움이 된다. 이것은 프로토콜이 실행되는 걸 좀 더 무겁게하지만, 결과적으로 빠른 연결설정과 같은 다른 최적화들을 가능케한다.

6. quic는 다중 바이트 스트림에 대해 알고 있다.
Tcp와 quic간의 두번쨰 큰 차이점은 quic가 좀더 기술적이라는 것이다. 우리는 더 파트2에서 더 새부적으로 이 영향들에 대해 탐구해볼 것이다. 하지만 지금은 좀더 고수준의 측면에서 이해해 볼 수 있다.

 - 알고 있었나요?

심지어 간단한 웹페이지라도 많은 수의 독립적 파일들과 자원들로 이루어 져있다는 걸 생각해보자. 거기에는 html, css, javascript, images등등이 있다. 

이런 각각의 파일들은 간단한 이진 덩어리들(브라우저에 의해 특정한 방법으로 번역되는 0과 1의 집합)이라고 여겨질 수 있다. 이 파일들을 네트워크를 통해 보낼때 우리는 그들을 한꺼번에 보내지 않는다. 대신에 좀 더 작은 덩어리(일반적으로 대락 각각 1400바이트 덩어리)로 분할하고 개별 패킷으로 보낸다. 이와같이 우리는 각각의 자원들을, 데이터가 시간에 따라 조금씩 다운로드되거나 스트림될때, 개별적 바이트 스트림으로 볼 수 있다.

/1.1에서  각파일은 고유의 tcp연결이 주어지고 완전히 다운로드 됐기에, 리소스 로딩 프로세스는 꽤 간단했다. 예를들어 우리가 파일 a,b,c를 가지고 있다면 우리는 세개의 tcp연결을 가질 것이다. 첫뻔째 AAAA, 두번째 BBBB, 세번째 CCCC(tcp패킷이 되는 각 문자의 반복)의 바이트 스트림을 볼것이다.

실전에서 브라우저는 얼마나 한꺼번에 많은 연결들이 사용될 수 있는지(그러므로 얼마나 많은 파일들이 병렬적으로 다운로드 될 수 있는지)에 대해 제한을 도입했다. 일반적으로 각 페이지 로드마다 6에서 30정도가 된다. 그 이전의 것이 완전히 전송되면 연결은 새로운파일 다운로드를 위해 재사용 될 것이다. 이 제한은 결국 자주 30개의 리소스보다 더 많은 것을 로드하는 최신 페이지의 웹 퍼포먼스를 방해하기 시작했다.

이 상황을 개선하는것은 /2의 주요 목표였다. 프로토콜은 이것을 더이상 각 파일에대해 새로운 tcp연결을 여는 것으로 해결하지 않고 대신에 단일 tcp연결을 통해 다른 리소스들을 다운로드한다. 이것은 서로다른 바이트스트림을 다중화함으로서 달성된다. 이것은 우리가 서로다른 파일들의 데이터를 전송하는 전송하는 중에 섞는 일을 멋지게 표현하는 방법이다. 우리의 세개의 파일들의 예에서, 우리는 단일 tcp연결을 얻을 것이고, 들어오는 데이터는 AABBCCAABBCC 와 같이 생겼을 것이다.(아마 다른 순서 조합들도 가능할 것이다) 이것은 충분히 간단해보이고 실제로도 잘 작동하며, 적은 오버헤드만으로도, /2를 일반적으로 1.1만큼 빠르거나, 조금 더 빠르게 만들어준다.

이 차이들을 더 자세히 들여다 보자. 1.1은 /2, /3과 다르게 멀티플렉싱을 허락하지 않는다. Aaaabbbbcccc -> aabbccaabbcc

하지만 tcp측면에서도 문제가 있다. tcp는 훨씬 더 오래된 프로토콜이고, 그저 웹페이지를 로딩하려는 목적으로 만들어지지 않았기 떄문에 a,b나 c에 대해 알지 못한다.

내부적으로 tcp는 단지 하나의 파일을 전송하는 것이라고 생각한다. 그리고 http레벨에서는 aabbccaabbcc따위로 보일 것에 크게 신경쓰지 않고, XXXXXXXXX따위로 본다. 대부분의 상황에서, 이건 중요하지 않다. (그리고 이건 실제로 tcp를 꽤 유연하게 만들어준다.) 하지만 예를들어 만약 네트워크상에서 패킷손실이 발생한다면 바뀐다.

세번째 tcp 패킷이 손실됐지만 다른 데이터들은 전달됐다고 가정해보자.(파일 b의 첫번째 데이터가 들어 있는 파일) tcp는 이 손실을 손실데이터의 새 사본을 새패킷으로 재전송 함으로써 대처한다. 하지만 이 재 전송은 도착하는데까지 시간이 걸린다.(적어도 하나의 RTT). 당신은 리소스 a와 c에 대해서는 손실이 없기 때문에 이게 큰 문제는 아니라고 생각할 것이다. 이와 마찬가지로 우리는 손실된 데이터인 b를 기다리는 도중에 a,b를 처리 할 수 있다. 그렇지 않을까?

슬프게도, 재전송 로직이 tcp층계에서 일어나기 때문에 그렇지는 않다. 그리고 tcp는 a,b그리고 c에 대해 모른다. tcp는 대신에 하나의 x파일의 일부가 손실 됐다고 생각할 것이며, 구멍이 채워지기전에 다른 나머지의 데이터들이 처리하는 것을 막아야 할 것이라고 생각할 것이다. 다르게 말하면 /2의 수준에서 우리는 우리가 이미 a,c의 단계를 처리할 수 있다는 것을 안다. 하지만 tcp는 이것을 알지 못하며, 이것은 그들이 잠재적으로 할 수 있는 것보다 더 느려지는 결과를 초래한다. 이게 바로 HOL블라킹 문제의 비효율성 예시이다.

전송계층의 hol블로킹 문제를 해결하는 것은 quic의 주요 목표중 하나였다. tcp와 다르게 quic는 은밀하게만 그게 다중 멀티플렉싱이라는 것을 알고 있을 뿐이다. 당연히도 그게 css,javascript, image를 전송하고 있다는 것을 알지 못한다. 그냥 스트림이 분리됐다는 것만 알고 있다. 이와 같이 quic는 패킷손실 탐지와 회복을 각 스트림 기초라는 논리에 두고 처리한다.

위의 시나리오에서 quic는 스트림 b만 보류할 것이고 a나c의 데이터에 대해서는 /3계층에 가능한한 빨리 전달 할 것이다. 아래 그림에 설명됨. 이론적으로 이것은 성능강화로 나타날 수 있다. 하지만 실전에서 이 이야기는 좀 더 미묘하다. 파트 2에서 알아볼 것이다.

이제 우리는 TCP와 QUIC간에 근본적인 차이가 있다는 것을 알았다. 우연하게도 이것은 우리가 왜 quic를 통해 /2를 실행할 수 없는지에 대한 주된 이유이다.
우리가 말했던 것처럼 /2는 단일 TCP연결을 통해 다중스트림을 실행하는 개념을 포함한다. 이와같이 /2를 통한 quic는 두가지 다르고 경쟁적인 스트림 추상화를 서로의 위에서 가지게 된다.

그들이 함께 잘 작동하게하는 것은 매우 복잡하고 에러가 일어나기 쉽다. 그래서 /2와 /3간의 핵심 차이점은 /3이 http스트림 로직을 제거하고 대신 quic스트림을 사용한다는 것이다. 하지만 파트2에서 우리가 볼 것 처럼 이것은 서버푸쉬, 헤더 압축, 우선순위화 같은 기능들이 어떻게 구현되는지에 다른 영향을 끼친다.

- 더 알아보기

중요하게 다시봐야할점은 tcp는 절대 다중의 독립적 파일들을 하나의 연결을 통해 전송하도록 디자인 되지 않았다는 것이다. 하지만 이건 확실이 웹 브라우징이 필요로 하는 것이고 많은 시간에 걸쳐 많은 비효율로 이끌었다. quic는 다중바이트흐름을 전송계층에서의 핵심 개념으로 만들고 각 스트림이라는 기초에 따라 패킷 손실을 다룬다.

7. quic는 연결 미그레이션을 지원한다.

quic에서 세번째 주요 개선점은 연결이 더 길계유지될 수 있다는 것이다.

-알고 있었나요?

우리는 연결이라는 개념을 웹프로토콜에 대해 이야기할때 자주 사용한다. 하지만 연결이라는게 정확히 어떤 것인가? 일반적으로 사람들은 tcp연결에 대해 두 단말 사이간 혠드쉐이크가 있었을 것이라고 말한다. 이건 udp가 자주 무연결이라고 불리는 이유다. 그러나 핸드셰이크는 특별한게 없다. 이것은 송수신되는 몇개의 특별한 형식의 패킷일 뿐이다. 그건 적은 목표를 가지고 있다. 이것에는 몇가지 목표가 있는데, 그것들중 가장 주요한 것은 반대편에 무엇인가 있는지 확인하고 대화할 의지와 능력이 있는지 확인하는 것이다. 다시 한번 말하지만 QUIC는 그 자체로는 하지 않는 UDP를 통해 작동하고 있지만 핸드셰이크를 수행한다. 

그러므로 의문사항이 따라온다. 그 패킷들은 어떻게 바른 목적지에 도착하는가? 인터넷에서 ip주소는 두개의 고유한 기계간의 패킷을 라우팅하는데 사용된다. 하지만 그냥 핸드폰가 서버간의 ip주소를 갖는 것 만으로는 충분하지 않다. 왜냐하면 둘다 각자의 단말점에서 동시에 다중의 네트워크화된 프로그램들을 실행하고 싶어하기 떄문이다.

각 연결은 기들이 속한 연결과 응용프로그램을 차별화 하기위해 각 단말에대한 포트번호가 부여돼 있다. 서버 응용프로그램은 각자의 기능에 따라 일반적으로 고정된 포트넘버를 가지고 있고(http, https를 위해 포트 80, 443. 그리고 dns를 위해 포트 53)반면에 클라이언트는 대게 각 연결에대해 그들의 포트번호를 난수적으로 선택한다.

이와 같이 기기와 응용프로그램간에 고유한 연결을 정의하기 위해, 우리는 4가지가 필요하다. 소위 4-튜플이라고 불리는 것이다. (클라이언트 ip주소 + 클라이언트 포트 + 서버주소 + 서버포트)

tcp에서 연결은 4튜플에 의해 식별된다. 그래서 이 4가지 매개변수들이 바뀌면 연결은 비활성화 되고 재 설정 돼야한다.(새로운 핸드셰이크를 포함해서) 이것을 이해하기 위해 주차장문제를 상상해보자. 당신은 현재 빌딩 내에서 wifi와 함께 스마트폰을 사용하고 있다. 이와같이 당신은 이 와이파이 네트워크에 대한 ip주소를 가지고 있다.

만약 당신이 밖으로 나간다면 당신의 폰은 셀룰러 4g네트워크로 전환할 것이다. 이것은 새로운 네트워크 이기때문에 완전히 새로은 ip주소를 받을 것이다. 왜냐하면 네트워크마다 다르기 때문이다. 이제 서버는 전에 보지 못했던 클라이언트 아이피 주소로부터 들어오는 tcp패킷을 마주할 것이다(비록 두 포트들과 서버 ip는 당연하게 똑같을 지라도). 이것은 아래에 설명 돼 있다.

tcp의주차장문제: 클라이언트가 새로운 ip를 받을때 서버는 더이상 그것을 연결과 링크시킬 수 없다.

 하지만 서버는 이 패킷이 연결에 속하는 새로운 ip에서 왔다는 것을 알수 있을까? 어떻게 이 패킷들이 같은 랜덤 클라이언트 포트를 선택한 셀룰러 네트워크 상의 다른 클라이언트로 부터 온 새로운 연결에 이 패킷들이 속하지 않는다는 걸 알 수 있을까? 슬프게도 이것에 대해 알수 없다.

 tcp는 우리가 스마트폰들과 셀룰러 네트워크들에 대해 상상하기 전부터 개발되었기 때문에예를들어 그곳에는 클라이언트가 자신의 바뀐 ip주소에 대해 서버에게 알게할 수 있는 메커니즘이 없다. 심지어 연결을 닫을 방법 또한 없다. 왜냐하면 오래된 4튜플에 보내진 tcp 리셋이나 핀커맨드가 다시는 클라이언트에 도달할 방법이 없기 떄문이다. 이와 같이 실전에서 모든 네트워크변화는 기존의 tcp연결들이 더이상 사용될 수 없다는 것을 의미한다.

 새로운 tcp나(그리고 아마 tls) ㅐㅎㄴ드 셰이크는 새로운 연결 설정을 위해 실행 돼야한다, 그리고 응용프로그램수준 프로토콜에 따라 프로세스중 작업을 재 시작해야한다. 예를들어 당신이 http를 통해 큰 파일을 다운로드 받고 있다면. 그 파일은 시작부터 다시 재 요청 돼야 한다.(예를들어 만약 서버가 ranged requests 를 지원하지 않는다면). 다른 예는 라이브 화상 회의이다. 아마 네트워크를 바꿀때 짧은 블랙아웃 현상을 겪을 것이다.

 우리는 파트 2에서 4튜플이 바뀔 수 있는 이유(예를들어 NAT rebinding과 같은) 에 대해 더 알아볼 것이다. 새로운 tcp연결을 재시작하는 것은 그러므로 심각한 영향이 있을 수 있다. (새로운 핸드셰이크를 기다리는 것, 다운로드를 재시작하는 것, 문맥을 재 설정하는 것) 이러한 문제를 해결하기 위해 quic는 connection identifier(CID)라고 하는 새로운 개념을 도입했다. 각 연결은 4튜플의 위에 두 단말간에서 고유함을 식별하는 다른 숫자가 부여된다.

 치명적이게도 이 cid는 전송계층에서 quic자체로 정의 됐기 때문에, 네트워크간을 움직일때 바뀌지 않는다. 이것은 아래의 이미지에서 보여져 있다. 이것이 가능하게 하기위해 cid는 각각의, 그리고 모든 quic패킷의 앞에 포함된다(ipㅜㅈ소와 포트가 각 패킷에서 존재하는 방식과 유사함). 이것은 실제로 quic패킷 해더에서 암호화 되지 않은 몇가지 항목중 하나다)

 quic는 다중의 처리된 연결식별자들을 사용한다. 유저트래킹을 예방하기 위해서.

 이것은 심지어 더 복잡해진다. 왜냐하면 클라이언트와 서버 들은 그들이 직접 선택하는 다른 cid목록들을 가질 것이기 때문에(그들이 다른 포트넘버들을 가지고 있는 것처럼) 이것은 광범위 서버 설정에 있어 라우팅과 로드밸런싱을 돕기위해서이다. 파트3에서 더 자세히 살펴본다.

 -더 알아보기
여기서 더 중요하게 알아 봐야할점은 tcpㅇㄴ에서 연결은 단말이 네트워크를 바꿀때마다 바뀔 수 있는 4개의 매개변수에 의해 정의된다는 것이다. 이와 같이 연결들은 때때로 재 실행돼야 하고, 약간의 다운타임으로 이어진다. uqic는 혼합하기위해 (connection id)라고하는 다른 매개변수들을 추가했다. quic클라이언트와 서버 모두 어떤 연결아이들이 어떤 연결로 매핑 되는지 알고 있으므로 네트워크 변경에 대해 더 강력하다.

8. quic는 유연하며 발전가능하다.

 quic의 마지막 한 단면은 발전하기 쉽게 만들어졌다는 것이다. 이것은 몇개의 다른 방법들로 달성된다. 이미 이야기했듯이, 첫번쨰로 quic가 거의 완전히 암호화됐다는 사실은, 만약 우리가 quic신버전을 배치하고 싶다면 모든 중개기가 아니라 단말점(클라이언트와 서버)만 업데이트 하면 된다는 것을 말한다. 물론 여전히 시간이 걸리는 일이겠지만, 일반적으로 연단위가 아닌 달 단위가된다.

 두번째로 tcp와 다르게 quic는 모든 프로토콜 메타 데이터를 보내기 위해 하나의 고정된 패킷헤더를 사용하지 않는다. 대신에 quic는 짧은 패킷 헤더만 가지고 있고 추가 정보를 통신하기 위해 패킷 패이로드 내부에 있는 다양한 프레임을 사용한다.(작은 특수 패킷의 일종) 예를들어 ACK 프레임(acknowledgements), NEW_CONNECTION_ID 프레임(연결 미그레이션을설정을 돕기위해),스트림 프레임(데이터 이송을 위해)를 사용한다 아래의 이미지에서 보여지는 것처럼.

이것들은 최적화로서 실행된다. 모든 패킷들이 가능한 메타 데이터들을 옮기지는 않기때문에(그래서 tcp패킷해더는 자주 꽤 되는 바이트들을 낭비하고는 한다 상기의 이미지를 봐라). 그러나 프레임을 사용하는데 매우 유용한 부작용은 quic의 확장자로서 새로운 프레임 타입을 정의 하는 것은 미래에 매우 쉬어질 것이다. 예를들어 가장 중요한 것은 믿을 수 없는 데이터를 암호화된 quic연결을 통해 보내도록하는 데이터 그램 프레임이다.

quic는 메타데이터를 보내기 위해 고정된 거대한 패킷해더 대신 개별적 프레임을 사용한다.

 세번째로 quic는 소위 전송파라미터라고 불리는 것을 운송하기 위해 커스텀 tls확장자를 사용한다. 이를 통해 클라이언트와 서버가  quic연결을 위한 구성을 선택할 수 있다. 이것은 기능이 활성화된(예를들어 확장자가 지원된 연결 미그레이션 을 허용할지의 여부) 일부 메커니즘에 대해 합리적인 디폴트 정보(예를들어 최대지원되는 패킷사이즈, 흐름 제어 제한)등을 전달할지의 여부 등을 다룰 수 있다는 것을 말한다. quic표준이 긴 목록을 정의하지만, 새로운 것들을 정의하기 위해 확장자들을 허용하고는 한다, 이러한 것들은 프로토콜을 더 유연하게 만든다.

 최종적으로 quic자체의 실제 요구사항은 아니지만, 대부분의 구현체들은 현재 사용자 공간에서 수행된다.(커널공간에서 주로 수행되는 tcp와는 다르게) 더 자세한 부분은 파트2에서 알아본다. 이것은 quic에서 구현체들과 확장자들을 실험 배치하는 게 tcp에서보다 훨씬 쉽다는 것을 의미한다.

 -더알아보기
 quic가 현재 표준화되고 있기는 하지만 이건 그냥 quic버전 1정도로 여겨져야 한다(Request For Comments(RFC)에서도 분명히 언급된 부분이기도 하다)  그리고 버전2를 상당히 빠르게 만드려는 분명한 의도가 있기도 하다. 게다가 quic는 확장자에 대한 쉬운 정의를 허락한다. 그래서 더 많은 사용 케이스들이 구현될 수 있다.

9. 결론

 우리가 이파트에서 배웠던 것들을 요약해보자. 우리는 어디에나 있는 프로토콜에 대해 주로 이야기했고 그리고 그것이 어떻게 현재의 많은 도전들이 알려지지 않았던 그 시간대에 설걔되었는지 알아보았다. 우리가 tcp를 유지하며 발전시키려 했을때 실용되기 매우 어려울 것이라는 건 확실했다, 왜냐하면 거의 모든 일상기기들이 보드에 그것들만의 업데이트가 필요한 tcp구현체를 가지고 있기 때문이다.

 TCP를 발전시키는 한편 이 문제를 뛰어넘기 위해서, 우리는 새로운 quic프로토콜을 만들었다.(실상은 정말 tcp2.0같은) quic를 더 배포하기 쉽게 만들기위해 udp프로토콜(이것 또한 대부분의 네트워크기기들이 지원한다)의 위에서 실행된다. 그리고 미래에 발전할 수 있다는 걸 확실하게 하기 위해,이것은 기본적으로 거의 암호화 됐고 유연한 프레임 메커니즘을 사용했다.

 이외에도 quic는 대부분 tcp기능(핸드셰이크나, 신뢰성, 정체제어와 같은)이라고 알려진 것들을 똑같이 가져왔다. 암호화와 프레이밍이외에도 두가지 주요 변경점은 다중 바이트 스트림의 인식과 연결 아이디의 도입이다. 하지만 이 변경점들은 quic위에서 바로 /2를 사용하지 못하게 했고, http/3의 창조가 필수적으로 되었다.(실상은 quic를 통한 /2인것)

 quic의 새로운 접근은 수많은 성능 향상의 길을 제시했다. 하지만 그들의 잠재적 이득은 quic와 /3의 길에서 논해진 것보다 훨씬 더 미묘하다. 이제 우리가 기본을 알았으니 이시리즈의 다음장에서 이 미묘함에 대해 더 깊게 이야기해볼 수 있다.

 -파트 1: /3의 역사와 핵심 개념
 이 글은 /3과 일반적 프로토콜에 처음인 사람을 타겟으로 했다. 그리고 이것은 주로 기초를 다룰 것이다.

 -파트 2:/3의 성능 기능들
 이것은 좀더 깊이있고 기술적이다. 이미 그 기초를 알고 있다면 여기서부터 시작해도 된다.

 -3파트 3: 실용적인 /3 배포 옵션
 이 시리즈의 세번쨰 글에서는 http/3를 자기 손으로 배포하고 테스트하는데 관련된 문제들을 다룬다.
