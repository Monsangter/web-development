악성 코드 분석을 위한 네트워크 트래픽 분석.
src= https://www.inflearn.com/course/%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%ED%8C%A8%ED%82%B7-%EB%B6%84%EC%84%9D-%EC%9E%85%EB%AC%B8-%EB%B0%8F-%EC%95%85%EC%84%B1%EC%BD%94%EB%93%9C-%EC%83%98%ED%94%8C-%EB%B6%84%EC%84%9D# 인프런 보안프로젝트

초~중급자를 위한강의.

네트워크 트래픽 분석과 악성코드 어떻게 연결할 수 있는지.
네트워크 기초부터 살펴봄~
실질적으로 필요한것~
네트워크를 실제로 패킷들로 분석
머리어 트래픽 분석을 위해서 사용 도구 튜터리얼
연습 샘플 분석
자바스크립트 난독화, 웹 클라이언트 사이드쪽에서 보통 쓰이는 언어임.dbd같은 공격등이 난독화와 함꼐 들오기도함 네트워크 트래픽에서 http타고 들오기더함
ek라고 익스프롤러 킷이 잇는데 여기서 난독화를 진행해줌 ek마다 난독화 방식 다르기 떔에 난해할 수 잇지만 어느정도 이후에 문맥을 파악할 수 잇을 정도로는 진행해줌. 실제 사례들을 들어가면서 어떻게 이런 자바스크립트 난독화와 와이어샤크 네트워크를 통해서 어떻게 사건이 진행 됏엇는지 또는 머래어가 어떻게 동작하는지를 네트워크라는 큰틀에서 악성코드도 크게 시스템 족에 파트가 있기때문에, 이번엔 네트워크에 촛점맞춰서 진행해봄.


1. 네트워크 트래픽 분석과 악성코드

네트워크 트래픽분석을통해 악성코드랑 어캐 연관대잇는지 분석해봄. 악성코드를 분석하는데 네트워크 트래픽이 왜 필요할까 악성코드도 네트워크가 발전함에 따라서 같이 발전하는 사례를 같이 역사를 볼수잇슴

옛날에는 네트워크가 발달안돼서 악성코드가 네트워크로 전파가 안댓음. 플로피 디스크나 다른 매체를 통해 전파가 됏다면 오늘날엔 초고상인터넷이 디폴트기 땜에 악성코드와 항상 연결돼 잇음.

군용 연구용으로 쓰이다 2000ㄴ년대 민간 상업용으로 전세계적 이용. 기술이 좋아지만 안정성 떨어짐. 한국이 네트워크 발달하긴햇는데 문제 생길수도잇는양상

01 악성코드 분석에 네트워크 트래픽이 필요할까

실질적으로 악성코드(실험적 자기복제코드)가 등장한 시점은 71년, 잠잠하다 86년부터 급격히 개체수와 종 증가. 이후 백신역사도 시작

총 악성코드 개수 지수적 상승. 신종출현은 수그러듬. 보급속도보다 몇년 늦음. 보급된후 몇년뒤 악성코드가 따라 는다는 말.

02 악성코드는 대부분 네트워크 트래픽을 타고 이동한다.

악성코드는 어떻게 네트워크 트래픽 타고 이동하나. 초창기 악성코드는 디스켓을 통해 이동 했으나 오늘날 악성코드는 인터넷 통해 전파.

 -1 브라우저를 통한 악코유포
 -2 불법크랙프로그램을 사용한 유포
 -3 피싱/파밍을 통한 유포
 -4 외부문서 매크로를 통한 유포.

03 네트워크 악성코드 실제 사례

 -1 브라우저 
 고전적임. 검색만으로도 유포되고, 특히 (힙취약점 이용)ie버전과 fláh취약점 조합으로 유포. 가끔 크롬을 통해서도 유포. 랜섬웨어가 이런 식으로 전파. 보안시스템 잇어도 연구해서 우회함. 계속 진화.
ie강이는 아니나 윈도 애플리케이션 취약점 분석이라는 강의도 잇음. (stack쪽 취약점 이용) 이 강의에서 취약점은 다루지 않는데 패킷이 어떻게 왓다갓다 하는지 정도는 다뤄보겟다.

 -2 불법 크랙 프로그램 사용
 웹하드, p2p,블로그 통해 유포. 공짜 좋아하는 불법 사용자 노리고 악성코드 같이 심어놈. 심지어 알고서도 실시간 감시기능 끄라고해서 끄는경우도잇음. trojan있을 확률 높음(몰래 로컬에 다운로드 받아놓음)

 -3 피싱 파밍을 통한 악성코드 유포.
 사용자를 속에 공격자가 임의로 만든 사이트에 접속하게 한뒤, 개인정보 입력하게하는 사회공학적 방법.
실제 페이스북측에서도 api를 잘만들어 제공하고 개인정보를 조금은 요구하기는 하는데, 아이디와 패스워드를 직접적으로 요구하지 않음. 패스워드도 해시로 저장함.

 -4 외부 문서 매크로 사용 
 이메일 등으로 스팸오는 문서를 보면 hwp,pdf,excel,word 첨부 일반 사용자의 경우 exe파일이나 zip파일만 경계하기도 하는데 매크로가 첨부된 파일일 수도 있음. 한글, pdf의 경우 취약점을 주로 이용하고, excel과 word의 경우 대부분 ms office에서 제공하는 매크로로 악성 코드 유포.

04 네트워크 분석이 악성코드분석에 미치는 영향.

 -1 악성코드의 정확한 행위 파악
	대부분의 악성코드가 네트워크 트래픽을 주로 사용(랜섬웨어 디도스 원격프로그램 조정, 트로젠 등) 디도스 공격을 위한 좀비 pc모으기, 특정 사용자 감시. 파일을 인질로 돈 요구하는 행위. 악성코드의 직접행위를 알아내기 위해서는 네트워크 트래픽 분석 필요. 
	악성코드가 시스템쪽에서 ollydbg나, 디버깅을 해서 파악가능한 부분이 있고 실질적으로 네트워크 트래픽이 필요한 부분도 있다. 네트워크 트래픽이 중간에 멈추면은 갑자기 진행이 안되는 경우도 있고 cnc서버가 살아있다면 주로 이런 cnc서버와의 통신을 통해서. 이런 네트워크 트래픽을 활용한다는거다. 없으면 임시방편으로 임의 서버 올려, 테스
	팅 하기도함.

 -2 악성코드 네트워크 흐름에서 탐지 및 차단

	ids장비등에서 네트워크 패킷을 감시하는데 필요.
	우리가 추출한 패턴에서 패턴이 abcd로가는 문자열로 흘러간다. 어디에서도 볼 수없던 패턴이다 하면은 ids장비에다 등록 해놓음. 오른보안 업체 가비아의 보안 장비 설치사례 보면 백본 - ngfirewall - waf -switch -servergorup
																				-(mirroring) IDS 
	백본에서 서버 그룹사이에 트래픽이 왔따갔따 하고 ids는 그중간에서 패킷을 미러링함. 패킷에 특정 문자열(악성코드 삽입)을 발견하면 위험알림.

05 네트워크 분석에 필요한 것들
 -네트워크 기초 이론 
  na나 np같은 공부도 해봣는데 불필요한거 뺴고  네트워크 기초이론부터 해서 진행할 예정이다. 

 -네트워크 프로토콜 구조와 이해
  이론적으로 헤더가 어떻게 생겨느니 같은 것도 살표본다. 근데 와이어 샤크로 실제 패킷확인도 해보겟음.

 -네트워크 분석 툴
  네트워크 관련해서 공부하면 시스코장비 같은거 다루는 방법 배우긴 하는데 네트워크 트래픽이 어떻게 왓다갓다하는지는 안배움. 이건 실제로 왔따갔다 하는 패킷이 어떤 역할을 하고 의미를 갖는지, 둘이 왓다갓다 하는걸 바이너리 형태로 보면 전혀 모름. 글키떔에 툴을 사용하면 자동화 되어서. 단순하게 분석 가능하다. 이런 툴에대한, 도구에 대한 이해를 해본다. 

 -실제 악성코드 트래픽 분석경험

전지해줄수잇는건 전지해주고 악성코드가 어떻게 전파되는지 확인하는 시간 갖겠다.

가장 중요한건 이론. 그 바탕으로 프로토콜 구조 이해. 다음으로 분석 툴. 나는 데이터 분석을 기초부터 다갈킴. 관련된 라이블러리 잇으면 다 알려줌. 다른데는 일케 안갈치고 넘파이 좀 배우고 텐서플로 좀 배우고 함. 근데 나는 넘파이, 냄블로비? 배움. 이거 배우고 판다스로 넘어가니까 편하다. 네트워크도 중복된 라이브러리를 쓰고 잇기떔에, 굉장히 편하다. 근데 요즘 과정들 보면 넘파이 냄블로비 다 뻄. 글고 판다만 갈킴. 그럼 텐서플로 못함. 뉴럴 어쩌고 해야대는대 못함. 다시 배워야함. 저랑 같이하면 안해도댐. 네트워크도 마찬가지로 네트워크 기초안하면 망함. 프로토콜 이해 못하고, 툴 사용못함. 사용은 할지못해도 확장은 못함. 그래서 기초부터 해야댐.분석툴 버그 많아서 기초부터 알고 잇어야 문제안생김 기초부터차근차근 ㄱ. 실제 악성코드는 변칙 변수 난무. 그래서 확장이 적용되지 않으면 문제 생김. 기초를 다 익히면 필없는데 모르면 듣고 위단계로 넘어가삼.

===========================

2. 네트 워크 기초

네트워크 분석이 아직 미숙 미흡하다 생각하면 들으삼

 01 osi 7layer 

 -1 데이터 통신 시스템
   -기본개념
컴퓨터랑 원거리에 있는 컴퓨터, 또는 다른 원거리에 있는 컴퓨터를 통신회선으로 결합해 정보처리하는 시스템.
중간에 라우터들이 잇을 수도 있겠고.. 웹페이지를 요청하면 서로 주고 받는다는 소리
메시지, 송신자,수신자,전송매체, 프로토콜 5가지 기본요소로 구성.

메시지 = 네이버 표시해줘. 송신자 =클라, 수신자 = 서버, 전송매체 = 라우터나 중개기들 ( 직사각형으로 생겨서 뭐 모아놓고 씀. 아파트 지하나 가보면 잇음), 프로토콜 = 규약 웹상에서 벌어지는 프로토콜을 http라는 규약으로 묶고 있는데, 네이버라는 어떤 회사에 웹페이지를 요청할때 get 인덱스 붙이고 호스트 붙이고 다양하게, .. 얘네를 헤더라고 부름. 글고 줄바꿈 두번하면 끝남. 이것 자체가 일종의 메시지가 댐. 응답도 규약이 있다. 정보를 보고서 형식에 맞게 전송해주니까 브라우저가 스크린에 표시하는거임.

   -구성요소 
데이타 다말장치 DTE(Data terminal Equipment) 송수신장치. 즉 단말기.
링크 프로토콜에 따라 행해지는 데이터 통신 제어기능을 갖추고 있는 단말장치나 주 컴퓨터

데이터 통신 장비 DCE(Data Communication Equipment) 
DTE와 전송로 사이에서 접속 설정, 유지, 해제, 부호-신호 변환을 위한장치

전송매체
메시지가 전달 되는 물리적 경로. 동축 케이플 트위스티드 페어(utp),광케이블 (내구성문제로 안에 묻혀잇음)

 -2 프로토콜
   -기본 개념
정보의 송 수신측. 또는 내트워크 내에서 약속된 규약이나 규범. 
중국인이랑 일본인이 서로 어캐 통신 하겟음. 그래서 프로토콜을 통해 통신함. 
연결과정, 통신회선 접속방식, 통신 회선을 통해 전달되는 정보 형태, 오류발생제어, 송/수신측 간 동기 방식등에 대한 약속

   -주요 요소
	-구문(신택스)
데이터의 형식(format)( http가 헤더 바디로 나눠져잇는것처럼), 부호화(coding) 신호레벨(signal level) 등이 어떤 구조와 순서로 표현.
	-의미(서멘틱)
각 비트가 갖는 의미, 보통 비트단위로 이야기하는 것들은 tcp나 udp 이런 것들이 잇음. 이진 비트에도 비트별로 의미가 잇는데
패턴에 대한 해석과 해석에 따른 전송제어, 오류수정등에 관한 제어 정보를 규정.
	-타이밍(타이밍)
두 개체간의 통신 속도를 조정하거나 메시지 전송시간 및 순서등에 대한 특성 조정. 해외 통화하는거 생각해보샘

 -3 LAN(Local Area Network)
	-정의
각 집을 봐도 스위치나 라우터 같은거 하나 쯤은 잇음. 이거에 티비, 컴퓨터 폰등이 연결 돼 있는 구조인데 좁은 범위에서 dte들의 연결을 제공함.
	-토폴로지
네트워크에서 호스트들을 연결하는 케이블 구조 혹은 기하학적 모양.

각 토폴로지마다 장단이 잇음. 우리가 주로 사용하는건 성형.

		장점							단점

성형,트리형		유지보수, 확장 유리. 하나의 중앙에 분산 연결되어 호스트의 고장은 영향 안줌. 중앙 전송제어장치의 고장이 치명적. 
								        케이블링 비용 커짐. 통신량 많으면 전송지연 발생

버스형		설치 용이, 케이블링 소요비용 낮음. 하나의 호스트 고장이 네트워크 영향안줌.  재구성결함분리 어렵고 버스 케이블 결함발생치명적

링형		단순해 설치와 재구성 간편 장애 발생한 호스트 쉽게 찾을 수 잇음		링을 제어하기 위한 절차 복잡으로 기본적 지연
		호스트 수 늘어나도 네트워크 성능 올라감.				단방향 전송으로 링결함시 통신불가. 새호스트 추가시 물리적으로 링절단필요

 01 osi 7layer - 2 Osi 7 layer

 통신들이 이제 정확히 어떻게 이루어지는데 물리적인걸 넘어 소프트웨어단으로 들어가 살펴보겟삼

 -기본개념
 Iso에서는 개방형 시스템 간 상호 접속(osi: Open System Interconnections)을 위해 표준화된 네트워크 구조를 제공하는 기본 참조 모델을 제정 했다.
 기종간 상호 접속을 위한 가이드 라인이라 할 수 있는데, 요즘엔 많이 안쓰이고 tcp/ip 쓰임. 70년대 이후 인터넷 발달하고 각 사별로 다른 프로토콜 사용하기 시작해서 국제기구에서 osi 7 layer 만듬.
표준화된 네트워크 구조를 만들어서 서로 통신할 수 있게 하자. 너무 복잡하고 세세함. 세세해서 공부하긴 좋은데 복잡해서 실제로 응용단에서 이걸 구현하기가 쉽진 않음. 공부하긴 좋지만 사용하기엔 문제가 잇음.

 상위계층 5-7 사용자가 통신을 쉽게 이용할 수 있도록 도와줌. 사용자와 가깝구나.
 어 프 세

 하위계층 1-4 효율적이고 정확한 전송과 관계된 일을 담당. 네트워크와 가깝구나
 트 네. 데링 피
 -계층구조
제반 통신절차 가운데 비슷한 기능을 갖는 모듈을 동일 계층으로 분할함.
각 계층간의 독립성 유지.
한 모듈에 대한 변경이 다른 전체 모듈에 미치는 영향 최소화.
계층은 2개 그룹으로 분리.
상위 3계층인 유저가 메시지 교환시 사용
하위 4계층은 메시지가 호스트에서 사용.

 -피어투 피어 간 통신
 하향할 수록 프로토콜 제어정보(pci)를 패킷에 덧붙임 (패킹). 상향할수록 다시 벗김.

 -캡슐화와 역캡슐화(encapsulation, decapsulation)

캡슐화 
어떤 것을 다른 것에 포함 시킴으로써 포함된 것이 외부에서 보이지 않도록 함.
프로토콜 데이터 단위를 다른 프로토콜 데이터 단위의 데이터 필드 부분에 위치 시키는 기술.
일종의 패킹 과정을 캡슐화라 함.
데이터를 추가하는 기술

역캡슐
이를 제거하거나 또는 캡슐화 이전으로 복원
캡슐화의 반대 동작
데이터를 추출하는 기술

노트북을 택배로 보내는 상황을 생각해보자. 새 상자도 필요하고 안에 뽁뽁이 완충제 받는사람 주소등 넣어야함.
프로토콜 데이터 필드에 위치하고 있는 데이터 단위를 추출.

 각 층계의 데이터를 pdu(protocol data unit)이라 부른다. 걍 패킹된 사앹를 말하는거임.

 -2 각 레이어의 기능 및 역할.
	-물리계층 피지컬 레이어.
물리매체, 물리적 링크의 설정/유지/해제
사용자 장비와 네트워크종단장비 사이 물리적 전기적 인터페이스 규정
전송 선로의 종류에 따른 전송 방식과 인코딩 방식 (자기 나름대로의 프로토콜) 결정
송신 측 물리 계층은 데이터 링크 계층으로 부터 받은 데이터를 비트단위로 변환.
수신 측 물계에서는 받은 비트를 데링층의 데이터로올림.

걍 전기 선임. 네트워크가 전기선을 통해 물리적 전기적 인터페이스에 전송방식을 가지고 비트단위로 전환해서 보낸다.
데링에서 온 프레임(바이너리 코드)를 전기신호 (비트)로 바꿔 보냄

	-데이터 링크 계층(데이터 링크 레이어)
물리계층에서 사용하는 비트에 대한 것들을 원활하게 전송하기 위해 흐름제어라든지 오류제어를 해주고
헤더에 프레임스탓 표시 목적지 주소, 트엘리어에 오류 검출 코드 프레임 스탑등을 포함함.(비트는 전기적 신호기땜에 잡음이 많이 껴잇어서 오류검출코드 필요)

두 서브 계층으로 이루어져 있고

하나는 논리적 연결제어를 하는 llc와 장비와 장비간 물리적 접속을 하는 mac로 나뉜다. 이두가지를 통과하면 패킷 이라는 패킷이란게 잇는데 헤더-패킷-트레일러 다붙여 프레임이라 함. 상향할떄는 헤더 트레일러 벗기고 패킷(데이타 부분만)만 올라감.
	-네트워크 계층
이전이 단대 단연결이엿으면 이건 종단간 연결.
송신측 부터 수신측 까지 데이터 안전전달을 위해 논리적 링크 설정. = 아이피를 설정한다.
실 네트워크는 단말기 사이에 많은 라우터나 중개기 등이 잇음. 이게 너무 복잡하기 떔에 그냥 논리적으로 바로 클-섭 연결이 돼 있는 것처럼 보이게 하겠다는 거임. 이게 아이피.
상위 계층의 데이터를 작은 크기의 패킷으로 전송한다. = 사실 데이터는 엄청큼 report.doc라는 40mb파일을 만들엇다 해보자. 한번에 전송하기엔 너무 크고 손실이나 오류가 발생할 가능성이 너무 큼.
글키떔에 잘개 쪼갬. mpu라고 함. Max packet unit 그리고 각 하나를 패킷으로 만듬. 이거 하나가 헤더 푸터 붙어서 프레임 만들어지는 거임. 즉 프레임이나 비트로 나눠 보냄.

개방형 시스템사이에서 네트워크 연결ㅇㄹ 관리하고 유지하며 해제. 스위치는 4걔충 스위치도 있지만  2계층에서 주로 동작하고, 
스위치 . 패킷의 수신주소를 보고 정해진 방향으로 전송. 동작속도는 라우터 보다 빠름. 보통 라우터가 더 많이 쓰임. 라우터는 연결을 유지할수 있또록 관리하고 유지하고 잇음. 라우팅 테이블에 따라 네이버의 주소를 따라서 라우팅을 하는거임.

네트워크 주소는 발신지로부터 목적지 까지 동일하게 적용된다. 한번 목표지를 네이버로 잡았으면 그 목표 논리주소는 계속 유지됨. 물리주소는 패킷이 한 시스템에서 다른 시스템으로 이동될때마다 변경. 데이터 링크 계층은  인식할수 있는 범위는 그냥 바로앞 라우터까지임. 그래서 다 따로 보내는 거임. 즉 네이버라는 논리주소를 가지고 있기 때문에 목적지를 향해 갈수잇는거임

컴퓨터가 있으면 라우터에 접속해서 네이버를 요청한다. 물리로 돼있지 논리적인 주소와 바로 연결돼 잇지 않음. 그래서 클라이언트는 네트워크 드라이버 같은 물리 장치를 통해 갖고 있는 물리주소를 가지고 물리계층에 대한 정보를 b로 보냄. 그럼 b는 그걸 버리고 그다음으로 연결된. 라우팅 테이블을 보고 c로 보냄. c는 그럼 또 그걸 가지고 라우팅테이블 참조~~~ 일련의 과정. 물리주소는 계속 한단계를 거칠떄마다 바뀜.  라우터가 수신하고 다시 송신할때도 또 주소 바뀜. 그러나 ip자체는 바뀌지 않는다. 네트워크 자체는 바뀌지않는다. 그러나 앞에서 말햇듯이 데이터링크에서 헤더의 어드레싱 부분은 계속 바뀐다는 것이다. 그래서 2계층은 1계층간의 단거리 통신을 말한거고 네트워크 레이어부터는 논리주소를 활용 멀리 멀리~ 근데 원래 어려운거고 와이어 샤크라는 툴쓰면 다 알아서 분석해줌. 이런것들이 있따는 거 그냥 알고 있고 ccna나 ccnp확실하게 알고 잇으면 관련된 내용을 정확히 학습가능



		-물리 주소와 네트워크 주소

시리어 포트나 아이피주소 같은 것들이 잇음. 라우터 아이피(ex 10.1.1.0/30), 글고 라우팅 테이블은 목적지에대한 아이피를 가지고 잇음. 이런식으로 연결됨. 너무 자세히 보면 또 너무 벗어남 이미 설명하기도 햇고. 그래서 어쩃든 물리적 통신과 네트워크 주소는 따로 다룬다. 그래서 라우터등은 물리적인 주소와 아이피 주소가 따로잇다. 그정도 사실만 아삼

	-전송계층

하위계층의 마지막 단계. 네트워크에선 섭클간 논리적 주소연결이 잇다 햇는데 전송계층은 한번 더 확장해 포트까지 연결이 된다. 아이피는 어떤 컴퓨터냐 를 나타낸다고 보면 되고, 포트는 서비스를 나타낸다.
한 컴퓨터에는 여러가지 서비스를 제공하고잇음. 그래서 이런 서비스간을 이어주는게 전송계층임. 종단간 제어. 아이피가 컴퓨터간의 종단연결이였따면 얘는 서비스간 종단연결임.
인터넷 간에 연결이 다음에도 http80이나 텔넷23, ftp 21같은 서비스가 잇음. 이런 서비스를 하나의 컴퓨터에서 제어하고 있기 땜에 서비스를 구분해준 얘가 바로 트렌스포트 레이어다.


	-상위계층
딱히 설명할게 없음. http나 프로토콜 계열 들가야 얘기가 나옴.
		-세션계층
특정한 프로세스들 사이에서 세션이라고 불리는 연결을 확립하고 유지하며 동기화. 세션은 어렵게 볼건 없고 걍 연결이라는 뜻 ㅎ
		-표현 계층
데이터 표현방식. 포맷을 맞추는거임. 데이터 보안과 효율적 전송을 위해 암호화와 압축 수행하여 세션 계층으로 내림.
		-응용계층
최상위 계층으로 응용프로세스(이용자나 응용프로그램등이 상호 동작하는 환경) 네트워크 환경에 접근하는 수단을 제공. 우리가 브라우저 창 키고 접속할때 일일이 패킷을 구현하고 표현이랑 세션을 어캐할건지 하지 않지. 이걸 브라우저가 함. 즉 네트워크환경에 접근하는 수단을 제공하고 있고, 응용 프로세스들이 상호간에 유용한 정보 교환할 수 있도록 하는 창구 역할 담당


응용		각종 응용서비스 제공				메시지		ftp,tftp,snmp,smtp,텔넷,http
		네트워크관리


표현		네트워크 보안(암/복호화)					ASCII, Mpeg, jpg
		압축/압축해제. 포맷 변환 수행

세션		소켓프로그램, 동기화						전송모드 결정(반이중,전이중)NFS, SQL, RPC
		동기화
		세션연결/관리/종료

전송		데이터 전송보장, 				세그먼트		tcp,udp,ssl
		흐름 제어
		quality of services(qos)


네트워크		통신경로 설정, 중계기능 담당			패킷		ip, icmp,igmp, rip, ospf
		라우팅, 혼잡제어
		데이터그램, 가상회선 방식
		ipv4, ipv6

데이터 링크		오류제어, frame화,				프레임		arp,rarp, ppp,slip
		매체제어(Mac)
		에러검출, 에러정정, 흐름제어

물리		물리적 연결설정, 해제				비트스트림		기계적 전기적, 절차적 규격
		전송방식, 전송매체


포맷등 표현, 인코딩 방식등을 관리하는 계층 

 02 tcp/ip 4계층 - tcp/ip 개요

 -개요
미국방연구계획국 알파넷, 1973 티씨피 개발을 했고 어쩌고저쩌고 진화햇다. 현재는 대부분 tcp/ip로 통신을 하고 있음. 이전에 배웠떤 osi랑 비슷한 층계로 나뉨.

 -tcp/ip 계층구조 및 계층관계
여러가지 프로토콜 조합을 의미하나 tcp ip가 가장 많이 사용돼서 이름지어짐.

데이터링크(네트워크 인터페이스층), 네트워크(인터넷층), 전송(호스트투 호스트 전송층), 응용층 으로 구성된다.

(물리,데링),(네트워크),(전송),(어,프,세) 너무 잘게 쪼개졋던거에서 지해롭게 사용할수잇도록 나눈거라고 이해하삼

		-tcp/ip 프로토콜 계층 구조

osi랑 유사해서 복습하는 것처럼 느껴질 수 잇음.
			-데이터링크 계층(network interface) 데이터링크계층과 물리계층
데이터 송수신하는 역할.

			-네트워크 계층(인터넷)
논리적 주소관리, 라우팅.
Ip: 호스트들과 네트워크에서 주소를 관리, 패킷을 라우팅
arp(address resolution protocol)
2계층간 통신에서는 아이피를 사용하지 않는다. 피지컬 주소를 사용하는데 이걸 맥어드레스라한다. 이 피지컬 레이어를 사용해 통신하기 때문에 반드시 2계층에 대한 정보가 필요하다. 즉 ip주소는 아는데 물리주소를 모른다, ㄱ때 사용되는 프로토콜임.
와 icmp(internet control message protocol) 패킷 전송에 관한 메시지 처리임.
ip 주소는 신뢰성이 없음. (연결이 됏는지 안됏는지 확인을 안함) ip는 그냥 보내면 끝임. 돌려받는 통신이 없음. 잘 보내졌나 확인할 길이 없음 . 그래서 icmp라는 추가적 기능을 수행하도록 만듬. 터미널에 핑을 쳐봣을때 응답을 받았다는 거는 icmp를 사용하고 있다는 이야기임. 데이터를 보냈을때 돌려받는, 신뢰성있는 연결이됐는지 확인하는
프롵콜

			-전송계층

호스트들간 통신을 제공하고 2개의 프로토콜이 잇음. 서로 어떤 서비스, 포트를 어떻게 연결할걸지 정의하는게 tcp,udp임. 여기서 두가지 소켓이 통신을하는데. 이걸 소켓이라 부름. 소켓은 서비스를 제공하고. 궁극적으로 서비스를 제공하는 곳은 프로세스임.  소켓은 일종의 전화기 같은 역할. 그래서 소켓이 번호를 갖는거임. 그게 바로 포트라고 이야기함.

포트를 만든 이유가 서비스를 제공하기 위함임. 그래서 걍 혼용해서 나는 쓰는중.소켓을 만드는 프로세스는 여러개의 소켓을 만들 수 잇음. 이 소켓이라는 얘가 tcp와 udp를 사용함. 각각의 특징이 잇음. 그 특징, 환경에 맞게 사용하고 잇음.

 				-tcp(Transmission Control Protocol)
연결지향 일반적으로 데이터의 확실한 전송을 위해 수신측에 확인 메시지를 요구. 방금 icmp랑 비슷함. 패킷 손실은 빈번히 발생하는 일임. 만약 카톡 이미지 전송할때 이미지 날아간채로 보내고 받냐? 아님. 계속 다시 받기 위해 왔따리 갓다리함. 진짜 인터넷 끊기면 전송실패라고 뜨긴하는데 그렇지 안자나? 어쩃든 신뢰성이 높다
zip파일 같이 조금만 손상돼도 열어볼수없는 그런 파일을 첨부할떄 주로 사용

				-udp(user data protocol)
비 연결 지향.
		
실시간으로 패킷 전송하여 빠르나 정확한 전달을 보장하진 않음. 라이브 방송 같이 실시간이 중요한 애들은 udp를 사용함. 받다가 일부분이 누락되고 지지직거리고 망가진걸 받아도 걍 무시하고 바로 다음 것 받는거임. 정확하진 않으나 실시간이기 떔에 사용하는검

			-응용계층
어플이 네트워크에 접근 가능하도록 한다. 웹브라우저 같은 것들이 네트워크에 접근할수잇도록 구성햇다 이런 의미

 -포트주소의 의미와 할당 원칙
	-포트의 개요
포트 번호는 인터넷이나 다른 네트워크 메시지가 서버에 도착했을때 전달 돼야할 특정 프로세스를 인식하기 위한 방법. 근데 엄밀히 말하면 특정 프로세스는 아니고 특정 프로세스가 갖고 있는 소켓을 인식하기 위한 방법임.
tcpㅗ아 udp에서 포트번호는 단위메시지에 추가되는 헤더 내에 넣어지는 16비트 정수의 형태를 가짐.
포트번호는 16비트로 이루어져 잇음. 이이야기는 2^16단위로 만들어진다는거고 0부터 65535까지 65536개의 포트를 구분할수 잇다는 뜻.

	-포트번호와 소켓
통신을 위해 tcp헤더에 송신자 포트와 수신자 포트 정보를 삽입해 패킷 생성. 패킷을 서버로 전달해 프로세스와 연결되어 서비스 이용가능
포트번호는 15비트이며 0에서 65535번까지 있다. 0~1023까지는 웰노운 포트라고해서 가능하면 임의로 쓰지 않음. 응용프로그램 개발자가 사용할수없는 영역으로 정의 하고 잇음. 

		-주요 포트번호 (1-1023): root의 권한이 필요한 포트
ftp(data) 20
ftp(control) 21
SSH 22
Telnet 23
SMTP 25 메일프로토콜
DNS(TCP/UDP) 53
BOOTP 67/68
TFTP-UDP 69
Finger 79
HTTP 80
POP3 110 메일쪽
IMAP 143
SNMP-UDP 161 심플 네트워크 매니지 프로토콜 네트워크 관련 애들 
SNMP(Trap)-UDP 162
BGP-TCP 179
IMAP3 220
SSL/TLS 443 보안(https)
IKE-UDP(vpn구성시사용) 500
루트의 권한이 잇어야만 열수 잇음 유닉스쪽에서는 

 -ip

네트워크 계층에 속한 전송경로의 확립이나 네트워크 주소나 호스트 주소의 정의에 의한 네트워크ㄴ를 논리적 관리한다.
모든 tcp/udp, icmp,igmp 아이피 위쪽에 존재하는 애들. 이런 애들은 ip 데이터 그램을 사용하여 전송한다.

비신뢰성 - 일단 보내는 놓는데 도착하든 말든 신경 안쓴다. 최선의 서비스(udp랑 비슷) 신뢰성 요구는 tcp와 같은상위 계층에서 제공 
비접속형 - 통신하는 호스트 사이에 연결설정 없이 패킷을 전송, (물리적 연결을 만들지 않고 논리적 연결만 만든다) 연결을 보장하는 것은 tcp다.ip는 연결과 관련딘 어떤 상태 정보도 유지하지 않는다. (논리적인 연결을 만들어주지만 그 연결을 유지하는 거는 tcp가 한다.)
주소지정 - ip에서는 네트워크 내 노드를 고유하게 지정하기 위한 수단으로 ip주소 사용. 패킷은 ip주소를 기반으로 목적지까지 전달.
경로설정 - 라우팅 기법. 라우팅 알고리즘 최적알고리즘.

 -ipv4 패킷 구성

데이터 필드에는 tcp,udp와 같은 상위 계층에서 전달 된 pdu(protocol data unit)ld 삽입되며 헤더필드에는 목적지까지 전송하기 위해 ip계층에서 필요한 값들이 포함. 헤더 크기는 옵션이 있으면 더 커지지만 없으면 20바이트 
빅엔디언을 기본으로하며 이를 네트워크 바이트 순서라고 한다. 빅엔디안 이란 것은 바이트를 앞에서 일겠다 이런 소리임. 리틀엔디안 도 있는데 이거는 뒤부터 읽음. 리틀엔디언은 인텔계열. 윈도우에서 많이 쓰는 방식. 빅엔디언은 네트워크에서 많이 사용한다.

	-헤더포맷
전반부 후반부 해서 16비트 씩 총 4바이트 이런 형식으로 5개줄있어서 20바이트. 살펴볼 것은 TTL(time to live) , Flag, fragment offset header checksum, protocol, source/destination IP

Flag는 단편화. 프래그먼트 오프셋에 관한 단편화된 정보를 가지고 있다. 단편화란 MPU란게 있는데 대량의 데이터를 보낼때 쪼개서 패킷화 해서 보낸다. 이걸 단편화라함. 그 단편화에대한 정보를 집어넣는거임. 그래서 플래그와 Fragment Offset을 통해서 나중에 데이터 따로보낼떄 재조립함

Time to Live(TTL) 라우터가 있으면은 라우터를 한번 건너 뛸때마다 time to live가 감소가 됨. 하나씩 건널때마다 64,63,62 이런식으루. 0이되면 사라짐. 왜냐하면 이안에 도착하지 않는다는건 기보적으로 멀리 떨어져잇거나 정확한 주소를 못찾는다는 이야기임. 왠만하면 15번안에 도착하는데 못하면 문제가 있따~ 운영체제마다 다름.
전송 안되는데 계속 돌아다니면 안되니까 ttl 0 도달시 라우터에서 삭제함. 
Protocol은 tcp에 있는 프로토콜을 이야기하는건데, 이 프로토콜은 tcp 쪽에있는 프로토콜에 대한 선견지명같은거? 실질적으로 필요는 없는데 tcp/ip 쪽에서 어떤 tcp, 어떤 포트, 어떤 프로토콜을 쓰는지 미리 알려주는 곳. 
Header checksum은 헤더에 대한 전체적인 오류 검출 기능. 합이 어떤 데이터를 알고리즘 만들어 체크섬을 계산해놓은다음에 비교해서 오류가 없는지 확인함. 그다음 목적 주소, 데이타

	-필드의 의미
식별자 (identification) 호스트가 보낸 각 데이터 그램을 유일하게 식별하는 것.
단편화 옵셋좀 더 보자. 단편화 조각들을 하나 데이터 그램으로 합할때 쓰는 오프셋 표시. 단편화 옵셋 필드는 13비트로 구성되며 전체 데이터에서 분할된 패킷의 상대적인 위치를 8바이트로 기술. 그래서 150이라고 써져잇으면 나중에 모아가지고 합쳐서 150x8 1200자리에 위치. 나중에 모아갖고 각각의 위치에 맞게 세팅한다.
단편화된건 같은 id를 가지고 잇음.

 -ip주소 관리 기법

	ipv4
	모든 네트워크 장비들은 고유 주소 가짐. 이게 아이피 주소
	32비트 주소를 1바이트로 나눠 10진수로 표시하는 도티드 데시멀 표현방식
ip주소는 네트워크 식별자 (netid)필드와 호스트 식별자(hostid)필드 두부분으로 구성되며 각 필드에 사용되는 비트 수에 따라 5개 클래스로 나눈다. 

넷 아이디와 호스트 아이디가 존재하는데, 바이너리가 32개 적혀잇겟지. 앞파트를 넷아이디(망아이디)라고 하고 뒤를 호스트 아이디라 함. 그래서 라우터가 막 연결 돼 잇다하면 그 연결 라인 하나가 망임. 그망안에서 호스트가 여러개 잇다면 그 특정 호스트를 찾는거가 호스트아디

클래스 ip주소를 5가지로 분류하는데 클래스 a는 넷 아디가 짧고 c로 갈수록 길어짐. d,e는 멀티캐스트, 실험용이라고 해서 다른거임 이래서 우리가 주로 쓰는건 클a~c 근데 클래스끼리 중복이 안되냐? 안됨. 클 a는 첫비트 0으로 시작 b는 10으로 시작 c는 110으로 시작 클d는 1110 클 e는 1111 그러니까 서로 겹칠일 없음 ㅋㅋ
클래스 a 는 넷아디비트 8개 고정비트 빼면 2의 24승개의 호스트 비트 만들 수 잇음. 근데 호스트수는 2^24 -2임. 호스트 아이디자체가 1부터 시작함. 글고 다 1비트로 채워진거는 브로드캐스트로 따로 뺴놈.  7개 b는 14개 c는 21개

가장 많은 호스트를 가지는 클 a는 호스트 기관에 할당. 가장 적은 호스트디를 가지는 c는 작은 규모네트워크에 할당.
클d는 멀티캣용 클e는 추후 사용위해 예약된 주소

		-패킷의 전송방법
유니캐스트 - 하나의 송신자가 하나의 수신자에 패킷 보내는 방식.
멀티캐스트 - 일대다 패킷전송방식. 멀티캐스트 그룹에 가입을 시키고 특정다수에게 전송하는 방식.
브로드 캐스트 - 같은 네트워크에 있는 모든 호스트들에 패킷을 보내는 방식. 불특정 다수인에 전송.

		-ipv4주소 관리방식
			-서브네팅
방금 말햇듯 클래스로나는 방법이 있고 또 서브네팅이라는 방법도 있다.   
ip주소에서 어느 비트가 네트워크이고 어디 비트가 호스트 인지 표현. 이진수로 전부 1인 부분은 네트워크 전부 0인 부분은 호스트를 나타냄.
			-슈퍼네팅(supernetting)
인터넷의 폭발적성장 으로 다음문제 대두
- class a와 b의 주소공간 고갈. 굉장히 많은 호스트를 할당할 수 잇는 큰공간인데 고갈대기 시작함.
- 클래스 c주소 할다으로 인터넷 라우팅 테이블 규모 증대. 네트워크 비트량이 많으니까 걍 네트워크id량이 커지고 라우팅 테이블 규모도 커짐.
- 32비트 ipv4 주소의 궁극적 고갈 2^32 40억개 밖에 안댐. 요즘은 인구도 많고 자동차 같은 것도 잇음.
이 해결책으로 IETF는 슈퍼네팅, cidr(Classless Inter-Domain Routing) 개념 도입
슈퍼네팅은 부족한 ip를 효율적으로 사용하기 위해 여러 개의 c클래스 주소를 묶어 하나의 네트워크로 구성하는 방식.
라우팅 주소가 너무 많으니까 묶어서 한꺼번에 관리하자는 솔임. c클래스 주소를 묶는건 기존 방식으론 안되기 떄문에 슈퍼네팅이라는 제도를 도입했다 라고 보면됨.

			-CIDR(Classes InterDomain Routing)
부족한 ip주소를 해결하기 위해 새로운 주소 지정시스템 생성. ip주소와 서브넷 마스크를 이진으로 표현하여 기존의 네트워크를 다양하고 세부적으로 분할.기존 방법보다 더 효율적으로 아이피 주소 지정.

- 표기법

Cidr 표기법에서는 비트 마스크를 사용해 점으로 구분된 10진 표기법을 지정. 1바이트 . 1바이트. 1바이트.1바이트/n(prefixlength) 프리픽스랭쓰는 앞쪽에 몇바이트를 네트워크 아이디로 지정했냐이 뜻임 씨클 입장에서 보면 24비트가 네트워크 아이디임. 
그래서 네트워크아이디 프리픽스랭스 24로 표시댐. 192.169.0.1/24 24개비트의 네트워크 아디를 가진주소다. 비트마스크를 사용 점으로 구분된 10진 표기법 지정. 이후 프리픽스랭스붙임

비트마스크는 ip주소에서 이진으로 표시된 서브넷 마스크에서 연속된 1의 수가 몇개인지를 지정. 연속된 1은 서브넷 마스크의 맨 왼쪽부터 시작.
cidr표기법의 ip주소는 ip주소에서 네트워크 id를 구성하고 /x로 비트수 표현

CIDR의 장점
ipv4의 주소 공간을 효율적으로 할당. 클 비랑 클 씨랑 네트워크 수가 8비트 차나 나는데 프리픽스 랭스 사용하면 20정도로 적절히 조절가능
라우팅테이블 비대화 줄임. 192.168.0.1/24 192.168.100.1/24  둘은 아디가 다르기 떔에 다르게 관리해야댐. 192.168.0.1/16 근데 일케 하면  저 두개 를 묶어서 패킷이 들어와도 여기로 보내갰다는 솔.
아이피 브이포 한곅ㄱ복가능

			-vlsm(variable length subnet mask)
cidr이나 슈퍼네팅과는 약간 결 다름. 씨클은 설명햇듯 2의 팔승-2 개의 호스트를 만들 수잇삼 근데 여기서 100개, 25개씩만 할당한다하면 공간이 남잖아. 그래서 씨클도 더 잘게 쪼갤수 잇음. 서로 다른 크기의 서브넷 지원.
하나의 씨클에서 100개와 25개를 나란히 쓸수잇도록  원래는 씨클을 두개로 나눌 수 없었는데 이번엔 100개랑 25개짜리 두개로 나눠 보자는거. cidr같이 ip주소 공간의 일부를 잘라 사용한다는 건 같고 vlsm은 한 기관에 이미 할당된 주소공간을 나눔. 같은 네트워크 주소 공간이지만 254개의 공간을 100개 25개 이런식으로 나눠 관리함으로서 각각의 다른 랜을 구성할 수 잇는 형태가 댐. 프리픽스랭스등을 사용해 계속 쪼개고 나눠서 할당함. 씨클에서 100개 할당시키려면 프리픽스를 25로 수정하던가 하는 방안 잇겟음.

192.168.0.1/24 -> 192.168.0.1/25 , 192.168.0.128/27 ( 128~159)

			-사설 네트워크를 위한 주소할당
ip부족현상으로 인한 해결책
공인 주소와 사설 주소 사이 호스트와 네트워크 를 접속하기 위해서는 NAT(Network Address Translation)기능 필요

공인 아이피가 뭐냐. isp업체에서 재ㅔ공하는거임. 인터넷 서비스 업체에서 우리한테 할당해주는 아이피임. 세계유일한 아이피. 우리집을 식별할 수 있는 아이피. 근데 이 한계가 잇음. 40억개 밖에 없다는 것. 글고 공인 아이피 인터넷 사용료 비싸게 우리 내고잇잔음
하나의 아이피를 다수의 기기가 사용할 수 있또록, iot에 관련된 기능들을 사용할 수 있또록 공인 ip가 하나로는 부족하다는 이야기. 그래서 ㅈ이걸 쪼개기 위해 사설네트워크 등장 나트라고해서 내부 네트워크에는 가상의 아이피를 제공하는 방식으로 해결. 
실제적으로 패킷이 나갈때는 이런 인터넷 공급자에서 제공한 공인 아이피로 질의를 하게댐. 내부에선 사설 사용. 그래서 우리가 커맨드에서 일반적으로 볼 수잇는 아이피 들은 사설 아이피다. 공인 아이피는 실제적으로 라우터와 접속함. 또는 공유기에 접속해야 알 수 잇음. 

	공인 ip		인터넷에 하나밖에 없는 ip로 유일.
	사설 ip		인터넷 상에서 확인할 수 없으며 내부 네트워크 에서만 활용. 홈랜이나 회사 내부에서 맘대로 할당.

사설주소대는 정해져잇음. 

Class a	24bit	10.0.0.0 - 10.255.255.255
Class b	20bit	170.16.0.0 - 170.31.255.255
Class c	16bit	192.168.0.0 - 192.168.255.255
여긴 공인으로 안쓰임.

			-nat(network address translation)
이런 사설 ip를 할당하는 기술을. 나트라고함.  외부 라이터에서 공인 아이피를 받아왔으면 내부망에서 사설아이피로 배포해야대잖아. 앞에서는 공인아이피로 받아왓다 하더라도 사설아이피 로 바꿔줘야 이단말로 데이터를 전송할 수 있기 떄문에, 주소 변환을 해주는 역할 하고 잇삼. 인터넷 공인 ip주소를 절약하기 위한 방편이고
인터넷이란 공공망과 연결되는 사용자들의 고유한 사설망을 침입자들로부터 보호. 그래서 실제적으로 우리가 공인아이피를 가지고 있다. 그러면은 밖에서 이렇게 바로 공격을 수행할 수가 있는데 만약에 사설 아이피를 가지고 있따면 공격자는 공인아이피 공격을 한다하더라도 실제적인 단말이 아니기 때문에 효과적으로 막을 수 잇음. 근데 이것도 뚫릴 수도 잇긴한데 이건 논외로두고 어쩃든 얘자체는 보호할 수잇다. 국가별 ip주소대는 kisa에 접속해보면 알 수 잇음.

 		-ipv6
			-ipv4의 한계
세계적인 인터넷 보급으로 인해 v4 32bit 43억개 주소로는 한계도달. 이미 모자라서 핸드폰엔 ipv6에 대한 정보들이 드가 잇음. 
			-ipv6 등장
기존 v4의 32비트 주소 길이를 4배 확장한 128비트 주소 길이를 사용. 43억을 4번 곱한거임. 걍 무한에 가 까움. 개인당 1000개의 아이오티 기기를 가질 수 잇는 숫자.
보안문제, 라우팅 효율성문제. qos보장, 무선인터넷 지원 v4는 너무 오래돼서 이런게 안됏엇음 ssl이라던지 이런걸로 해결을 했는데 v6는 나올떄부터 다 해결해나온 새로운 아이피프로토콜!!!
현재는 이동전화나 가전제품 등에 v6주소 도입 v4와도 어느정도 호환 되기 때문에 같이 쓰고 잇는 과도기 상태.

		구분				v4				v6

		주소길이				32비트				128비트
		포시방법				8비트 4부분 10진수 표시		16비트 8부분 16진수로 표시
		주소개수				약 43억개				2^128개(약 43^4)
		주소할당 방식			abcde등 클래스단위 비순차할당		네트워크 규모, 단말기 수 따라 순차할당
		프로드캐스트 주소			있음				없음 (대신 로컬 범위 내에서의 모든 노드에 대한 멀티캐스트를 사용할 수 잇도록 멀티캐스트 주소 제공)
		헤더 크기				가변				고정
		Qos 제공				미흡				제공
		보안				IPSec 프로토콜 별도 설치		IPSec 자체 지원
		서비스 품질				제한적 품질보장(type of service	확장된 품질보장(트래픽 클래스, 플로우 레이블에 의한 서비스 품질지원)
						에 의한 서비스 품질 일부지원)		
		plug and play			불가(DHCP 이용 가능)			가능

v4는 기본 기능이 없어 보충해주는 프로토콜 이용하는데 v6는 기본지원. v6는 나중에 차근차근 더 공부 해보삼


	5 TCP(Transmission Control Protocol)
Tcp/ip에서 많이 사용되고 있다.

접속형(connection-oriented)		데이터 교환 전 tcp연결 설정

신뢰성(reliability)		수신 확인(ack)를 활용해 신뢰성 있는 통신 수행
				주어진 시간 안에 확인 응답 도착 않으면 ack재전송

흐름제어(flow control)		tcp접속 종단에 일정 크기의 버포 공간을 가짐
				버퍼의 크기만큼 데이터를 보내도록 제어
				처리속도가 느린 수신 측 호스트의 버퍼 크기에 맞춰 전송

혼잡 제어(congestion Control)	네트워크 패킷이 과도하게 많을 경우 혼잡 현상을 방지/제거하기 위한 기능
				tcp에서는 혼잡을 피하기 위한 방법으로 slow-start 알고리즘 사용

바이트 스트림 통신(byte-stream commu~)데이터 의미에 상관없이 데이터 나눠 전송.

데이터 교환 이전 tcp연결 설정을하는데(핸드셰이크라함) 핸드 셰이크를 통해서 접속된 상태를 유지 시킴. ip는 접속 유지가 없지만 티씨피는 잇삼.
신뢰성은 아이피는 신뢰성 없다 말햇는데 얘는 ack메시지를 통해서 계속 누락된 메시지를 찾음. 확인 응답이 도착하지 않으면 다시 재전송
흐름제어 tcp 접속 종단에 일정 크기의 버퍼공간가짐.ㄹㅍ

혼잡제어는 네트워크 패킷이 과도하게 많을 경우에 이런 혼잡을 인식하고 방지하고 제거하기 위한 기능
slow-start algorithm

가장 중요한건 접속형과 신뢰성.

소스포트와 데스티네이션 포트. 어디에서 오고 어디로가는지 서비스에 대한 정보. 소켓에 대한 정보가 있다.
시퀀스 넘버 통해 몇번인지 확인 할 수 있고, 애크놀리지 넘버를 통해 몇번째 애크인지 확인가능.
시크와 애크를 통해 접속 유지. 

윈도 사이즈여깄고 , 플래그 체크섬.오류확인코드 어전트 포인터는 나중에확인
포트번호 소스, 데스티 네이션의 포트번호.
순서번호 시퀀스넘버 사용 데이터 스트림의 바이트 구분 위해 사용되는 순서 번호.
확인응답번호 스퀀스 넘버를 받게 되면 애크라고 데이터를 보내줌. 그 숫자, 그넘버가 시퀀스 넘버에 바이트 순서 번호라고 보면 됨.
헤더길이가 명시 됐고 
6개의 플래그 비트가 있는데 세그먼트 흐름 용도를 제어하기 위한 필드. syn ack.
윈도 크기는 흐름제어. 윈도우가 넘 많이 차있으면 어느정도 빈공간을 알려주는 역할. (빈공간만의 데이터만 보내라고 체크해주는것)
체크썸은 티씨피 헤더와 티씨피 데이터에 대한 체크섬을 수행.
긴급 포인터는 송신측에서 데이터를 긴급히 보내는 데이터다라고 표시해줌

6개의 플래그 비트.

urg	긴급포인터 있음
ack	확인 응답번호가 기술 돼 잇음.
psh	데이터를 가능한 빨리 응용계층으로 보내야 함.
rst	연결 재설정
syn	연결 초기화를 위해 순서번호 동기화
fin	송신측이 데이터 전송을 종료.

각각 용도가 정해져잇는거라 자주 볼텐데 비트보다는 플래그 단위로 자주 보게될것임.

연결방식

	-연결 설정
		능동적 열림
클라이언트는 서버가 열어 놓은 포트로 티씨피 연결 요청
보통 처음에 씬을 보내는 쪽.
		수동적 열림
보통 서버는 네트워크 응용을 수행하기 위해 정해진 포트를 열고 클라이언트 요청을 기다림
씬 메시지를 수신하는 쪽

삼방 핸셲 통해 티씨피 연결.

	-연결종료
4way handshake 통해 연결 종료

티씨피 통신은 클라와 서버간 이어져잇다 보면댐

	-handshake
Three way handshake는 서버가 먼저 수행하기 전에 소켓 열고 기달려야함. 

클라이언트는 SYN과 Seq x를 보냄.
서버에서는 SYN패킷을 받고 SYN패킷과 ACK 패킷을 같이 보내게 됨.여기서 보내는 seq num는 x가 아닌 y.
ack에는 +1을 넣어서 ack 했다. 라는 의미로 돌려주게 됨.
syn이랑 ack 받으면 ack에 y + 1 함. 

세번 과정 거쳐 동기화했다고 해서 three way handshake라고도 함.

		-4way handshake
역시 타임순으로 진행이 됨. 호스트 에이와 호스트 비가 존재. 클라이언트에서 보통 종료를 요청함. 보통 클라이언트 쪽에서 삔,  시퀀스 엑스를 보냄 씬은 연결을 초기화하기 위해 보내는 번호로 같이 넘버와 
함께 전송이 되는데, 핀패킷은 바로 핀만 보내게 됨. 원래 시퀀스 넘버에서 원래 있던 거에서 원래 있떤 거로 보냄. 원래 있던 핀 패킷으 보내게 되고 엑스 플러스 1을 통해서
애크를 보내게 된다. 핀애크를 보내긴 보내는데 나중에 보냄. 서버가 클라이언트 쪽에 종료를 받았다고 하더라도. 바로 종료하는게 아니라 어느정도 데이터가 남았다면 바로 데이터
들을 어느정도 처리하고서, FIN ACK를 처리하게 됨. 즉 FYN을 에이가 끝내고 싶다보내면 오케이 기다려봐 . 기다리다가 조아 다 정리가 된 것 같아. 이제 정리해도 좋아라고 응답 한번 더함.
그럼 리시브 핀 애크를 받게되고. 그래 종료하자 하고 에크 플1 이때 번호는 x와 x + 1, y + 1로 threeway handshake처럼 계속 유지가 됨. timewait이 발생하는데
애크를 보냈잖아 보낸 뒤에 리시브 애크를 받고 끝남. 정확하게 다 받고 끝났는지 확인할 길이 없어서 계속 타임 wait함. 혹시나 애크를 받고 끝내는게 아니라 문제가 생겼으면
재응답이 있을테니까 기다리는 거임. 타임 웨잇. 쓰리웨이는 접속 설정.  포웨이는 접속 끝내기. 
지금까지 씬 애크 삔 세개 패킷 살펴봄.

		-UDP(user datagram protocol)
-비연결형	 				ip의 특징을 그대로 물려 받음. 연결설정을 위한 지연 시간이 없고 dns같은 간단한 질의 응답은 udp로 처리하고 있다. 연결설정이 안필요한ㄷ 단발성 서비스에  효과적.
-비상태정보	 연결 				정보나 상태정보를 저장하지 않음. 따라서 빠름
-경량의 오버헤드 				tcp가 20비트였던 것에 반해 udp는 8바이트의 세그먼트 헤더크기를 가지고 있음.
-비정규적 송신률.(un regulated send rate)	일부 패킷의 손실이 생기더라도 지속적인. 최소 전송률을 욕하는 실시간 영상 서비스의 경우 udp를 사용.
-최선의 서비스.(best effort)			서비스의 지연 없이 최선의 서비스 제공. 어떻게든 가능한한 더 많이 하려함.

tcp는 여기 적합하지 않고, 이런 것들은 udp를 사용한다는 것. 

포트넘버와 같이 검사합의 구성으로 간단히 이루어져있으며 8바이트 헤더 길이 가짐. 경량화 돼 있는 모습 소스포트 목적지포트 패킷길이 체크섬.

tcp와 udp의 차이점. 

서비스				tcp					udp
신뢰성				패킷이 목적지까지 도달했는지 확인			ack를 사용하지 않음
				패킷이 도달할 때마다 ack를 수신			패킷이 그들의 목적지에 도달되는 것을 보장하지 않음
				신뢰성 있는 프로토콜				신뢰성 없는 프로토콜

연결				연결 지향적					비연겨 지향적
				핸드쉐이킹 과정 수행

패킷순서				패킷내 순서번호사용				x

혼잡제어				o					x

용도				신뢰성 있는 전송				스트리밍 비디오와 브로드 캐스트 등 실시간 전송

속도와 오버헤드			상당한 양의 자원을 사용하며 udp	보다 느림.		더 적은 자원을 사용하고 tcp 보다 빠름.

서비스는 tcp와 udp를 구분해서 소켓을 만든다. 이 소켓, 포트는 tcp는 신뢰성이 굉장히 높다. udp는 보장하지 않고 신뢰성 없는 프로토콜

				-TCP/IP프로토콜 분석 실습
이제까지 이론을 배웠는데 이 이론이 실제로 동작하고 있는지를 확인해보자. 그래서 와이어 샤크를 통해서 분석 시작하겟다.

사실상 대부분 네트워크 관련수업을 보면 네트워크 패킷을 확인하지 않음. 그래서 이번엔 내가 그게 정확하게 동작하고 일치하는지 확인하는 간단한 시간 가지도록함.
앞서 와이어 샤크를 설치해야하는데 와이어 샤크는 네트워크 패킷을 분석할 수 있는 도구임. 오픈소스고 무료니까 윈도우 사용하고 있다면 와이어샤크 서버에 접속해서 다운로드 눌러주고 환경에 맞는 걸 설치해진행하면 되겠다.

설치한뒤 왼쪽 위에 파랑색 상어갈기 눌러보면 패킷 캡처링 시작이라고 툴팁 뜸. 이걸 누르면 무차별적으로 모든 패킷들을 다 확인함. 그래서 이 피시에서 돌아가는 모든 패킷들있죠. 여러분들이 웹브라우저에서 네트워크 요청을한다면, 네트워크 요청까지 다 와이어 샤크가 캡쳐해서 확인하게 됨.

그래서 캡처를 시작하고 인터넷 브라우저 열어주삼. 저는 여기서 네이버 닷컴 접속하겟삼. 

3. 프로토콜 분석

이전 까지 배웠던 프로토콜들은 tcp ip layer 의 3계층 까지만 봤었음. 이제 본격적으로 분석할 내용들은 어플리케이션단에서 발생하는 프로토콜임. 이제 네트워크 기초에서 심화단계로 넘어간다고 보면됨.
이제 응용계층 프로토콜은 기본 위에 쓰여지는 프로토콜임. 프록시가 켜져 있는 상태인 것 같은데 프록시 내려봄. 난 프록시땜에 안댓는데 끄니까 다시댐.
접속햇으면 다시 캡쳐링 꺼주삼.

인터넷프로토콜을 봐보자
유닉스환경에서는 ttl 64로 설정 돼 잇삼. 다음으로 tcp 프로토콜은 6번임. 헤더체크섬은 이렇다. 소스 아이피와 데스티네이션 아이피는 이렇게 적혀있다. 그래서 이런식으로 데이터를 잘 확인할 수 있는 그런거다.

다음으론 이더넷을 봐보자. 데스티네이션도 써져있고 쏘스도 써져잇다. 여기는 맥어드레스임. 그래서 전에 배웠다 싶이 두개의 계층으로 나눠져 있기 떄문에 프레임도 감춰진 내용을 봐야될 것 같죠.
그래서 여기는 프레임 넘버나 렝스 같은게들어가 있구요, 그리고 물리적 주소는 여기쪽에 들어가 있음. 물리적 주소는 이쪽에 써있다 싶이 쏘쓰가 이렇게 써져있고, 데스티네이션은 이렇게 써 있음. 
이 데스티네이션은 물리적인 데이터링크쪽 계층이 두개가 선언이 됐는데 얘는 왜 이렇게 vmware로 나왔냐면 네이버쪽으로 요청을 했지만은, 네이버쪽으로 바로 이 질의가 가는게 아님.

데이터 링크는 2계층간의 통신이기 떄문에, 라우터를 넘어가지 못함. 이라우터가 가상환경에서 실행중이라서, vmware라는 가상의환경의 물리주소를 사용하고 있음 그래서 소스는 유닉스, 리눅스 환경이고, 여기도 vmware가 찍혔고, 이것도 가상 네트워크에 라우터를 가리키고 있기 때문에, vmware가 찍혔음. 네이버가 vmware가 아니고, 2계층 통신이기때문에 vmware라고 찍힌다. 라고 보셈

그다음에 프레임에 또 뭐 특별히 볼 데이터는 없음. 그래서 이제 지금까지 우리가 봤던, 4개의 계층을 차근차근 하나 씩 살펴봣음. 프레임, 이더넷은 데이터링크 한계층으로 보면됨. 인터넷 프로토콜은 인터넷, 트랜스미션은 전송으로 보면댐. 그다음 여기 http가 있는데 이건 응용프로그램 계층임.

하이퍼 텍스트 트랜스퍼 프로토콜 겟을 사용해서 쭉쭉나눠져서 데이터를 가져오는걸 확인가능. http가 어떻게 사용되는지는 다음에 배움. 
쩃든 가장 중요한건 프레임 이더넷은 데이터링크. 인터넷 프로토콜은 네트워크레이어, tcp(트랜스미션 컨트롤 프로토콜)는 트랜스포트레이어
하이퍼택스트 트랜스퍼 프로토콜은 어플계층이다. 총 네가지계층으로 이뤄진 헤더를 와이어 샤크 이용해서 보면 훨씬 보기 쉽고, 원랜 이렇게 나감 밑에  사람이 보기 어려운 데이터로 나가는데 일일이 해석하기 어려운걸 와이어 샤크가 가독성있게 꼼꼼히 분석할 수 잇게 해줌. 재밌고 쉬운 분석가능~

네트워크 기초 봤고 실습까지 마무리 ~ 감사



 01 telnet 프로토콜 개요.

인터넷이나 로콜 영역 네트워크 연결에 쓰이는 네트워크 프로토콜이다.
프로토콜의 클라이언트 일부 기능이 추가된 소프트웨어
텔넷 클라이언트는 대부분 유닉스 시스템에서 사용(실질적으로 모든 플랫폼임)
최근에 텔넷의 보안문제 떄문에 사용률 감소하여 원격제어를 위해 ssh로 대체
23번포트 주로사용

telnet은 원격제어 터미널임. 직접 설치는 안하고 마련해둔 텔넷 패킷이 있음. 그걸 가지고 진행할거임
텔넷으로 어딘가에 원격으로 붙으면은 커맨드 창같은게 열림. 이런 창이 열리는데 이창에다 명령하고 싶은 내용을 명령하고 커맨드창처럼 사용할 수잇음. 리눅스 유닉스 맥os다 사용 가능.

이제 바로 텔넷 프로토콜을 분석 해보겠음.

여러분은 윈도에서 파일 열고 실습하면 되는데 나는 칼리 리눅스에서 진행중 윈도우에서도 할수잇는데 내가 컬럼같은거 설정해놔서 초기화된 버전으로 알려드릴라 리눅스에서 함. 컬럼 바꾸는 내용은 나중에 다룸. 

텔넷만 보고 싶으면 위에 telnet만 플터링 할 수잇음. 내용을 보면 어플단에 데이터를 보내고 있는걸 볼 수 잇음. 근데 펼쳐보면 대체 뭐하는건지 데이터가 보이지가 않음.
뭐 에코한다고 적혀잇거나 커맨드 윈도사이즈 이런게 젹혀잇는데 뭔 얘긴지 몰겟음 아무리 내려도 점점점 밖에 없음. 도대체 어떻게 분석해야댈까. 마우스 오른쪽을 눌러보삼. 빨로우를 가시면 tcp stream할 수 잇음. Tcp 스트림 하면 여기서는 확인 하지 못했던 정보들을 확인할 수 잇음.
앞은 뭐라는지 모르는 내용이고 좀 내려가다보면 칼리라는게 나옴. 칼리쪽에서 루트로 접속을 했는데, 접속을 할때 어떤 데이터를 가지고 접속을 했섭니다 그래서 칼리를 가지고 마이크로 소프트에 잇는 텔넷 서비스에 접속을 한거. 빨간색이 클라이언트임. 파란색이 서버임.  클라는 자신이 칼리라고 소개하고 서버는 자신이 마소 텔넷서비스 라고 소개함. 그니까 서로 일종의 프로토콜인거임 서로 인사하는거. 그다음 로그인 창을 띄워줬더니 클라이언트가 a라고 보냄. 서버도 똑같이 보냄. 그래서 administar 문자를 하나씩 타자 칠때마다 에코현상이라는게 일어남. 메아리처럼 데이터를 주고받는거죠. 이 현상이 일어나는데 이게 텔넷의 특징임. 패스워드같은 경우는 한번에 전송된걸 볼 수 잇음. 아이디는 글자하나하나 데이터가 넘어가더니 패스워드 칠떄는 한방에 넘어갔구나.

그 다음에 마소 텔넷 서버 넘어가고 커맨드 창으로 넘어감. 노트 패드닷 exe이렇게 실행을 했는데, 노트패드가 실제로 실행됏겟지 안보이지만. 
글고 먼가 p를 보냈는데 데이터가 제대로 안나옴. 글고 dor이라 쳣더니 dor이란 데이터도 먼가 제대로 안나옴. 그래서 여기서 잘못된 명령어를 내린거임. 이렇게 분석 가능. 
뭐 중요한게 아니라 사실 걍 내가 실수한거임. P 실수로 걍 눌러버리고 dir쳐야되는데 dor눌러버리고. 알아볼 수 없는 데이터가 들어갔는데, 결국엔 dir 성공 적으로 치게 되면 dir이 exe겉리 세부내용 출력하는 명령어임. dir도 보면 하나씩 에코현상 일어나는거 볼 수잇음. 글고 다치니까 이렇게 대이터가 나오게 댐. 그다음 cl이라고 쳤고 그리고 clc.exe 계산기를 실행했죠 그다음 cd qk라고 했는데, 잘못된 내용임. 뭐 이런 일련의 과정이 있음. 그래서 그냥 이정도만 이해하고 텔넷이 이렇게 진행된다 이해하면 댐. 텔넷서비스는 주로 많이 사용하진 않지만, 가끔 사용하는 경우가 있음. 워밍업으로 텔넷은 이렇게 통신하는구나 하고 보여준거임. 세부적 내용은 사실상 이렇게, 하나씩 하나씩 봐야 하겟지마는  이렇게 하나하나 보는 것보다 tcp스트림을 사용하면 더 빠르게 정보를 파악할 수 잇기떄문에 이런 것들은 다른 프롵토콜을 분석할때에도 많이 사용하니까 잘 익혀두길 바란다. 

 02 ftp프로토콜 개요

파일 전송 프로토콜의 약자

Tcp/ip 프로토콜을 가지고 서버와 클라이언트 사이 파일을 전송하기 위한 프로토콜로 ftp 서버는 아직도 많이 사용되고 잇음 ㅋㅋ 응용계층에 속하며, 역사가 오래되었지만 지금도 인터넷에서 자주 사용
최초의 ftp클라이언트 애플리케이션들은 운영 체제가 그래픽 사용자 인터페이스를 갖추기 이전에 개발된 cui프로그램으로 현재 대부분의 윈도우, 유닉스, 리눅스 운영 체제에 기본 포함

그뒤로 수많은 ftp 클라이언트들이 많이 생겨서 실제적으로 서버가 운영되고 gui로 접속해서 컨트롤하는 경우가 많음. 아직도많이 사용하기 떔에 지금 분석해놓으면 유영함

ftp프로토콜은 두가지 커넥션을 사용하게된다. 21번 포트를 사용하고, 하나는 20번 포트를 사용한다. 데이터 포트는 20번으로 사용하고, 커맨드같은거 위주인 제어 포트는 21번 포트를 사용. 

		-명령/데이터전송 연결
명령 연결 		제어포트 21번 사용. 명령을 위한 연결 생성후 여기를 통해 클라이언트에서 지시하는 명령어 전달해서 클라이언트가 어디 디렉터리를 입력하고 싶다, 어디 파일을 내려받고 싶다 이런 명령어를 전달할떄 주로 사용됨.
데이터 전송용 연결 이건 따로 연결이됨  보면 능동과 수동으로 연결되는데 파일 전송이 필요할떄 새로 연결을 한다 이점을 염두하면 되겠음. 

		-능동/수동(active/passive) 모드

모드			설명
능동 모드			서버가 자신의 데이터 포트인 20번 포트에서부터 클라이언트가 지정한 지점으로 데이터를 연결한다. 그래서 20번 포트가 클라이언트에 붙게 된다 이런 뜻	임.(1023<클라이언트 포트) 
			하지만 클라이언트가 보통 나트가 설정돼 잇고 방화벽이 설정 돼 잇기때문에 거의가 동작 잘하지 않음. 그래서 20번 포트를 주로 사용하기보다는 클라이언트 쪽에서 접속을 할 수 있또록 클라이언트가 서버가 지정한 포트로 연결 할 수 있도록 하고 있다. 그래서 보통 양쪽 포트 모두 1023보다 큰 포트를 사용한다.

		-ftp 프로토콜 분석(실습)
ftp 필터링하삼. ftp말고도 ftp-data 라고 치면, 데이터를 전송하는 데이터에 대해서도 확인 가능하다. ftp를 치면 이게 커맨드임. 커맨드 쪽을 출력을 해주는 거고, ftp-data는 데이터 전송 아까 데이터 전송포트는 따로 열린다고 말햇죠, 그래서 다른 포트들이 존재함.
먼저 ftp분석 해보겠다. ftp보면 오른쪽에 여러가지 데이터가 함께 나오는데 걍 우클릭후 빨로에 티씨피 스트림 보삼.

FTP command list src: www.nsftools.com/tips/RawFTP.htm#list

220 DaFTP Server.. ........ ...........
USER boanproject
331 User name okay, need password.
PASS boanproject
230 User logged in, proceed.
SYST
215 UNIX Type: L8
PORT 192,168,187,131,225,253
200 PORT Command successful.
LIST
125 Opening ASCII mode data connection for /bin/ls.
226 Closing data connection.
TYPE I
200 Type set to I.
PORT 192,168,187,131,232,243
200 PORT Command successful.
RETR Sysmon64.exe
150 File status okay; about to open data connection.
226 Closing data connection.
PORT 192,168,187,131,187,105
200 PORT Command successful.
STOR telnet.pcapng
550 Requested action aborted: local error in processing.
QUIT
221 Goodbye.


첨에 접속햇더니 daftp server를 출력함 여기서 하는 역할은 바로 접속하니까, ftp서버에서 데이터 보낸거임. 나는 ftp서버야 라고. Daftp서버야
그담에 클라이언트쪽에서 보안프로젝트라는 유저이름으로 데이터 요청. 유저이름 좋아. 패스워드 필요
다음 패스워드도 보안 프로젝트 그래서 로그드인이 정상척으로 처리된것을 확인 가능. 
그다음 클라이언트쪽에서 넌 시스템이 뭐니 라고 질문함. 이게 유닉스 계열의 질의인데, 보면, ftp관련한 명령어 들이 다양하게 많이 있음. SYST같은 경우는 시스템 타입이 뭔지 질의하는 얘
그다음 시스템 타입이 유닉스 l8타입으로 돼 있다고 대답해줌. 그다음 포트 열라고 지시를 해주는데, 포트는 포트를 여라는 지시임. 그래서 아까 봤던 사이트를 참고해서, port라고 쳐보면
Open a data 포트라고 적혀있음. 그래서 포트를 열어라. 

syntax: port a1,a2,a3,a4,p1,p2 이 어드레스 여기에서 포트. p1*256+p2 를 열어라 라고 이야기 하고 있고. 포트를 연다는 사실을 알 수 있다. 그래서 서세스풀하게 했고
다음 list는 ls명령어임. 유닉스에서 ls명령어는 디렉토리를 출력하는 애임. 리스트에 대한 정보를 확인해보겠다. 

Syntax: LIST [remote-filespec]
만약 파일에대한 인포메이션에 대한 걸 얻을 수 읻는 질의

그다음엔 또 type i를 리퀘스트 하고 잇어
또 type i에 대해 또 포트를 열게 되고

Sytax: type type-character
Sets the type of file to be transferred. Type-character can be any of:
A - ascii text
E - EBCDIC text
I - image (binary data)
L - local format

그래서 이미지. 바이너리에 대한 요청을 해서 포트를 연거임.
그ㅐㄹㅆ더니 이번엔 sysmon64.exe에 대한 요청을 함 그랬더니, 데이터를 보내주는 모양이 보이고 
그다음에포트 또 열어 피캡파일을 요청했는데 requested action aborted 돼서 로컬 에러 발생함. 
그래서 다운로드가 정상적으로 되지 않은 걸로 확인댐. 
그리고 사용자는 quit해서 로그아웃 했고. 굿바이해서 정상적으로 패킷 종료.

그다음 우리가 확인할게 뭐냐면 여기선 데이터 통신이 안보이니끼 필터링으로 ftp-data해서 봐보겟음. 포트 여는 것들은 여기서 이렇게 확인 가능함.
근데 이건 tcp스트림으로 보면안됨. 왜냐면 tcp 스트림은 연결 시작과 끝까지만 데이터가 나오기 떄문에, 얘는 데이터를 보낼때마다 세션을 생성함. 그래서 세션이 끊겨 보임 그래서 우리가 원하는 데이터를 쭉 이어서 볼수는 없다. 그렇기 때문에 tcp스트림으로 보면 다 짤려보임 그래서 번거러우니까 그렇게 하지마삼.

처음에 데이터에 리스트를 요청했을때 리스트에는 이렇게 데이터가 나옴. Sysmon64.exe라는 파일이 하나가 있는게 확인이됨. 디렉토리를 검사한 결과가 이렇게 나나온 거임.

그다음 시스몬64파일을 요청햇음. 
바이너리를 요청할 건데 포트를 열고 이걸 좀 내려줘라고 요청을 함 그랬더니 데이터를 내려줬는데, 보면은 이 파일의 헤더가 mz로 시작을 함. 이게 exe파일의 매직넘버임.
그래서 얘는 exe파일 이구나를 알 수 있음. 여기서 받은 exe 파일은 sysmon64.exe 달랑 하나 뿐이기때문에 이게 됐구나를 알 수 있고, 
Closing data connection이 종료가된것을 확인할 수가 있음. 정상적으로 데이터가 전송이 된 것임.

귿음 텔넷 피캡을 저장하도록 했는데, requested action aborted 돼서 에러가 나오죠. 여기서 포트는 열었지만 실질적으로 데이터를 전송하지 못한 그런 상황임. 뒤쪽은 데이터 전송이 실패했기 때문에 더 볼 필요가 없음.

	03 arp/icmp 프로토콜 개요
이번시간은 arp와 icmp에 대해 살펴 보겠다. 먼저 arp 에 대해 살펴보겠다. 
		-주소 결정 프로토콜(Address Resolution Protocol, ARP)
네트워크 상에서 ip주소를 물리적 네트워크 주소로 대응(bind)시키기 위해 사용되는 프로토콜. ip주소를 알고 물리 주소를 모를때, 주로 사용함. 밑에 보면 icmp헤더가 나오는데 sender의 하드웨어 어드레스가 48비트로 구성이 돼 있고, 센더 프로토콜 어드레스가 32비트로 구성된걸 확인할 수 있음. 이 두가지 구성이 있는데, 이 두가지 구성은 앞에서 본 ip주소와 물리적 네트워크 주소를 의미함 . Sender protocol address 가 ip주소를 의미하고 sender hảdware address가 물리적 네트워크 주소를 말함. A가 b로 데이터를 보낸다고 가정했을때, 질의가 된다 한다면, sender가 바로 a가 되는 역할이고 b가 target의 역할이 된다. target은 하드웨어 어드레스가 없는 상태, 물리적 네트워크 주소가 없는 상태이기 떄문에, 비워두고. ip주소만 알고 있기 때문에 ip주소를 target protocol address에 넣음. 여기서 알수 있는건. 물리적 주소는 이더넷 또는 토큰링의 48비트 네트워크 카드 주소이다. 없는 데이터는 모두 f로 채워서 브로드캐스트 주소로 세팅해준다. 호스트 a가 호스트 b에 ip패킷을 전송할때. ip호스트 b의 물리적 주소를 모르는 상태 일때, 쓰는게 arp이다. 또는 arp의 종류가 많은데, 가장 기본적인 일반적으로 보는 arp만 살펴보겠다. 

arp프로토콜을 사용(호스트 b주소, 브로드캐스팅 물리주소(FF-FF-FF-FF-FF-FF) ARP 패킷 전송) 호스트 b는 자신의 ip주소가 목적지에 있는 ARP패킷을 수신. 그래서 수신했을때, 자기의 ip 주소와 일치하게 된다면, 맥 어드레스도 같이 넣어서, 같이 샌더에게 보내게 된다. 즉 자신의 물리주소를 a에게 응답함으로서 통신이 끝나게됨.

		-arp table
각 pc를 보면 이런 arp 테이블을 cmd창에서 arp -a 라는 모형으로도 사용해서 테이블을 확인할 수 있음. 

보면 인터넷 어드레스도 한쪾에 저장을 했고 피지컬 어드레스도 한쪾에 저장했고 마지막으로 타입이 나옴. 타입에 스태틱이 돼 있따는 것은, 이미 사전에 정의 된거고, 앞쪽에 있는 다이나믹은 동적이고 변할 수 있다는 뜻이요. 동적이란 것은 arp를 통해 데이터를 받아왔다라고 보는게 정확한 거다. 왜냐면 arp같은 경우는 캐시를 메모리 테이블에 저장 해놓기 때문에 일정 시간이 지나가면 일정 시간이 가게 되면 arp에 대한, 정보를 날리고 새로운 데이터를 받아옴. 그렇기 떄문에, 데이터를 유지하는 기간이 정해져있다. 얘네는 언제든지 동적으로 변할 수 있는 상태다.  그래서 아마 arp를 받아 왔을 가능성이크다 라고 이야기할 수 잇음. 그리고 arp 테이블을 관리함으로써 이전에 보냈던 곳에 다시 패킷을 전송할 필요가 있게되면 패킷을 전송할때 이걸 다시 확인해서 피지컬 어드레스로 다시 보내면 된다. 우리가 여태까지 앞서 봤다 싶이 ip를 통해서만 해서도 데이터를 보낼 수 있게 됐는데 왜 굳이 arp를 통해 받아오냐면 2계층에서 통신할때, 한 네트워크에서 통신을 할때는 물리주소를 가지고 통신을 함. 그래서 a와 b가 통신할떄는 같은 네트워크에 존재를 한다면 인터넷 어드레스인 ip주소를 가지고 통신을 하는 것이 아니라, 피지컬 어드레스를 가지고 통신을 하게됨. 그래서 반드시 이런 물리주소가 필요로하게된다. arp와 반대로 ip호스트가 자신의 물리 주소는 알지만 ip주소를 모르는 경우 서버로부터 ip주소를 요청하기 위해 rarp사용. 이거 말고도 garp나 뭐 존재를 하는데, 그건 여기서 다루지 않고 기본적인 arp만 다룸.

		-icmp
			-icmp의 필요성(Internet Control Message Protocol)

이게 필요한 이유는 ip가 신뢰성이 없기 때문임. Ip는 최선형 전달 서비스만 지원하기 때문에 ip 패킷이 전송되는 목적지에 전달되지 못함. ip패킷이 결과를 반환하지 않음. Pc a가 pc b에 질의 하는데, 중간에 수많은 라우터를 거치게됨. 중간에  질의를 하다보니까 코스트가 하나 죽었음. 그럼 연결이 안될거임. 그럼 안된걸로 끝나는 거임. a가 b로 연결 됐는지 안됏는지 확인 할 방법 이 없음. 글키 땜에 icmp라는 프로토콜을 같이 사용하게 됨. icmp를 사용하게 되면은 destination unreachable이라는 데이터를 반환하게 됨. 주소로 도달할 수가 없었따 이런 메시지를 받아 보내주는데. icmp가 해주는 역할은 패킷이 잘 전송 됐는지 연결 됐는지 확인할때 사용하게 된다. 
전달 되더라도 원하는 서비스 ip가 존재하지 않는 경우에 대해 오류를 보고해야하는 상황이 생김.
오류 보고 기능과 네트워크 상태 진단 기능을 통해 ip 보조 수행. 
icmp는 ip로 캡슐화되며 ip 헤더의 프로토콜 필드값을 1로 설정하여 icmp 메시지임을 나타냄

			-icmp 포맷

				-메시지 타입필드 : 메시지 종류 기술
				-코드 필드 : 메시지 타입에 따라 세분화가 필요할때 사용
				-체크섬 필드 : icmp 메시지에 대해 체크섬을 계산 한 값이 삽입

처음에는 메시지 타입필드. 메시지 타입이 어떤건지 말해주는데, 뒤에가서 나올테니까 거기가서 보고
코드 필드는 메시지 타입에 따라 세분화가 필요할떄 이 code를 사용하게 됨.
체크섬 필드는 icmp 메시지에 대해 체크섬을 계산한 값이 삽입 됨. 그래서 이 뒷부분이 오류검출 코드가 되는거임.
그 다음은 메시지 바디라고 해서 에러 메시지나 캡슐레이션된 아이피 데이터 그램을 삽입할때 사용하게 됨. 

				-icmp 메시지 종류
타입이 사실 5종류 이상있는데 이정도만 살펴봄

Icmp type			메시지 기능

Echo request			원하는 호스트로의 IP 연결을 확인하기 위해 사용되는 간단한 문제 해결 메시지

Echo reply			ICMP Echo Request에 대한 응답 메시지

Redirect				데이터를 보내는 호스트에게 목적 ip 주소에 대한 좀 더 적합한 경로가 있음을 알리기 위해 라우터가 보내는 메시지


Source quench			데이터를 보내는 호스트에게 ip 데이터 그램이 라우터의 집중 현상에 의해 손실되고 있음을 알리기 위해 라우터가 보내는 메시지로 받게 되면
				데이터를 보내는 호스트는 전송률을 낮추게 된다. Source quench는 icmp에서 선택적 메시지 이고 대부분 구현되지 않는다.


Destination Unreachable		라우터나 목적 호스트가 데이터그램이 전달되지 못한다는 사실을 데이터를 보내는 호스트에 알려준다.

데스티네이션 언리쳐블이라는 얘도 많이 보게 된다. 라우터나 목적 호스트가 데이터그램이 전달되지 못헸을 경우에 이것을 다시 호스트에게 알려주는 역할을 함. 중간에 있는 라우터나 목적호스트가 보내주는 패킷이라고 볼수가 있음.

			-ARP/ICMP 프로토콜 분석(실습)
				-arp

Arp나 icmp도 마찬가지로 프로토콜 이름을 필터에 입력해주면 댐. arp는 tcp스트림으로 볼수 없음 왜 냐면 얘는 ip까지 밖에 패킷이 존재하지 않음. 글키 떔에, 4계층에, 4계층이상의 응용단에 프로토콜을 지원하지 않고 트랜스포트도 지원하지 않음. Tcp/ip로 따지문 두개의 계층만 운용되는 형태라고 보면 됨. Ip, 네트워크 레이어 까지만 운용되고 있는 상태이고 여기서 이제 보면, 브로드 캐스트 주소로 어떤 데이터를 보내게 됨. 얘가 질의라고 볼 수 잇음.

이 어드레스 리솔루션 프로토콜을 사용하고 있다고 보여지고, 이더넷의 1번이라고 세팅 되어 있다. 여 vmware 에 대한 데이터는 가지고 있고 센더에 맥어드레스와 아이피 어드레스 다 가지고 잇음. 타겟은 맥어드레스는 비어있고 아이피 어드레스는 채워져 있는 걸 볼 수 있음. 정확히 이야기하면 데스티 네이션 쪽에는 ffffffffㅏㄱ 들어가고, 정작 진짜 arp쪽에는 0으로 채워 넣음. 이거는 인포라고해서 의역한 메시지라고 보면 됨. 누가 131번을 가지고 있냐? 이걸 128번에 말해줘. 이런 뜻임.

그래서 브로드 캐스트로 보냈더니 어떤 데이터가 이거에대한 응답을 하고 있음. 방금은 128이 131에 질의 했는데, 이번엔 131이 128에 질의함. 맥어드레스가 원래 없었는데 채워서 질의하는 모습.

여기에 데스티네이션에도 정확하게 주소를 채워서 브로드캐스트가 아닌 데이터를 넣었음. 그 다음 패킷도 마찬가지로 이번엔 2번이 누구냐 묻고 잇음. 그거에 대한 질의를 2번이 받아서, 처리하고 잇는 것을 볼 수 잇음. arp는 이런 일련의 흐름이다 라고 볼 수 잇음. 이정도로 arp 분석 마치고 바로 icmp ㄱ

				-icmp
icmp를 보면 내가 핑패킷을 보내서, 핑패킷에 대한, 데이터를 받아오고 있다. 그래서 아까 id 000001번이라고 하면은 icmp메시지라는 것을 나타내고 있고, 타입이 8로 설정 돼서 echo request 발생함. 128이 2번에 질의하고 있고, 2번이 질의 받아 reply 처리. ttl(time to live)가 128로 아마 윈도우일 가능성이 크다는 것을 추측할 수가 있음. 64번인 경우에는 유닉스 리눅스 계열임. 보면 요청응답 3번 주고 받았고, 응답 계속 못받음. 이상 arp/icmp분석 끝

	04 http/dns 개요

		-http?
역사가 오래됨. 이전시간에도 몇번 언급을 했었는데, 언급한 http에 대해서, 좀 더 자세하게 이야기하고 넘어가도록 하겟다.
Hyper text transfer protocol) www상에서 정보를 주고 받을 수 있는 프로토콜. 현재는 파일다운로드라거나 pdf를 보여준다거나 여러가지 방면으로 많이 쓰이고 있어서 html에
한정 짓기에는 무리가 있는데, 그래도 주로 html문서를 주고받는데 쓰임. 

역사가 오래된만큼 기능이 다양함. 초창기에는 정적인 페이지를 만들어서 정적인 페이지만 보여줬음. 정적인 페이지는 아무런 동작을 하지 않음. 우리가 뭔가 클릭을 하거나 뭘 할때 하이퍼 링크가 달릴 수는 있어도, 정적인 문서이기때문에 정적인 문서를 클릭하거나, 광고를 보여주거나 이런 경우는 옛날에 없었음. 그런 정적인 문서에 동작을 하지 않는 문서이다. 이런 정적인 문서를 보여주다가, 최근에는 http가 굉장히 대중적이면서도 다양한 기능들이 포함되면서, 동적인 페이지로 많이 변함. 누가 로그인 했냐에 따라서 누구누구님 안녕하세요, 이런 마케팅 전략. 그리고 또 여러가지 움직이는 그런 것들. 플래쉬로 게임도하고, 이런 여러가지 상호동작할 수 있는, 문서작업도하고요. 많은게 추가됨.

http의 자세한 동작원리는 너무 많음. 최근에 이슈되고있는 액티브 x도 거기에 들어감. 여기서는 가장 필요한 기초에대해서만 이야기하겠따

주로 tcp80번 포트 사용. http는 클라이언트와 서버 사이에 이루어지는 요청/응답프로토콜. 클라이언트가 서버에 문서를 요청하고 응답을 받아보는 그런 프로토콜임.

전달되는 자료는 http:로 시작하는 ip주소가 아닌 url(인터넷 주소)로 조회. 클라이언트인 웹브라우저가 http를 통해 서버로부터 웹페이지나 그림 정보를 요청

서버는 그에대한 응답 메시지를 만들어서 다시 클라이언트에 전달.

		-요청 내용에 포함되는 요청 메소드

요청메소드						설명

Get						url에 해당하는 자료의 전송 요청
HEAD						get과 같은 요청이지만 메타정보 만을 받음
POST						서버가 처리할 수 있는 자료 전송
PUT						해당 URL에 자료를 저장
DELETE						해당 URL의 자료를 삭제
TRACE						이전에 요청한 내용을 들을 것을 요청
OPTIONS						서버가 특정 URL에 대해 어떤 HTTP Method를 지원하는 지 확인
Connect						프록시가 사용하는 요청
PATCH						리소스에 대한 부분적 수정을 적용.

사실 현재 http에서 사용되는 메소드는 거의 없음. Get post만 거의 쓰인다고 보면 됨. 옛날에는 프로그래머들이 서버관리 편하게 하기 위해 put delete trace options등등 썼었는데 현재는 지원 안댐. PUT,DELETE같은 경우 해당 페이지의 URL을 임의로 만들거나 삭제할 수 있는 위험한 메소드임. 그리고 현재는 웹을 관리할 수 있는 많은 프로그램이 있기 떄문에 굳이 사용할 필요가 없음.

Get은 바디를 만들 수가 없고 헤더만 가지고 있음. 포스트는 요청을 하긴하는데 일반적 요청이 아니라 바디에 데이터를 담아 보냄. post는 헤더와 body둘다 가지고 있음. 메일등을 보낼때 문서를 웹으로 올리는데, 여러분들 받은 데이터들이 헤더로 전송이 되는게 아니라 용량이 크거나 민감한 정보는 바디에 담아서 전송하게 됨.

		-클라이언트 요청/ 서버응답 예


Header				get/ http/1.1
				Host: www.boanproject.com
				User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:45.0) Gecko/20100101 Firefox/45.0
				Accept: text/html,application/xhtml+xml, application/xml; q=0.9,*/*;q=0.8
				Accept-Langueage:en-US,en;q=0.5
				Connection: close

Body







겟 요청인데, 헤더가 존재하는거고, 겟문장은 앞에서 설명했다 시피 바디가 존재하지 않음. 겟요청은 호스트 주소가 써져있고, 물론 ip는 이미 tcp/ip에서 입력돼 들어감. 이미 3,4,단계를 지나 응용프로그램단이기 때문에 별도의 tcp가 들어가지 않음. 대신 호스트 주소와 유저 에이전트, 현재 유저가 사용하고 있는 브라우저의 정보를 보내게 됨. 여기는 파이어 폭스를 사용했고, 보안프로젝트 닷컴의 최상위 경로를 요청하고 잇음.

		-클라이언트 요청 / 서버응답 예

Header		http/1.1 200 OK
		Server: apache
		Date: Thu, 04 May 2017 13:43:46 GMT
		Content-Type: text/html; charset=euc-kr
		Connection: close
		Cache-Control: no-store, no-cache, must-revalidate
		Cache-Control: post-check=0, pre-check=0
		Pragma: no-cache
		Content-Length: 713

Body		<html>
		<head><title>~~~>/title>		<meta http-equiv="Expires" content="0">
			<meta http-equiv="Last-Modified" content="0">
			<meta http-equiv="Cache-Control" content="no-cache, must-revalidate">
			<meta http-equiv="Pragma" content="no-cache">
			<meta http-equiv="imagetoolbar" content="no">
			<meta http-equiv="Content-Type" content="text/html; charset=euc-kr"></head>
		<frameset rows="0,100" cols="*" border="0">
			frame name-"top" scrolling="no" marginwidth="0" marginheight="0" marginheight="0"
		src="http://cafe/naver.com/boanproject" border=0 frameborder=0>
			<noframes></noframes>
		</frameset>
		</html>

상태 메시지 200번대는 정상적으로 응답했다
	300번대는 웹이 옮겨졌을때 받은 요청
	400번대는 찾을 수 없음
	500번대 	논리적인 흐름이 문제가 생겨서 버그때문일 수도 있고 해킹자가 해킹을 시도했을때발생할수도
서버는 아파치 사용하고 잇음. 데이트와 컨텐츠 타입이 있음. http는 헤더는 반드시 존재하고 바디는 옵션적으로 들어가는데, 옵션적으로 들어갈때 반드시 헤더쪽에다가 content-length를 선언 해줘야 됨. 컨텐트 렝스는 바디의 크기를 명시해주고, 컨텐트 렝스가 있는 바이트수만큼 클라이언트로 요청을 보낼 수가 있게 됨. 바디 안에 html문서가 있고 html문서에도 헤드와 바디가 있음. 이런 여러가지 요청에 대한 응답을 할 수가 있다 라는 것. 자바스크립트는 없고 단순 html로 보임.

	-도메인 네임 시스템(Domain Name System， DNS）
호스트의 도메인 이름을 호스트의 네트워크 주소(IP）로 바꾸거나 또는 그 반대를 수행하기도 함. 보통 이름을 통해서 아이피를 조회하는 역할을 함. 역도 가능한데, 이건 추적이나 확인할떄 보통사용하는데 보통은 반대임.

클라가 서버에 질의 하기전에 dns서버에 질의를함 "네이버 닷컴이 누구니" 클라이언트는 네이버 닷컴에 대한 데이터를 갖고 있지 않다는 것을 의미. 근데 보통 웹브라우저는 어느정도 캐쉬가 같이 있기 떄문에 항상 물어보지는 않고 없을때는 반드시 물어봄. 클라이언트가 dns서버에 주소에 대한 질의를 하면 그 주소를 보고서 ip주소를 내려줌.
이렇게 받은 클라이언트를 사용해서 아이피를 통해서 서버로 질의를 하게 됨. 서버는 그거에대한 웹페이지를 보여주게 됨. 

특정 컴퓨터(또는 네트워크로 연결된 임의의 장치)의 주소를 찾기 위해, 사람이 이해하기 쉬운 도메인 이름을 숫자로 된 식별 번호(IP주소)로 변환. 사용자가 편하게 심볼을 기억할 수 있는 도메인 네임을 사용하고 있따. 흔히 전화번호부에 비유됨.
dns서버는 전세계 많은 서버들에 퍼져있음. 종류도 다양함. 이거를 분산형 데이터베이스 시스템이라고 일컬음.

			-루트네임 서버
dns서버들 중에서도 최상위단에 속하는 서버들을 말함. 한국엔 없고 일본에 존재. 이것 덕분에 아이피 받아서 접속할 수 있다.

			-recursive query

dns가 루트서버가 아닐 가능성이 매우 높음. 한국에는 kt에서 운영하는 dns서버가 있고, 그 dns서버는 캐시라는 것을 갖고 있음. 일종의 이니셜 저장장치임. 만약 네이버 닷컴의 주소에 대한 정보를 가지고 있다면 주소에 대한 정보를 임시적으로 넣어놓고 리프레쉬를 주기적으로 해줌. 리프레쉬란 주기적으로 계속 개선한다는 이야기임. 다른 것이 바뀌었는지 확인하는 그런 애임. 그래서 캐싱기능을 사용해서 만약 데이터가 있으면 바로 응답을 해줌. 이 dns서버는 총체적인 데이터를 갖고 있는건 아니라서 이쪽 서버에 데이터가 없다 아이피가 없다 이러면 루트 서버와 네임서버이런 것들을 통해 질의하게 된다. 그래서 각각의 의미가 있음. 루트 서버는 보통 .com만 보고서 그에대한 질의를 보내줌. 뭐 .kr이라던가. 그다음에는 2차 도메인 이런ㅂ ㅏㅇ식으로 dnskr 캐싱을 유지하고 있음.

			-http/dns 프로토콜 분석(실습)
이론에 대해 간단하게 살펴봤고, 이제 분석실습해보자. 이 데이터는 dns와 http가 충분히 찍히도록 웹요청을 했던 그 내용을 패킷을 찍어서 놓은 것임. 여기서는 간단히 어떤 dns요청이 있었고 어떤 http요청이 있었는지 확인하도록 하겠다. 보면 칼리라는 웹사이트에 접속한걸 확인 할 수 있는데, 왜 갑자기 칼리라는 곳에 접속이 됐냐. 보면 웹브라우저가 실행하면 칼리쪽에 있는 사이트에 접속하게 됐음. 그래서 웹페이지를 열자마자 바로 여기서부터 질의가 돼서 ofensive0security로 접속이 됨. 그래서 쭉 이거에 대한 dns를 요청만 한거임. 그리고 뒤쪽에 보면 받은 데이터라고, 보면 됨. www.kali.com 이라는 도메인이 있는데 뒤에보면 아이피주소가 찎혀있음. 네임서버는여기를 활용했고, 다 있음. 어쩃든 여기에 대한 주소를 받아옴.
192.124.249.6

여기서 특징으로 볼만한게, a가 붙인게 있고 aaaa가 붙어 있는 것도 있음. a는 v4에 대한 주소를 요청한 것. 그래서 이 브라우저는 v4,v6의 호환을 제공하기 위해 v4와 v6에 대한 요청을 동시에  하는 중. a가 4개면 v6 하지만 아직까지도 받는것은 v4가 일반적. 우리가 아이피 레인 버전 체계에 대해서는 꽤 오래전 몇시간 전에 배웠다. 기억 안나면 다시 학습해보삼.

여기서도 프로토콜 대상으로 검색해보고 싶다 하면 dns에 대한 정보만 나옴. 내가 여러가지 웹사이트 접속했던게 기록에 남음. 

Http로 필터링 하면 dns에 대한 정보대신 http에 대한 정보를 상세히 확인 가능. 살펴보면 쿠키도 나오는데. http는  스테이트 리스방식으로 동작하는데 여기선 스테이트리스가 아님.
스테이트 리스 방식이란, 클라이언트가 서버에 요청했을대 데이터를 돌려줄떄 그게 접속 끝임.

클라이언트와 서버는 접속이 한번 끊김. 그러면은 클라이언트는 서버가, 서버는 클라이언트가 뭐뭐 어떤거에 접속했는지 기억해야함. 그리고 로그인에 대한 정보도 기억해야함 . 로그인 유지를 위해. 웹브라우저를 닫으면 왜 로그인이 끊기나? 쿠키값이 날아가 버려서. 단한번에 접속이 끝나는데도 불구하고 로그인을 유지할 수 있는 이유는 쿠키에 있는거임. 쿠키라는 것은 클라이언트에 대한 정보를 인식하기 위한 것. 그래서 클라이언트가 뭔가 서버에게 접속을 하면 서버는 클라이언트에게 쿠키 값을 줌. 이게 너의 회원번호야 이런거임. 찜찜발 번호달린 열쇠 같이. 사우나도 가고 헬스장도 가고. 사용할 수 있는 권한은 키와 번호때문임. 비슷하게 웹브라우저한번 나가면 다시 출입 불가함.  쿠기값중요하고 보안적으로도 쿠기값 유지하는 것을 이야기함.
302 상태메시지 뜬거 봄. 객체가 옮겨졌따. 다른페이지 접속하라고 로케이션으로 찍어줌. 여기 접속은 했지만 잘못된곳이니까 준 로케이션으로 이동해라. 원래 기존에 접속한곳은 daum.net 이엿음. 근데 이번엔 www.daum.net으로 이동하라고 함.

사용자 입장에서는 중간에 요청이 오는 걸 잘 못보고 바로 다음점 넷이 보이는 것처럼 그렇게 보인다. 리디렉션을 수행하라고 데이터를 받은다음에 실제로 여기에선 리다이렉션을 수행하고 잇음. 다음점 넷이라고 쓰여있는데, 다음점 넷이라고 적혀잇어서 쿠키값을 유지한상태로 계속 요청을 하고 있는 거다. 이런 요청들이 계속 진행되게 되고 html안에도 요청받은 대답 안에는 여러가지 jpeg파일이나 그런게 있을 수 잇음. 그래서 요청을 계속하고 있는거고 너무연연하지 마삼. 가장 사용자가 요청한 데이터를 보면 이거 하나 뿐임. 하나를 요청했을 뿐인데 뒤에있는 데이터는 쭉 따라온거임 왜냐하면 하이퍼링크로 연결이된게 아니라 jpeg파일등을 인클루드하는 기능들이 다 잇기 떄문에, 이런 것들이 총체적으로 포함되어 있다. 거기에대한 요청과
그런것들을 꾸준히 유지해야함.

컨티뉴에이션 같은게 있는데 이건 http로 요청을 유지하려는 그런거임. 우리가 얘기하는 것과는 동떨어져잇음.
이거 포스트 메시지를 받고 있는데, 빨로 tcp스트림으로 켜보삼. 이게 데이터가 큼. mpu가 말 첨에 잘못했는데 관련없다 했는데 관련 있는거임. mpu를 짜르다보니까 여러개의 패킷으로 보내게 된거 이렇게 포스트가 큰경우에는 나눠져서 보내진다. 그래서 tcp프레임으로 한번에 보는게 더 편할 수도 잇음. 
앞으로 우리가 주로 볼 데이터들은 http데이터일 가능성이 큼. 굉장히 짧은데, 짤은 시간만엧 촬영해서 그럼. 0초부터 시작을 하는데 데이터가 많지 않게 구성했으니까 여러분은 http의 구성에대해 살펴봐 

여기서는 아마 클라이언트가 51184로 접속을 했고 80번으로 데이터를 받은 것으로 보인다. 이렇게 http와 dns에 대해 맛만 봐봤따.

		-smb프로토콜 

약간 특별한데 원래 내 교육과정에 안들어가있었음. 분석할 일이 거의 없으니까. 근데얼마전에 큰일이 하나 터짐. 워너크라이 워너크립토가 터짐. 걔가 smb취약점을 사용함.  smb취약점을 사용했는데 이슈된 내용 안집고 넘어가기 그래서 넣음. 완벽한 데이터란 없음. 정확하게 이야기하면 익스플로러를 정확히 분석할만한 수준은 아니여도 smb통신이 어떻게 되고 있는지 정도는 살펴볼수 있는 그런 데이터 사용인데 어디서 익스플로잇 코드를 썼는지 정도는 추측할 수잇음 한번 살펴보자. 

			-SMB(Serve Message Block)
메시지 블럭을 서브하는 역할.
윈도우나 도스에서 파일이나 디렉터리 및 주변 장치(팩스나 프린터, 이런 윈도우에서 공유하는 시스템 홈네트워크 구축을 하면은 여러가지 장치들을 공유할 수 있또록 그렇게 설정이 되는데  그떄 사용되는 메시지 형식. 

Net bios는 smb 형식에 기반을 두고 있으며, 많은 네트워크 제품들도 smb사용. 우리 실습에서 주로 살펴볼 내용은 아니지만, smb가 여러군데에서 많이 사용되고 있기 때문에 한번 쯤 살펴보면 좋을 거라는 생각 듬. 
서로 다른 운영체제 사이에 파일을 공유할 수 있또록 하기 위해 smb를 사용.
msb는 대부분 마이크로 소프트 윈도우를 실행하고 있는 컴퓨터에서는 굉장히 많이 이용하게 됨. 윈도우 2003, win7, vista이상에서 사용하고 있고 xp에서도 이런 공유시스템 사용하고 있긴함. 프로토콜 관련 문서 Https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/Ms-SMB/[MS-SMB].pdf

smb도 홈네트워크 중에서도 홈주인이 있음. 홈뭐라고 하는데 어쩃든 서버가 있고 그리고 홈네트워크에 참여하는 클라이언트가 있음. Smb 홈네트워크를 구축하는데도 , 서버와 클라이언트 형식으로, 나뉘어서 있다. 라고 말할 수 잇음. 근데 워너크립트가 취약점을 이용해 막퍼졌는데 워너크립토도 사실상 보면 클라이언트가 서버를 공격하는 형태가 돼 잇음.

				-워너 크립토 유포 pcap 분석
					-워너크립토 기사

nsa(미 국가안보국)에서 유출된 공격도구를 사용한거. 워너크립토 랜섬웨어가 전세계확산되며 큰 논란이 됐음. 한국은 주말이 끼고 워낙 대처를 잘해서비교적 해외에 비해 내부에서 많이 퍼지진 않음. 근데 이터너 블루는 이 nsa의 해킹도구를 사용했음. 메타스플로잇이라는 도구에도 들어가 있어서 봤는데, 얘가 exe파일로 포함 돼 잇음. 내부를 분석하려면 정확하게 파일을 리버싱해야하지 않나 싶은데, 나는 네트워크 관련 일을 했따 보니까. 내부에 리버싱 관련한 부분들은 굳이 잘 다루지 않음. 이터널 블루가 발생시키는 smb프로토콜은 옹알옹알옹알
지금은 현제 패치가 된상태이다. 컴퓨터를 키기전에 랜선을 뽑고서 중요한 자료를 백업하고 인터넷 업데이틀 해라. 마이크로 소프트를 업데이트 해라 이런 지침이 내려왔엇음. 우리나라에서는 파급효과럴 못본 악성코드임. 


					-ms17-16취약점 살펴보기  (17년도에 16번쨰로 발생한 취약점
이게 어떤 취약점을 사용했는지 인터넷 검색하면 많이 볼 수 있음. 2017년3월 14일 보안 업데이트가 있었음. 영양 받는 취약성들이 적혀있고, 어떤식으로 동작하는지도 적혀 있음. 대략적인 정보만 갖고 있고, 아주 자세히 어떻게 익스플로잇하는지 잘 적혀있지 않음. 웹에서 찾아보다보면 많이 나오겠지 그래도.

분석 사례를 보자. 이거는 한참 난리가 있었으니까. Kill-switch for wanna cry? 킬 스위치라는 것도 주말간에 등장 했던것 같음. 그래서 어재 어떤 등록되있지 않은 도메인을 요청한것 같은데, 그 도메인을 등록해가지고 더이상 암호화 하지 않도록 킬 스위치를 했다. 근데 여기서는 그렇게 까지는 이야기 하지 않겠따. 그냥 이런식으로 분석했던 내용이고 실제로 보면 어떻게 이해되는지 정확히 볼 수 있을 거임.

전세계 이렇게 많은 나라에 퍼졌었다고 이야기 할 수 있음.\

					-워너크립토 유포 pcap분석
피캡파일이 많이 있음. 악성코드도 배포하고 그럴 수 있는데, 분석을 위한것들이지. 이번에 한번 우리가, 분석진행 해보겠음.
우리가 일단 워너크립터를 분석하기 전에 피피티로 정리해놈. 많이 복잡해서 피피티로 정리해놨는데 사실상 피티에서 다 설명하기 때문에 실습자체는 혼자 직접 해도됨. 나는 간단하게만 보겠음
생각 외로 패킷이 정제를 잘 해놈. 그래서 우리가 봐야할 패킷들만 잘 모아놈. "이거 이상해, 하거나 필터링 할 필요까진 전혀 없음" 바로 접속하면은 바로 파일열면 다음과 같은 내용도 보이고 하기 떄문에 , 별도로 어떻게 하라고는 설명 안드릴게/ 실제로 실습하는 내용 간단하고 나는 혹시 뺴먹는 내용 있을까봐, 그래서 피티를 보고 설명하는 방식으로함.

나도 smb자체가 보통 익숙하지 않음. smb에서 취약점 발생하는게 흔한건 아님. 그래서 smb가 어떤것들이 있고 어떤 프로토콜을 가지는지 익숙하지 않아서 피티 적은 내용 참고해서 진행함. 앞에 가장 앞자리 보게되면 smb가 쓰레웽 핸드 쉐이크로 시작하는ㄱ ㅓ 볼 수 있음. 소스가 204번이고 데스티가 203임 204가 203에 신패키지 요청하고 있음. 패키지 요청하는걸로봐서는 왼쪽이 클라이언트 오른쪽이 서버 임. 그래서 445ㅓㅂㄴ으로 통신하고 있음. 내용을 더 자세히 보면 신 패킷 날아감.  돌아오는 패킷은 신 애크 패킷. 그다음은 애키패킷을 하고 있음. 그래서 우리가 전형적으로 살펴볼 수 있는 쓰리 웨이 핸드 쉐이크로 티시피 연결을 시작,시도을 한다는것을 알 수 있다. 그다음으로 이제 살펴볼 프로토콜은 smb가 초기화되는 그런 프로토콜이라고 볼 수 있음. 익스플로잇 직전에 네트워크 트래픽이 몇번 오고가는데, smb프로토콜 자체가 이미 이렇게 앞에서 


C
1			Server
SMB_COM_NEGOTIATE Request
->
2
SMB_COM_NEGOTIATE Request
<-
3
SMB_COM_SESSION_SETUP_ANDX Request 1
[NTLM NEGOTIATE_MESSAGE]
->
4
SMB_COM_SESSION_SETUP_ANDX Request 1
[NTLM challenge_MESSAGE]
<-
5
SMB_COM_SESSION_SETUP_ANDX Request 2
[NTLM AUTHENTICATE MESSAGE]
->
6
SMB_COM_SESSION_SETUP_ANDX Request 2
<-

정형화된 틀이기 떄문이 이것까진 분석할 필요 없음. 일치한 내용들을 확인 할 수 있고 실제적인 패킷들에 대한 헤더를 밑에서 열어서 볼 수있는데 하나씩 눌러서 내용을 보는거임. 